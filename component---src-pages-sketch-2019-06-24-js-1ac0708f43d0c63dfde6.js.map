{"version":3,"sources":["webpack:///./src/pages/sketch/2019/06/24.js","webpack:///./node_modules/amp-is-object/is-object.js","webpack:///./node_modules/coordinate-systems/coordinate-systems.js","webpack:///./node_modules/amp-is-array/is-array.js","webpack:///./node_modules/amp-is-number/is-number.js","webpack:///./node_modules/amp-extend/extend.js"],"names":["sketch","p","setup","createCanvas","WEBGL","noStroke","draw","background","pointLight","min","frameCount","camera","apply","spherical","cart","concat","specularMaterial","i","SIZE","push","rotateX","TWO_PI","cos","rotateY","sin","translate","WEIGHT","box","pop","__webpack_exports__","_ref","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_0__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_3__","path","pathname","description","module","exports","obj","type","isArray","__webpack_require__","isNumber","isObject","extend","degPerRadian","Math","PI","Coordinate","config","isRadian","isDegree","_x","_y","_z","_r","_t","_p","pos","defineProperty","this","get","x","set","label","coords","Error","initialType","prototype","cartesian","arguments","options","temp","cartesian2d","cartesian3d","polarToCart2d","polar","cylindrical","sphericalToCart3d","cyl","cartesian2dToPolar","center","cartesian3dToCylindrical","sphericalToCylindrical","pol","sph","cartesian3dToSpherical","cylindricalToSpherical","baseCoord","arrToNumeric","length","nums","num","TypeError","parseFloat","rt","r","t","xy","y","sqrt","atan2","xyz","z","x2","y2","z2","rtz","sr","sp","rtp","cr","toString","nativeIsArray","Array","call","source","prop"],"mappings":"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","file":"component---src-pages-sketch-2019-06-24-js-1ac0708f43d0c63dfde6.js","sourcesContent":["import React from \"react\";\nimport { spherical } from \"coordinate-systems\";\nimport SketchLayout from \"~components/sketch-layout\";\n\nconst sketch = function(p) {\n  const SPEED = 0.075;\n  const WEIGHT = 2;\n\n  p.setup = function() {\n    p.createCanvas(660, 840, p.WEBGL);\n    p.noStroke();\n  };\n\n  p.draw = function() {\n    p.background(0);\n\n    p.pointLight(\n      p.min(p.frameCount, 255),\n      p.min(p.frameCount, 255),\n      p.min(p.frameCount, 255),\n      1,\n      0,\n      0\n    );\n\n    p.camera(...spherical([150, 0, 0]).cart(), 0, 0, 0, 0, 1, 0);\n\n    p.specularMaterial(255, 255, 255);\n\n    for (let i = 1; i < 20; i++) {\n      const SIZE = i * WEIGHT * 2;\n      p.push();\n      p.rotateX(\n        ((p.TWO_PI * 2) / WEIGHT) * i * p.cos((p.frameCount / 400) * SPEED)\n      );\n      p.rotateY(\n        ((p.TWO_PI * 2) / WEIGHT) * i * p.sin((p.frameCount / 200) * SPEED)\n      );\n      p.push();\n      p.translate(0, -(SIZE / 2) + WEIGHT / 2, 0);\n      p.box(SIZE, WEIGHT, WEIGHT);\n      p.pop();\n      p.push();\n      p.translate(0, SIZE / 2 - WEIGHT / 2, 0);\n      p.box(SIZE, WEIGHT, WEIGHT);\n      p.pop();\n      p.push();\n      p.translate(-(SIZE / 2) + WEIGHT / 2, 0, 0);\n      p.box(WEIGHT, SIZE, WEIGHT);\n      p.pop();\n      p.push();\n      p.translate(SIZE / 2 - WEIGHT / 2, 0, 0);\n      p.box(WEIGHT, SIZE, WEIGHT);\n      p.pop();\n      p.pop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","module.exports = function isObject(obj) {\n    var type = typeof obj;\n    return !!obj && (type === 'function' || type === 'object');\n};\n","\"use strict\";\nvar isArray = require('amp-is-array');\nvar isNumber = require('amp-is-number');\nvar isObject = require('amp-is-object');\nvar extend = require('amp-extend');\nvar degPerRadian = 180 / Math.PI;\n\n/**\n * @constructor Coordinate\n * @description Defines object which can convert between coordinate systems.\n * It is recommended to use one of the Coodinate.STATIC_CONSTRUCTOR functions\n * to generate your first coordinate before conversions. e.g. Coodinate.spherical(...)\n * @param {Object} config\n * {\n *     label: 'type of initial coordinate',\n *     coords: {\n *         x/y/z/r/t/p: 'k-v pairs'\n *     },\n *     isDegree: Boolean\n * }\n */\nvar Coordinate = function (config) {\n    var isRadian,\n        isDegree,\n        pos = {},\n        _x, _y, _z, _r, _t, _p;\n\n    // Override select setters/getts\n    Object.defineProperty(this, \"isRadian\", {\n        get: function (x) { return isRadian; },\n        set: function (x) {\n            isRadian = !!x;\n            if (isDegree !== !x) { isDegree = !x; } // jshint ignore:line\n        }\n    });\n    Object.defineProperty(this, \"isDegree\", {\n        get: function (x) { return isDegree; },\n        set: function (x) {\n            isDegree = x;\n            if (isRadian !== !x) { isRadian = !x; } // jshint ignore:line\n        }\n    });\n    Object.defineProperty(pos, \"cartesian2d\", {\n        get: function (x) { return [_x, _y]; },\n        set: function (x) { _x = x[0]; _y = x[1]; }\n    });\n    Object.defineProperty(pos, \"cartesian3d\", {\n        get: function (x) { return [_x, _y, _z]; },\n        set: function (x) { _x = x[0]; _y = x[1]; _z = x[2]; }\n    });\n    Object.defineProperty(pos, \"polar\", {\n        get: function (x) { return [_r, _t]; },\n        set: function (x) { _r = x[0]; _t = x[1]; }\n    });\n    Object.defineProperty(pos, \"cylindrical\", {\n        get: function (x) { return [_r, _t, _z]; },\n        set: function (x) { _r = x[0]; _t = x[1]; _z = x[2]; }\n    });\n    Object.defineProperty(pos, \"spherical\", {\n        get: function (x) { return [_r, _t, _p]; },\n        set: function (x) { _r = x[0]; _t = x[1]; _p = x[2]; }\n    });\n\n    // init from config\n    if (config.isDegree && !config.isRadian) {\n        this.isDegree = true;\n    } else {\n        this.isRadian = true;\n    }\n    if (!config.label || !config.coords) {\n        throw new Error(\"no coordinate type defined\");\n    }\n    this.initialType = config.label;\n    this.pos = pos;\n    this.pos[config.label] = config.coords;\n};\n\n\n\n/**\n * @method cartesian\n * Converts current coordinate to cartesian\n * @function cartesian\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cartesian = function () { return this.cart.apply(this, arguments); };\n/**\n * @method cart\n * Converts current coordinate to cartesian\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cart = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            return this.pos.cartesian2d;\n        case 'cartesian3d':\n            return this.pos.cartesian3d;\n        case 'polar':\n            this.pos.cartesian2d = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n            return this.pos.cartesian2d;\n        case 'cylindrical':\n            temp = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n            this.pos.cartesian3d = [temp[0], temp[1], this.pos.cylindrical[2]];\n            return this.pos.cartesian3d;\n        case 'spherical':\n            this.pos.cartesian3d = Coordinate.sphericalToCart3d(this.pos.spherical, this.isDegree);\n            return this.pos.cartesian3d;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n\n/**\n * @method cylindrical\n * Converts current coordinate to cylindrical\n * @function cylindrical\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cylindrical = function () { return this.cyl.apply(this, arguments); };\n/**\n * @method cyl\n * Converts current coordinate to cylindrical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cyl = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            this.pos.cylindrical = [temp[0], temp[1], 0];\n            return this.pos.cylindrical;\n        case 'cartesian3d':\n            this.pos.cylindrical = Coordinate.cartesian3dToCylindrical(this.pos.cartesian3d, this.isDegree, options.center);\n            return this.pos.cylindrical;\n        case 'polar':\n            temp = this.pos.polar;\n            return [temp[0], temp[1], 0];\n        case 'cylindrical':\n            return this.pos.cylindrical;\n        case 'spherical':\n            this.pos.cylindrical = Coordinate.sphericalToCylindrical(this.pos.spherical, this.isDegree);\n            return this.pos.cylindrical;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n/**\n * @method pol\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.pol = function () { return this.polar.apply(this, arguments); };\n/**\n * @method polar\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.polar = function (options) {\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            this.pos.polar = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            return this.pos.polar;\n        case 'polar':\n            return this.pos.polar;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n\n/**\n * @method spherical\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.spherical = function () { return this.sph.apply(this, arguments); };\n/**\n * @method sph\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.sph = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            this.pos.spherical = [temp[0], temp[1], 0];\n            return this.pos.spherical;\n        case 'cartesian3d':\n            this.pos.spherical = Coordinate.cartesian3dToSpherical(this.pos.cartesian3d, this.isDegree, options.center);\n            return this.pos.spherical;\n        case 'polar':\n            temp = this.pos.polar;\n            return [temp[0], temp[1], 0];\n        case 'cylindrical':\n            this.pos.spherical = Coordinate.cylindricalToSpherical(this.pos.cylindrical, this.isDegree);\n            return this.pos.spherical;\n        case 'spherical':\n            return this.pos.spherical;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n///\n/// Static Constructor Functions\n///\n\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cartesian = function(x) { return Coordinate.cart(x); };\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cart = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length < 2 || options.coords.length > 3) {\n            throw new Error('expected exactly 2 or exactly 3 cartesian options');\n        }\n        baseCoord = {\n            label: 'cartesian2d',\n            options: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        if (options.coords.length === 2) {\n            return new Coordinate(baseCoord);\n        }\n        baseCoord.label = 'cartesian3d';\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [x,y,(z?)] coords');\n};\n\n\n\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cylindrical = function(x) { return Coordinate.cyl(x); };\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cyl = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 3) {\n            throw new Error('expected exactly 3 params [r, t, z]');\n        }\n        baseCoord = {\n            label: 'cylindrical',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [r, t, z] coords');\n};\n\n\n\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.polar = function(x) { return Coordinate.pol(x); };\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.pol = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 2) {\n            throw new Error('expected exactly 2 params [r, t]');\n        }\n        baseCoord = {\n            label: 'polar',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected array of [r, t] options');\n};\n\n\n\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.spherical = function(options) { return Coordinate.sph(options); };\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.sph = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 3) {\n            throw new Error('expected exactly 3 params [r, t, p]');\n        }\n        baseCoord = {\n            label: 'spherical',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [r, t, p] coords');\n};\n\n\n\n/**\n * Mutates an array of number-like looking values to purely numeric array\n * @example\n * [5, '2.4', '0'] => [5, 2.4, 0]\n * @param  {Array} nums\n * @return {undefined}\n */\nCoordinate.arrToNumeric = function(nums) {\n    var num;\n    if (!isArray(nums)) {\n        throw new TypeError(\"expected array of number-like values\");\n    }\n    for (var i = nums.length - 1; i >= 0; i--) {\n        num = nums[i];\n        if (typeof num === 'string') {\n            num = parseFloat(num);\n        }\n        if (!isNumber(num)) {\n            throw new TypeError(num + ' not numeric or numeric-like');\n        }\n    }\n};\n\n\n\n/**\n * Convert polar to 2d cartesian coordinates\n * @param  {Array}   rt        [radis, theta]\n * @param  {Boolean} isDegree specifies units\n * @return {Array}  [x, y]\n */\nCoordinate.polarToCart2d = function(rt, isDegree) {\n    var r, t, x, y;\n    r = rt[0];\n    t = rt[1];\n    if (isDegree) {\n        t = t * (1/degPerRadian);\n    }\n    x = r * Math.cos(t);\n    y = r * Math.sin(t);\n    return [x, y];\n};\n\n\n\n/**\n * Convert cartesian 2d to polar coordinates\n * @param  {Array}  xy\n * @param {Boolean=} isDegree overrides default radian theta assumption\n * @param  {Array=} center [x, y] coords of center of circle.  Defaults to [0, 0],\n * however may be offset.  Note. Such functionality not supported yet for converting\n * polar to cartesian\n * @return {Array}  [radius, theta]\n */\nCoordinate.cartesian2dToPolar = function(xy, isDegree, center) {\n    var x, y, r, t;\n    if (!isArray(xy) && xy.length !== 2) {\n        throw new TypeError('expected [x, y] xy array');\n    }\n    x = xy[0];\n    y = xy[1];\n    if (center && !isArray(center) && center.length !== 2) {\n        throw new TypeError('expected [x, y] center array');\n    }\n    if (center) {\n        x = x - center[0];\n        y = y - center[1];\n    }\n    r = Math.sqrt(x*x + y*y);\n    t = Math.atan2(y, x);\n    if (isDegree) {\n        t = t * degPerRadian;\n    }\n    return [r, t];\n};\n\n\n\n/**\n * Convert 3d cartesian to 3d cylindrical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y] coords of center of circle\n * @return {Array}      [radius, theta, z]\n */\nCoordinate.cartesian3dToCylindrical = function (xyz, isDegree, center) {\n    var x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        rt;\n    rt = Coordinate.cartesian2dToPolar([x, y], isDegree, center);\n    return [rt[0], rt[1], z];\n};\n\n\n\n/**\n * Convert 3d cartesian to 3d spherical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y, z] coords of center of circle\n * @return {Array}      [radius, theta, phi]\n */\nCoordinate.cartesian3dToSpherical = function (xyz, isDegree, center) {\n    if (center && center.length !== 3) {\n        throw new Error('expected center value to have [x, y, z] coords' +\n            'for locating sphere center');\n    }\n    var x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        x2, y2, z2,\n        r, t, p;\n    if (center) {\n        x = x - center[0];\n        y = y - center[1];\n        z = z - center[2];\n    }\n    x2 = x*x; y2 = y*y; z2 = z*z;\n    r = Math.sqrt(x2 + y2 + z2);\n    if (!r) {\n        p = t = 0;\n    } else {\n        t = Math.atan2(y,x);\n        p = Math.atan2(Math.sqrt(x2 + y2), z);\n        if (isDegree) {\n            t = t * degPerRadian;\n            p = p * degPerRadian;\n        }\n    }\n    return [r, t, p];\n};\n\n\n\n/**\n * Convert a cylindrical to a spherical coordinates\n * @param  {Array}   rtz\n * @param  {Boolean} isDegree\n * @return {Array}   [radius, theta, phi]\n */\nCoordinate.cylindricalToSpherical = function(rtz, isDegree) {\n    var r = rtz[0], t = rtz[1], z = rtz[2];\n    var sr, sp; // sphere radius, sphere theta...\n    if (isDegree) {\n        t = t / degPerRadian;\n    }\n    sr = Math.sqrt(r*r + z*z);\n    sp = Math.atan2(r, z);\n    if (isDegree) {\n        sp = sp * degPerRadian;\n        t = t * degPerRadian;\n    }\n    return [sr, t, sp];\n};\n\n\n\n/**\n * Convert spherical to a cartesian coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\nCoordinate.sphericalToCart3d = function (rtp, isDegree) {\n    var r = rtp[0], t = rtp[1], p = rtp[2],\n        x,y,z;\n    if (isDegree) {\n        t = t / degPerRadian;\n        p = p / degPerRadian;\n    }\n    x = r * Math.sin(p) * Math.cos(t);\n    y = r * Math.sin(p) * Math.sin(t);\n    z = r * Math.cos(p);\n    return [x, y, z];\n};\n\n\n\n/**\n * Convert spherical to cylindrical coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\nCoordinate.sphericalToCylindrical = function (rtp, isDegree) {\n    var r = rtp[0], t = rtp[1], p = rtp[2],\n        cr, z;\n    if (isDegree) {\n        t = t / degPerRadian;\n        p = p / degPerRadian;\n    }\n    cr = r * Math.sin(p);\n    z = r * Math.cos(p);\n    if (isDegree) {\n        t = t * degPerRadian;\n        p = p * degPerRadian;\n    }\n    return [cr, t, z];\n};\n\nmodule.exports = Coordinate;\n","var toString = Object.prototype.toString;\nvar nativeIsArray = Array.isArray;\n\n\nmodule.exports = nativeIsArray || function isArray(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n","var toString = Object.prototype.toString;\n\n\nmodule.exports = function isNumber(obj) {\n    return toString.call(obj) === '[object Number]';\n};\n","var isObject = require('amp-is-object');\n\n\nmodule.exports = function(obj) {\n    if (!isObject(obj)) return obj;\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n        source = arguments[i];\n        for (prop in source) {\n            obj[prop] = source[prop];\n        }\n    }\n    return obj;\n};\n"],"sourceRoot":""}