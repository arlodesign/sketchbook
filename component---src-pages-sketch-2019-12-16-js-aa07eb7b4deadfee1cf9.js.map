{"version":3,"sources":["webpack:///./src/lib/polarToCartesian.js","webpack:///./src/lib/lerpLine.js","webpack:///./src/pages/sketch/2019/12/16.js"],"names":["polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y","polarToCartesian","p","x1","y1","x2","y2","rate","showFirstDot","noisy","thisRate","max","dist","l","random","point","lerp","sketch","w","h","HUE","HUE_COUNT","floor","HUE_LINES","SIZES","grid","GRID","Doodad","size","this","hue","colors","Array","fill","map","_","i","color","square","push","translate","rotate","PI","noStroke","lerpColor","blendMode","SCREEN","stroke","lerpLine","noise","frameCount","pop","setup","createCanvas","background","colorMode","HSL","width","height","xx","yy","visited","draw","concat","filter","length","overlap","s","line","HARD_LIGHT","circle","noLoop","location","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2019-12-16-js-aa07eb7b4deadfee1cf9.js","sourcesContent":["const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","/**\n * Creates a line of points at a specified interval (the rate)\n *\n * @param {obj} p The current p5.js drawing context\n * @param {*} x1\n * @param {*} y1\n * @param {*} x2\n * @param {*} y2\n * @param {*} rate Number between 0 and 1 to determine how often to draw a point\n * @param {*} showFirstDot Defaults to true\n * @param {*} noisy Defaults to true\n */\nexport default function(\n  p,\n  x1,\n  y1,\n  x2,\n  y2,\n  rate,\n  showFirstDot = true,\n  noisy = true\n) {\n  const thisRate = Math.max(rate, 0.01 / p.dist(x1, y1, x2, y2));\n\n  for (let l = 0; l < 1; l += thisRate) {\n    if (l === 0 && !showFirstDot) continue;\n    if ((noisy && p.random() > l) || !noisy) {\n      p.point(p.lerp(x1, x2, l), p.lerp(y1, y2, l));\n    }\n  }\n}\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport lerpLine from \"~lib/lerpLine\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  const HUE = p.random();\n  const HUE_COUNT = p.floor(p.random(3, 7));\n  const HUE_LINES = p.floor(p.random(HUE_COUNT));\n\n  const GRID = 15;\n  const SIZES = [1, 2, 3, 7];\n  const MARGIN = GRID * 3.5;\n\n  let grid = [];\n  let w;\n  let h;\n  let y = MARGIN;\n\n  class Doodad {\n    constructor(x, y, size) {\n      this.x = x * GRID;\n      this.y = y * GRID;\n      this.size = size * GRID;\n\n      const hue = HUE * p.floor(p.random(HUE_COUNT));\n      this.colors = Array(2)\n        .fill()\n        .map((_, i) =>\n          p.color(\n            p.random() < 0.3 ? HUE * p.floor(p.random(HUE_COUNT)) : hue,\n            HUE_COUNT,\n            (HUE_COUNT / 2) * i\n          )\n        );\n\n      this.square();\n    }\n    square() {\n      p.push();\n      p.translate(this.x + this.size / 2, this.y + this.size / 2);\n      p.rotate(p.random([0, p.PI]));\n      p.translate(-this.size / 2, -this.size / 2);\n\n      p.noStroke();\n      p.fill(p.lerpColor(this.colors[0], this.colors[1], 0.5));\n      p.square(0, 0, this.size);\n\n      p.blendMode(p.SCREEN);\n      for (let y = 0; y <= this.size; y++) {\n        p.stroke(p.lerpColor(this.colors[0], this.colors[1], y / this.size));\n        lerpLine(\n          p,\n          0,\n          y,\n          this.size,\n          y,\n          p.noise(p.frameCount / 100, y) / this.size\n        );\n      }\n\n      p.pop();\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.background(0);\n    p.colorMode(p.HSL, HUE_COUNT);\n\n    w = p.floor(p.width / GRID);\n    h = p.floor(p.height / GRID);\n\n    for (let xx = 0; xx < w; xx++) {\n      grid.push([]);\n      for (let yy = 0; yy < h; yy++) {\n        grid[xx].push({\n          x: xx,\n          y: yy,\n          visited: false,\n        });\n      }\n    }\n  };\n\n  p.draw = function() {\n    if ([].concat(...grid).filter(({ visited }) => !visited).length) {\n      const { x, y } = p.random(\n        [].concat(...grid).filter(({ visited }) => !visited)\n      );\n\n      if (!grid[x][y].visited) {\n        let size = Math.max(...SIZES);\n        let overlap;\n\n        do {\n          overlap = false;\n          for (let xx = x; xx < size + x; xx++) {\n            for (let yy = y; yy < size + y; yy++) {\n              if (x + size > w || y + size > h || grid[xx][yy].visited) {\n                overlap = true;\n              }\n            }\n          }\n          if (overlap) {\n            size = Math.max(...SIZES.filter(s => s < size));\n          }\n        } while (overlap);\n\n        new Doodad(x, y, size);\n\n        for (let xx = x; xx < size + x; xx++) {\n          for (let yy = y; yy < size + y; yy++) {\n            grid[xx][yy].visited = true;\n          }\n        }\n      }\n    } else {\n      p.stroke(\n        HUE_LINES,\n        HUE_COUNT,\n        p.noise(0.03, y / 100) * HUE_COUNT,\n        HUE_COUNT / 2\n      );\n      p.line(MARGIN, y, p.width - MARGIN, y);\n      y++;\n\n      if (y > p.height - MARGIN) {\n        p.noStroke();\n        p.blendMode(p.HARD_LIGHT);\n\n        for (let i = HUE_COUNT; i > 0; i--) {\n          p.fill(i, HUE_COUNT, HUE_COUNT - 1, HUE_COUNT * 0.666);\n          p.circle(\n            p.random(p.width),\n            p.random(p.height),\n            (p.width / HUE_COUNT) * i\n          );\n        }\n        p.noLoop();\n      }\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}