{"version":3,"sources":["webpack:///./src/pages/sketch/2019/04/25.js","webpack:///./src/lib/polarToCartesian.js"],"names":["noise","OpenSimplexNoise","Date","now","sketch","p","hue","random","alpha","a","i","setup","createCanvas","background","colorMode","HSB","blendMode","OVERLAY","strokeWeight","draw","translate","width","height","stroke","noiseVal","map","noise4D","cos","TWO_PI","frameCount","sin","polarToCartesian","x","y","flip","l","beginShape","vertex","lerp","endShape","noLoop","location","path","pathname","description","polarToCartesianX","center","angle","distance","Math","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray"],"mappings":"6FAAA,8EAKMA,EAAQ,IAAIC,IAAiBC,KAAKC,OAElCC,EAAS,SAASC,GACtB,IAEIC,EAAMD,EAAEE,OAAO,GAAI,KACnBC,EAAQ,EACRC,EAAI,EACJC,EAAI,EAERL,EAAEM,MAAQ,WACRN,EAAEO,aAAa,IAAK,KACpBP,EAAEQ,WAAW,KACbR,EAAES,UAAUT,EAAEU,KACdV,EAAEW,UAAUX,EAAEY,SACdZ,EAAEa,aAAa,IAGjBb,EAAEc,KAAO,WACPd,EAAEe,UAAUf,EAAEgB,MAAQ,EAAGhB,EAAEiB,OAAS,GACpCjB,EAAEkB,OAAOjB,EAAK,IAAK,IAAKE,GAiBxB,IAfA,IAAMgB,EAAWnB,EAAEoB,IACjBzB,EAAM0B,SACHhB,EAAI,IAAO,IACXA,EAAI,IAAO,GACZL,EAAEsB,IAAItB,EAAEuB,QAAUvB,EAAEwB,WAvBZ,MAwBRxB,EAAEyB,IAAIzB,EAAEuB,QAAUvB,EAAEwB,WAxBZ,QA0BT,EACD,EACA,EACA,GAdgB,EAgBDE,YAAiB,EAAG,EAAGtB,EAAGJ,EAAEgB,MAAQG,GAA7CQ,EAhBU,EAgBVA,EAAGC,EAhBO,EAgBPA,EACPC,GAAO,EAEFC,EAAI,EAAGA,EAAI,EAAGA,GAAKX,EAAW,EAAI,KACzCU,GAAQ7B,EAAE+B,aACV/B,EAAEgC,OAAOhC,EAAEiC,KAAK,EAAGN,EAAGG,GAAI9B,EAAEiC,KAAK,EAAGL,EAAGE,KACtCD,GAAQ7B,EAAEkC,WACXL,GAAQA,EAEV7B,EAAEkC,YAEF9B,GAAKJ,EAAEuB,OA1CK,KA2CJvB,EAAEuB,SACRlB,GAAK,IACLF,GAAS,EACTC,EAAI,GACJH,GAAO,IACG,GAAGD,EAAEmC,YAKN,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAcrC,OAAQA,EAAQsC,KAAMD,EAASE,SAAUC,YAAY,O,kCC9DrE,0GAAMC,EAAoB,SAACC,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKtB,IAAIoB,GAASC,GAE9BE,EAAoB,SAACJ,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKnB,IAAIiB,GAASC,GAsB9BG,EAA0B,SAC9BC,EACAC,EACAN,EACAO,EACAC,EACAC,QACG,IADHA,OAAU,GAEV,IAAMxB,EAAIoB,EAAUH,KAAKtB,IAAIoB,GAASO,EAChCrB,EAAIoB,EAAUJ,KAAKnB,IAAIiB,GAASQ,EACtC,OAAOC,EAAU,CAACxB,EAAGC,GAAK,CAAED,IAAGC,MAIlBF,IAzBU,SACvBqB,EACAC,EACAN,EACAC,EACAQ,QACG,IADHA,OAAU,GAEV,IAAMxB,EAAIa,EAAkBO,EAASL,EAAOC,GACtCf,EAAIiB,EAAkBG,EAASN,EAAOC,GAC5C,OAAOQ,EAAU,CAACxB,EAAGC,GAAK,CAAED,IAAGC","file":"component---src-pages-sketch-2019-04-25-js-c1bbf26e081765a58996.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport OpenSimplexNoise from \"open-simplex-noise\";\n\nconst noise = new OpenSimplexNoise(Date.now());\n\nconst sketch = function(p) {\n  const STEPS = 1000;\n\n  let hue = p.random(67, 100);\n  let alpha = 5;\n  let a = 0;\n  let i = 0;\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.background(128);\n    p.colorMode(p.HSB);\n    p.blendMode(p.OVERLAY);\n    p.strokeWeight(1);\n  };\n\n  p.draw = function() {\n    p.translate(p.width / 2, p.height / 2);\n    p.stroke(hue, 100, 100, alpha);\n\n    const noiseVal = p.map(\n      noise.noise4D(\n        (i + 0.1) / 10,\n        (i + 0.2) / 10,\n        p.cos(p.TWO_PI * (p.frameCount / STEPS)),\n        p.sin(p.TWO_PI * (p.frameCount / STEPS))\n      ),\n      -1,\n      1,\n      0,\n      1\n    );\n    const { x, y } = polarToCartesian(0, 0, a, p.width * noiseVal);\n    let flip = true;\n\n    for (let l = 0; l < 1; l += noiseVal / 4 + 0.0000001) {\n      flip && p.beginShape();\n      p.vertex(p.lerp(0, x, l), p.lerp(0, y, l));\n      !flip && p.endShape();\n      flip = !flip;\n    }\n    p.endShape();\n\n    a += p.TWO_PI / STEPS;\n    if (a > p.TWO_PI) {\n      i += 1000;\n      alpha /= 2;\n      a = 0;\n      hue -= 33;\n      if (hue < 0) p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}