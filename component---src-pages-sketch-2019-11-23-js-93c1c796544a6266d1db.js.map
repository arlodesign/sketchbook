{"version":3,"sources":["webpack:///./node_modules/bezier-easing/src/index.js","webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2019/11/23.js","webpack:///./src/lib/lineIntersection.js"],"names":["float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","LinearEasing","x","module","exports","mX1","mY1","mX2","mY2","Error","sampleValues","Array","i","getTForX","aX","intervalStart","currentSample","kSplineTableSize","guessForT","initialSlope","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","Math","abs","binarySubdivide","polarToCartesianX","center","angle","distance","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","y","polarToCartesian","ease","bezierEasing","sketch","p","drawing","lastPoint","HUE","random","circles","viewGuides","Circle","rate","radius","this","_radius","direction","sizeFunction","draw","circle","animLoop","theta","setup","createCanvas","frameRate","createGraphics","width","height","colorMode","HSL","blendMode","HARD_LIGHT","strokeWeight","properties","shuffle","floor","push","createLoop","background","mid","map","cA","cB","lerp","position","thisPoint","lineIntersection","stroke","line","image","frameCount","DURATION","noLoop","noFill","forEach","console","info","mousePressed","location","path","pathname","description","x1","y1","x2","y2","x3","y3","x4","y4","uA","uB"],"mappings":"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","file":"component---src-pages-sketch-2019-11-23-js-93c1c796544a6266d1db.js","sourcesContent":["require(\"core-js/modules/es6.typed.float32-array\");\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nfunction LinearEasing(x) {\n  return x;\n}\n\nmodule.exports = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport \"p5.createloop\";\nimport lineIntersection from \"~lib/lineIntersection\";\nimport bezierEasing from \"bezier-easing\";\n\nconst ease = bezierEasing(0, 1, 1, 0);\nconst DURATION = 1800;\n\nconst sketch = function(p) {\n  const HUE = p.random();\n\n  let drawing;\n  let lastPoint;\n  let circles = [];\n  let viewGuides = true;\n\n  class Circle {\n    constructor(x, y, rate, radius) {\n      this.centerX = x;\n      this.centerY = y;\n      this._radius = radius;\n      this.rate = rate;\n      this.direction = p.random([1, -1]);\n      this.sizeFunction = p.random([Math.sin, Math.cos]);\n    }\n    get position() {\n      return polarToCartesian(\n        this.centerX,\n        this.centerY,\n        p.animLoop.theta * this.rate * this.direction,\n        this.radius\n      );\n    }\n    get radius() {\n      return this._radius * ((this.sizeFunction(p.animLoop.theta / 2) + 1) / 2);\n    }\n    draw() {\n      p.circle(this.centerX, this.centerY, this.radius * 2);\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.frameRate(60);\n    drawing = p.createGraphics(p.width, p.height);\n    drawing.colorMode(p.HSL, 1);\n    drawing.blendMode(p.HARD_LIGHT);\n    drawing.strokeWeight(0.5);\n\n    const properties = p.shuffle([\n      [1, p.random(p.width / 20, p.width / 10)],\n      [p.floor(p.random(3, 7)), p.random(p.width / 2, p.width)],\n      [p.floor(p.random(500, 1000)), p.random(p.width, p.width * 2)],\n    ]);\n\n    circles.push(new Circle(0, 0, ...properties[0]));\n    circles.push(new Circle(p.width, 0, ...properties[1]));\n    circles.push(new Circle(p.width / 2, p.height * 1.5, ...properties[2]));\n\n    p.createLoop(DURATION);\n  };\n\n  /*\n\n               mid[0]\n  circle[0] ---------- circle[1]\n            \\        /\n             \\      /\n      mid[2]  \\    / mid[1]\n               \\  /\n                \\/\n             circle(2)\n\n  */\n\n  p.draw = function() {\n    p.background(0);\n\n    let mid = circles.map((cA, i) => {\n      let cB = circles[i === 2 ? 0 : i + 1];\n      return {\n        x: p.lerp(cA.position.x, cB.position.x, 0.5),\n        y: p.lerp(cA.position.y, cB.position.y, 0.5),\n      };\n    });\n\n    const thisPoint = lineIntersection(\n      circles[0].position.x,\n      circles[0].position.y,\n      mid[1].x,\n      mid[1].y,\n      circles[1].position.x,\n      circles[1].position.y,\n      mid[2].x,\n      mid[2].y\n    );\n    if (lastPoint) {\n      drawing.stroke(\n        HUE,\n        p.abs(p.sin(p.animLoop.theta)),\n        p.abs(p.cos(p.animLoop.theta)),\n        ease(p.abs(p.sin(p.animLoop.theta)))\n      );\n      drawing.line(thisPoint.x, thisPoint.y, lastPoint.x, lastPoint.y);\n      p.image(drawing, 0, 0);\n    }\n    lastPoint = thisPoint;\n\n    if (p.frameCount > DURATION * 60) {\n      p.noLoop();\n      viewGuides = false;\n    }\n\n    if (viewGuides) {\n      p.stroke(\"red\");\n      p.noFill();\n      circles.forEach((cA, i) => {\n        let cB = circles[i === 2 ? 0 : i + 1];\n        p.circle(cA.centerX, cA.centerY, cA.radius * 2);\n        p.line(cA.position.x, cA.position.y, cB.position.x, cB.position.y);\n        p.circle(mid[i].x, mid[i].y, 5);\n      });\n      p.line(circles[0].position.x, circles[0].position.y, mid[1].x, mid[1].y);\n      p.line(circles[1].position.x, circles[1].position.y, mid[2].x, mid[2].y);\n      p.line(circles[2].position.x, circles[2].position.y, mid[0].x, mid[0].y);\n    }\n\n    if (p.frameCount % 100 === 0) {\n      console.info(p.frameCount + \" of \" + DURATION * 60);\n    }\n  };\n\n  p.mousePressed = function() {\n    viewGuides = !viewGuides;\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout\n    sketch={sketch}\n    path={location.pathname}\n    description=\"Click or tap canvas to toggle guides.\"\n  />\n);\n","/**\n *\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x4\n * @param {number} y4\n */\nexport default function lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n  const uA =\n    ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) /\n    ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n  const uB =\n    ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) /\n    ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n\n  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n    return { x: x1 + uA * (x2 - x1), y: y1 + uA * (y2 - y1) };\n  }\n  return { x: null, y: null };\n}\n"],"sourceRoot":""}