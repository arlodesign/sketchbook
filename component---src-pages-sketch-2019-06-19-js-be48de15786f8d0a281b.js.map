{"version":3,"sources":["webpack:///./src/pages/sketch/2019/06/19.js","webpack:///./node_modules/amp-is-object/is-object.js","webpack:///./node_modules/coordinate-systems/coordinate-systems.js","webpack:///./node_modules/amp-is-array/is-array.js","webpack:///./node_modules/amp-is-number/is-number.js","webpack:///./node_modules/amp-extend/extend.js"],"names":["sketch","p","points","initPoints","setup","createCanvas","WEBGL","Array","from","random","TWO_PI","concat","draw","background","directionalLight","min","frameCount","cos","sin","camera","noStroke","fill","specularMaterial","forEach","pt","i","v","createVector","apply","spherical","cart","normalize","push","translate","map","c","rotateX","atan2","y","z","cylinder","noise","x","pop","__webpack_exports__","_ref","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_3__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_6__","path","pathname","description","module","exports","obj","type","isArray","require","isNumber","isObject","extend","degPerRadian","Math","PI","Coordinate","config","isRadian","isDegree","_x","_y","_z","_r","_t","_p","pos","defineProperty","this","get","set","label","coords","Error","initialType","prototype","cartesian","arguments","options","temp","cartesian2d","cartesian3d","polarToCart2d","polar","cylindrical","sphericalToCart3d","cyl","cartesian2dToPolar","center","cartesian3dToCylindrical","sphericalToCylindrical","pol","sph","cartesian3dToSpherical","cylindricalToSpherical","baseCoord","arrToNumeric","length","nums","num","TypeError","parseFloat","rt","r","t","xy","sqrt","xyz","x2","y2","z2","rtz","sr","sp","rtp","cr","toString","nativeIsArray","call","source","prop"],"mappings":"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","file":"component---src-pages-sketch-2019-06-19-js-be48de15786f8d0a281b.js","sourcesContent":["import React from \"react\";\nimport { spherical } from \"coordinate-systems\";\nimport SketchLayout from \"~components/sketch-layout\";\n\nconst sketch = function(p) {\n  const SIZE = 200;\n\n  let points = [];\n  let initPoints = [];\n\n  p.setup = function() {\n    p.createCanvas(660, 840, p.WEBGL);\n    initPoints = Array.from(Array(50), () => [\n      SIZE,\n      p.random(p.TWO_PI),\n      p.random(p.TWO_PI),\n    ]);\n    points = [...initPoints];\n  };\n\n  p.draw = function() {\n    p.background(0);\n    p.directionalLight(\n      p.min(p.frameCount, 255),\n      p.min(p.frameCount, 255),\n      p.min(p.frameCount, 255),\n      p.cos(p.frameCount / 100),\n      p.sin(p.frameCount / 200),\n      p.sin(p.frameCount / 100) / 2\n    );\n    p.camera(\n      p.sin(p.frameCount / (SIZE * 5)) * (SIZE * 2),\n      p.cos(p.frameCount / (SIZE * 5)) * (SIZE * 2),\n      SIZE / 3,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    );\n\n    p.noStroke();\n    p.fill(0);\n    p.specularMaterial(255, 255, 255);\n\n    points.forEach((pt, i) => {\n      const v = p.createVector(...spherical(pt).cart());\n      v.normalize();\n\n      p.push();\n      p.translate(\n        ...spherical(pt)\n          .cart()\n          .map(c => c / 2)\n      );\n      p.rotateX(p.atan2(v.y, v.z));\n      p.cylinder(20 * p.noise(v.x, v.y, p.frameCount / 150), SIZE, 50);\n      p.pop();\n\n      points[i] = [\n        SIZE,\n        initPoints[i][1] * p.noise(initPoints[i][1], p.frameCount / 500),\n        initPoints[i][2] * p.noise(initPoints[i][2], p.frameCount / 500),\n      ];\n    });\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","module.exports = function isObject(obj) {\n    var type = typeof obj;\n    return !!obj && (type === 'function' || type === 'object');\n};\n","\"use strict\";\nvar isArray = require('amp-is-array');\nvar isNumber = require('amp-is-number');\nvar isObject = require('amp-is-object');\nvar extend = require('amp-extend');\nvar degPerRadian = 180 / Math.PI;\n\n/**\n * @constructor Coordinate\n * @description Defines object which can convert between coordinate systems.\n * It is recommended to use one of the Coodinate.STATIC_CONSTRUCTOR functions\n * to generate your first coordinate before conversions. e.g. Coodinate.spherical(...)\n * @param {Object} config\n * {\n *     label: 'type of initial coordinate',\n *     coords: {\n *         x/y/z/r/t/p: 'k-v pairs'\n *     },\n *     isDegree: Boolean\n * }\n */\nvar Coordinate = function (config) {\n    var isRadian,\n        isDegree,\n        pos = {},\n        _x, _y, _z, _r, _t, _p;\n\n    // Override select setters/getts\n    Object.defineProperty(this, \"isRadian\", {\n        get: function (x) { return isRadian; },\n        set: function (x) {\n            isRadian = !!x;\n            if (isDegree !== !x) { isDegree = !x; } // jshint ignore:line\n        }\n    });\n    Object.defineProperty(this, \"isDegree\", {\n        get: function (x) { return isDegree; },\n        set: function (x) {\n            isDegree = x;\n            if (isRadian !== !x) { isRadian = !x; } // jshint ignore:line\n        }\n    });\n    Object.defineProperty(pos, \"cartesian2d\", {\n        get: function (x) { return [_x, _y]; },\n        set: function (x) { _x = x[0]; _y = x[1]; }\n    });\n    Object.defineProperty(pos, \"cartesian3d\", {\n        get: function (x) { return [_x, _y, _z]; },\n        set: function (x) { _x = x[0]; _y = x[1]; _z = x[2]; }\n    });\n    Object.defineProperty(pos, \"polar\", {\n        get: function (x) { return [_r, _t]; },\n        set: function (x) { _r = x[0]; _t = x[1]; }\n    });\n    Object.defineProperty(pos, \"cylindrical\", {\n        get: function (x) { return [_r, _t, _z]; },\n        set: function (x) { _r = x[0]; _t = x[1]; _z = x[2]; }\n    });\n    Object.defineProperty(pos, \"spherical\", {\n        get: function (x) { return [_r, _t, _p]; },\n        set: function (x) { _r = x[0]; _t = x[1]; _p = x[2]; }\n    });\n\n    // init from config\n    if (config.isDegree && !config.isRadian) {\n        this.isDegree = true;\n    } else {\n        this.isRadian = true;\n    }\n    if (!config.label || !config.coords) {\n        throw new Error(\"no coordinate type defined\");\n    }\n    this.initialType = config.label;\n    this.pos = pos;\n    this.pos[config.label] = config.coords;\n};\n\n\n\n/**\n * @method cartesian\n * Converts current coordinate to cartesian\n * @function cartesian\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cartesian = function () { return this.cart.apply(this, arguments); };\n/**\n * @method cart\n * Converts current coordinate to cartesian\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cart = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            return this.pos.cartesian2d;\n        case 'cartesian3d':\n            return this.pos.cartesian3d;\n        case 'polar':\n            this.pos.cartesian2d = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n            return this.pos.cartesian2d;\n        case 'cylindrical':\n            temp = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n            this.pos.cartesian3d = [temp[0], temp[1], this.pos.cylindrical[2]];\n            return this.pos.cartesian3d;\n        case 'spherical':\n            this.pos.cartesian3d = Coordinate.sphericalToCart3d(this.pos.spherical, this.isDegree);\n            return this.pos.cartesian3d;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n\n/**\n * @method cylindrical\n * Converts current coordinate to cylindrical\n * @function cylindrical\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cylindrical = function () { return this.cyl.apply(this, arguments); };\n/**\n * @method cyl\n * Converts current coordinate to cylindrical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cyl = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            this.pos.cylindrical = [temp[0], temp[1], 0];\n            return this.pos.cylindrical;\n        case 'cartesian3d':\n            this.pos.cylindrical = Coordinate.cartesian3dToCylindrical(this.pos.cartesian3d, this.isDegree, options.center);\n            return this.pos.cylindrical;\n        case 'polar':\n            temp = this.pos.polar;\n            return [temp[0], temp[1], 0];\n        case 'cylindrical':\n            return this.pos.cylindrical;\n        case 'spherical':\n            this.pos.cylindrical = Coordinate.sphericalToCylindrical(this.pos.spherical, this.isDegree);\n            return this.pos.cylindrical;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n/**\n * @method pol\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.pol = function () { return this.polar.apply(this, arguments); };\n/**\n * @method polar\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.polar = function (options) {\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            this.pos.polar = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            return this.pos.polar;\n        case 'polar':\n            return this.pos.polar;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n\n/**\n * @method spherical\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.spherical = function () { return this.sph.apply(this, arguments); };\n/**\n * @method sph\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.sph = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            this.pos.spherical = [temp[0], temp[1], 0];\n            return this.pos.spherical;\n        case 'cartesian3d':\n            this.pos.spherical = Coordinate.cartesian3dToSpherical(this.pos.cartesian3d, this.isDegree, options.center);\n            return this.pos.spherical;\n        case 'polar':\n            temp = this.pos.polar;\n            return [temp[0], temp[1], 0];\n        case 'cylindrical':\n            this.pos.spherical = Coordinate.cylindricalToSpherical(this.pos.cylindrical, this.isDegree);\n            return this.pos.spherical;\n        case 'spherical':\n            return this.pos.spherical;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n///\n/// Static Constructor Functions\n///\n\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cartesian = function(x) { return Coordinate.cart(x); };\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cart = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length < 2 || options.coords.length > 3) {\n            throw new Error('expected exactly 2 or exactly 3 cartesian options');\n        }\n        baseCoord = {\n            label: 'cartesian2d',\n            options: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        if (options.coords.length === 2) {\n            return new Coordinate(baseCoord);\n        }\n        baseCoord.label = 'cartesian3d';\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [x,y,(z?)] coords');\n};\n\n\n\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cylindrical = function(x) { return Coordinate.cyl(x); };\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cyl = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 3) {\n            throw new Error('expected exactly 3 params [r, t, z]');\n        }\n        baseCoord = {\n            label: 'cylindrical',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [r, t, z] coords');\n};\n\n\n\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.polar = function(x) { return Coordinate.pol(x); };\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.pol = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 2) {\n            throw new Error('expected exactly 2 params [r, t]');\n        }\n        baseCoord = {\n            label: 'polar',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected array of [r, t] options');\n};\n\n\n\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.spherical = function(options) { return Coordinate.sph(options); };\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.sph = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 3) {\n            throw new Error('expected exactly 3 params [r, t, p]');\n        }\n        baseCoord = {\n            label: 'spherical',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [r, t, p] coords');\n};\n\n\n\n/**\n * Mutates an array of number-like looking values to purely numeric array\n * @example\n * [5, '2.4', '0'] => [5, 2.4, 0]\n * @param  {Array} nums\n * @return {undefined}\n */\nCoordinate.arrToNumeric = function(nums) {\n    var num;\n    if (!isArray(nums)) {\n        throw new TypeError(\"expected array of number-like values\");\n    }\n    for (var i = nums.length - 1; i >= 0; i--) {\n        num = nums[i];\n        if (typeof num === 'string') {\n            num = parseFloat(num);\n        }\n        if (!isNumber(num)) {\n            throw new TypeError(num + ' not numeric or numeric-like');\n        }\n    }\n};\n\n\n\n/**\n * Convert polar to 2d cartesian coordinates\n * @param  {Array}   rt        [radis, theta]\n * @param  {Boolean} isDegree specifies units\n * @return {Array}  [x, y]\n */\nCoordinate.polarToCart2d = function(rt, isDegree) {\n    var r, t, x, y;\n    r = rt[0];\n    t = rt[1];\n    if (isDegree) {\n        t = t * (1/degPerRadian);\n    }\n    x = r * Math.cos(t);\n    y = r * Math.sin(t);\n    return [x, y];\n};\n\n\n\n/**\n * Convert cartesian 2d to polar coordinates\n * @param  {Array}  xy\n * @param {Boolean=} isDegree overrides default radian theta assumption\n * @param  {Array=} center [x, y] coords of center of circle.  Defaults to [0, 0],\n * however may be offset.  Note. Such functionality not supported yet for converting\n * polar to cartesian\n * @return {Array}  [radius, theta]\n */\nCoordinate.cartesian2dToPolar = function(xy, isDegree, center) {\n    var x, y, r, t;\n    if (!isArray(xy) && xy.length !== 2) {\n        throw new TypeError('expected [x, y] xy array');\n    }\n    x = xy[0];\n    y = xy[1];\n    if (center && !isArray(center) && center.length !== 2) {\n        throw new TypeError('expected [x, y] center array');\n    }\n    if (center) {\n        x = x - center[0];\n        y = y - center[1];\n    }\n    r = Math.sqrt(x*x + y*y);\n    t = Math.atan2(y, x);\n    if (isDegree) {\n        t = t * degPerRadian;\n    }\n    return [r, t];\n};\n\n\n\n/**\n * Convert 3d cartesian to 3d cylindrical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y] coords of center of circle\n * @return {Array}      [radius, theta, z]\n */\nCoordinate.cartesian3dToCylindrical = function (xyz, isDegree, center) {\n    var x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        rt;\n    rt = Coordinate.cartesian2dToPolar([x, y], isDegree, center);\n    return [rt[0], rt[1], z];\n};\n\n\n\n/**\n * Convert 3d cartesian to 3d spherical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y, z] coords of center of circle\n * @return {Array}      [radius, theta, phi]\n */\nCoordinate.cartesian3dToSpherical = function (xyz, isDegree, center) {\n    if (center && center.length !== 3) {\n        throw new Error('expected center value to have [x, y, z] coords' +\n            'for locating sphere center');\n    }\n    var x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        x2, y2, z2,\n        r, t, p;\n    if (center) {\n        x = x - center[0];\n        y = y - center[1];\n        z = z - center[2];\n    }\n    x2 = x*x; y2 = y*y; z2 = z*z;\n    r = Math.sqrt(x2 + y2 + z2);\n    if (!r) {\n        p = t = 0;\n    } else {\n        t = Math.atan2(y,x);\n        p = Math.atan2(Math.sqrt(x2 + y2), z);\n        if (isDegree) {\n            t = t * degPerRadian;\n            p = p * degPerRadian;\n        }\n    }\n    return [r, t, p];\n};\n\n\n\n/**\n * Convert a cylindrical to a spherical coordinates\n * @param  {Array}   rtz\n * @param  {Boolean} isDegree\n * @return {Array}   [radius, theta, phi]\n */\nCoordinate.cylindricalToSpherical = function(rtz, isDegree) {\n    var r = rtz[0], t = rtz[1], z = rtz[2];\n    var sr, sp; // sphere radius, sphere theta...\n    if (isDegree) {\n        t = t / degPerRadian;\n    }\n    sr = Math.sqrt(r*r + z*z);\n    sp = Math.atan2(r, z);\n    if (isDegree) {\n        sp = sp * degPerRadian;\n        t = t * degPerRadian;\n    }\n    return [sr, t, sp];\n};\n\n\n\n/**\n * Convert spherical to a cartesian coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\nCoordinate.sphericalToCart3d = function (rtp, isDegree) {\n    var r = rtp[0], t = rtp[1], p = rtp[2],\n        x,y,z;\n    if (isDegree) {\n        t = t / degPerRadian;\n        p = p / degPerRadian;\n    }\n    x = r * Math.sin(p) * Math.cos(t);\n    y = r * Math.sin(p) * Math.sin(t);\n    z = r * Math.cos(p);\n    return [x, y, z];\n};\n\n\n\n/**\n * Convert spherical to cylindrical coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\nCoordinate.sphericalToCylindrical = function (rtp, isDegree) {\n    var r = rtp[0], t = rtp[1], p = rtp[2],\n        cr, z;\n    if (isDegree) {\n        t = t / degPerRadian;\n        p = p / degPerRadian;\n    }\n    cr = r * Math.sin(p);\n    z = r * Math.cos(p);\n    if (isDegree) {\n        t = t * degPerRadian;\n        p = p * degPerRadian;\n    }\n    return [cr, t, z];\n};\n\nmodule.exports = Coordinate;\n","var toString = Object.prototype.toString;\nvar nativeIsArray = Array.isArray;\n\n\nmodule.exports = nativeIsArray || function isArray(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n","var toString = Object.prototype.toString;\n\n\nmodule.exports = function isNumber(obj) {\n    return toString.call(obj) === '[object Number]';\n};\n","var isObject = require('amp-is-object');\n\n\nmodule.exports = function(obj) {\n    if (!isObject(obj)) return obj;\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n        source = arguments[i];\n        for (prop in source) {\n            obj[prop] = source[prop];\n        }\n    }\n    return obj;\n};\n"],"sourceRoot":""}