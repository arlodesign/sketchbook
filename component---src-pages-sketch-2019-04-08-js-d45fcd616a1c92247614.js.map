{"version":3,"sources":["webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2019/04/08.js"],"names":["polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y","polarToCartesian","sketch","p","Doodad","this","freq","TWO_PI","floor","random","drawFunc","pinwheel","horizontalLines","verticalLines","spiralClockwise","spiralCounterclockwise","draw","push","translate","pop","strokeWeight","r","line","GRID","start","end","offset","noStroke","fill","circle","map","doodads","setup","createCanvas","width","height","background","forEach","d","noLoop","location","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2019-04-08-js-d45fcd616a1c92247614.js","sourcesContent":["const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  const GRID = 60;\n  const MARGIN = 5;\n\n  class Doodad {\n    constructor(x, y) {\n      this.x = x;\n      this.y = y;\n      this.freq = p.TWO_PI / (p.floor(p.random(10, 15)) * 2);\n      this.drawFunc = p.random([\n        this.pinwheel,\n        this.horizontalLines,\n        this.verticalLines,\n        this.spiralClockwise,\n        this.spiralCounterclockwise,\n      ]);\n    }\n    draw() {\n      p.push();\n      p.translate(this.x, this.y);\n      this.drawFunc();\n      p.pop();\n    }\n    pinwheel() {\n      p.strokeWeight(2);\n      for (let r = 0; r < p.TWO_PI; r += this.freq) {\n        p.line(\n          ...polarToCartesian(0, 0, r, (GRID / 2 - MARGIN) / 3, true),\n          ...polarToCartesian(0, 0, r, GRID / 2 - MARGIN, true)\n        );\n      }\n    }\n    horizontalLines() {\n      p.strokeWeight(2);\n      for (let r = 0; r < p.TWO_PI; r += this.freq) {\n        const start = polarToCartesian(0, 0, r, GRID / 2 - (MARGIN + 2), true);\n        const end = [-start[0], start[1]];\n        p.line(...start, ...end);\n      }\n    }\n    verticalLines() {\n      p.strokeWeight(2);\n      for (let r = 0; r < p.TWO_PI; r += this.freq) {\n        const start = polarToCartesian(0, 0, r, GRID / 2 - (MARGIN + 2), true);\n        const end = [start[0], -start[1]];\n        p.line(...start, ...end);\n      }\n    }\n    spiralClockwise() {\n      const offset = p.random(p.TWO_PI);\n      p.noStroke();\n      p.fill(0);\n      for (let r = 0; r < p.TWO_PI * 2; r += this.freq) {\n        p.circle(\n          ...polarToCartesian(\n            0,\n            0,\n            r + offset,\n            p.map(r, 0, p.TWO_PI * 2, 0, GRID / 2 - MARGIN),\n            true\n          ),\n          2\n        );\n      }\n    }\n    spiralCounterclockwise() {\n      const offset = p.random(p.TWO_PI);\n      p.noStroke();\n      p.fill(0);\n      for (let r = p.TWO_PI; r > -p.TWO_PI; r -= this.freq) {\n        p.circle(\n          ...polarToCartesian(\n            0,\n            0,\n            r + offset,\n            p.map(r, p.TWO_PI, -p.TWO_PI, 0, GRID / 2 - MARGIN),\n            true\n          ),\n          2\n        );\n      }\n    }\n  }\n\n  let doodads = [];\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    for (let x = GRID / 2; x < p.width; x += GRID) {\n      for (let y = GRID / 2; y < p.height; y += GRID) {\n        doodads.push(new Doodad(x, y));\n      }\n    }\n  };\n\n  p.draw = function() {\n    p.background(255);\n    doodads.forEach(d => d.draw());\n    p.noLoop();\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}