{"version":3,"sources":["webpack:///./src/pages/sketch/2020/05/15.js","webpack:///./src/lib/polarToCartesian.js"],"names":["sketch","p","mask","RENDER","getURLParams","render","RATE","COLORS","shuffle","setup","pixelDensity","frameRate","createCanvas","background","createLoop","gif","open","noiseRadius","createGraphics","width","height","noStroke","fill","circle","draw","animLoop","progress","noise2D","canvas","theta","blendMode","MULTIPLY","noFill","noSmooth","translate","j","stroke","i","vertex","a","x","y","map","angle","TWO_PI","distance","sin","polarToCartesian","beginShape","curveVertex","endShape","canvasPixels","get","image","frameCount","console","info","floor","location","path","pathname","description","polarToCartesianX","center","Math","cos","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray"],"mappings":"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","file":"component---src-pages-sketch-2020-05-15-js-02ef257294e69b70e264.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport \"p5.createloop\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function (p) {\n  const RENDER = p.getURLParams().render;\n  const DURATION = 30;\n  const RATE = RENDER ? 60 : 30;\n  const LINES = 400;\n  const VERTICES = 20;\n  const COLORS = p.shuffle([\"cyan\", \"magenta\", \"yellow\"]);\n\n  let mask;\n\n  p.setup = function () {\n    p.pixelDensity(1);\n    p.frameRate(RATE);\n    p.createCanvas(660, 840);\n    p.background(0);\n    p.createLoop(DURATION, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 0.2,\n    });\n\n    mask = p.createGraphics(p.width, p.height);\n    mask.noStroke();\n    mask.fill(0);\n    mask.circle(p.width / 2, p.height / 2, p.width * 0.8);\n  };\n\n  p.draw = function () {\n    const { progress, noise2D, theta } = p.animLoop;\n    const canvas = p.createGraphics(p.width, p.height);\n\n    p.background(0);\n\n    canvas.background(255);\n    canvas.blendMode(canvas.MULTIPLY);\n    canvas.noFill();\n    canvas.noSmooth();\n    canvas.translate(p.width / 2, p.height / 2);\n\n    for (let j = 1; j <= 3; j++) {\n      canvas.stroke(COLORS[j - 1]);\n      for (let i = 1; i <= LINES; i++) {\n        const vertex = (a) => {\n          const x = noise2D(j, 1) * (p.width / 2);\n          const y =\n            p.map(noise2D(j + 1, 2), -1, 1, p.width / 2, p.width) *\n            (j % 2 ? -1 : 1);\n          const angle = a > p.TWO_PI ? a - p.TWO_PI : a;\n          const distance =\n            canvas.height *\n            (i / LINES) *\n            p.map(\n              noise2D(j + 3 * (i / LINES), angle * p.sin(angle)),\n              -1,\n              1,\n              0.5,\n              3\n            );\n\n          return polarToCartesian(\n            x,\n            y,\n            angle + noise2D(j + 2, 3),\n            distance,\n            true\n          );\n        };\n\n        canvas.beginShape();\n        for (\n          let a = 0;\n          a <= p.TWO_PI + (p.TWO_PI / VERTICES) * 2;\n          a += p.TWO_PI / VERTICES\n        ) {\n          canvas.curveVertex(...vertex(a));\n        }\n\n        canvas.endShape();\n      }\n    }\n\n    const canvasPixels = canvas.get();\n    canvasPixels.mask(mask);\n    p.image(canvasPixels, 0, 0);\n\n    p.frameCount % 100 === 0 && console.info(`${p.floor(progress * 100)}%`);\n    if (!RENDER && p.frameCount === DURATION * RATE) {\n      console.info(\"100%\");\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}