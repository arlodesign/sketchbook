{"version":3,"sources":["webpack:///./src/pages/sketch/2019/05/03.js","webpack:///./src/lib/lerpLine.js"],"names":["sketch","p","w","h","SIZES","grid","Doodad","x","y","size","this","square","lerpLine","noise","frameCount","setup","createCanvas","background","stroke","noFill","floor","width","height","xx","push","yy","visited","draw","random","concat","filter","overlap","Math","max","s","length","noLoop","location","path","pathname","description","x1","y1","x2","y2","rate","showFirstDot","noisy","thisRate","dist","l","point","lerp"],"mappings":"g9BAIA,IAAMA,EAAS,SAASC,GACtB,IAIIC,EACAC,EAJEC,EAAQ,CAAC,EAAG,EAAG,EAAG,IAEpBC,EAAO,GAILC,EARmB,WASvB,WAAYC,EAAGC,EAAGC,GAChBC,KAAKH,EATS,GASLA,EACTG,KAAKF,EAVS,GAULA,EACTE,KAAKD,KAXS,GAWFA,EAEZC,KAAKC,SAdgB,mBAgBvBA,OAAA,WACE,IAAK,IAAIH,EAAIE,KAAKF,EAAGA,GAAKE,KAAKF,EAAIE,KAAKD,KAAMD,IAC5CI,YACEX,EACAS,KAAKH,EACLC,EACAE,KAAKH,EAAIG,KAAKD,KACdD,EACAP,EAAEY,MAAMZ,EAAEa,WAAYN,GAAKE,KAAKD,OAxBf,KA8BzBR,EAAEc,MAAQ,WACRd,EAAEe,aAAa,IAAK,KACpBf,EAAEgB,WAAW,KACbhB,EAAEiB,OAAO,GACTjB,EAAEkB,SAEFjB,EAAID,EAAEmB,MAAMnB,EAAEoB,MAnCE,IAoChBlB,EAAIF,EAAEmB,MAAMnB,EAAEqB,OApCE,IAsChB,IAAK,IAAIC,EAAK,EAAGA,EAAKrB,EAAGqB,IAAM,CAC7BlB,EAAKmB,KAAK,IACV,IAAK,IAAIC,EAAK,EAAGA,EAAKtB,EAAGsB,IACvBpB,EAAKkB,GAAIC,KAAK,CACZjB,EAAGgB,EACHf,EAAGiB,EACHC,SAAS,MAMjBzB,EAAE0B,KAAO,WAAY,IAAD,MACD1B,EAAE2B,QACjB,MAAGC,OAAH,QAAaxB,GAAMyB,QAAO,qBAAGJ,YADvBnB,EADU,EACVA,EAAGC,EADO,EACPA,EAINH,EAAKE,GAAGC,GAAGkB,SAAU,WACxB,IACIK,EADAtB,EAAOuB,KAAKC,IAAL,MAAAD,KAAY5B,GAGvB,EAAG,CACD2B,GAAU,EACV,IAAK,IAAIR,EAAKhB,EAAGgB,EAAKd,EAAOF,EAAGgB,IAC9B,IAAK,IAAIE,EAAKjB,EAAGiB,EAAKhB,EAAOD,EAAGiB,KAC1BlB,EAAIE,EAAOP,GAAKM,EAAIC,EAAON,GAAKE,EAAKkB,GAAIE,GAAIC,WAC/CK,GAAU,GAIZA,IACFtB,EAAOuB,KAAKC,IAAL,MAAAD,KAAI,EAAQ5B,EAAM0B,QAAO,SAAAI,GAAC,OAAIA,EAAIzB,cAEpCsB,GAET,IAAIzB,EAAOC,EAAGC,EAAGC,GAEjB,IAAK,IAAIc,EAAKhB,EAAGgB,EAAKd,EAAOF,EAAGgB,IAC9B,IAAK,IAAIE,EAAKjB,EAAGiB,EAAKhB,EAAOD,EAAGiB,IAC9BpB,EAAKkB,GAAIE,GAAIC,SAAU,EAtBH,IA2BrB,MAAGG,OAAH,QAAaxB,GAAMyB,QAAO,qBAAGJ,WAAwBS,QACxDlC,EAAEmC,WAKO,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAcrC,OAAQA,EAAQsC,KAAMD,EAASE,SAAUC,YAAY,O,oCClFtD,aACbvC,EACAwC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,QACA,IAFAD,OAAe,QAEf,IADAC,OAAQ,GAIR,IAFA,IAAMC,EAAWhB,KAAKC,IAAIY,EAAM,IAAO5C,EAAEgD,KAAKR,EAAIC,EAAIC,EAAIC,IAEjDM,EAAI,EAAGA,EAAI,EAAGA,GAAKF,GAChB,IAANE,GAAYJ,KACXC,GAAS9C,EAAE2B,SAAWsB,IAAOH,IAChC9C,EAAEkD,MAAMlD,EAAEmD,KAAKX,EAAIE,EAAIO,GAAIjD,EAAEmD,KAAKV,EAAIE,EAAIM","file":"component---src-pages-sketch-2019-05-03-js-2f72fb6f27e8d00ae1ef.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport lerpLine from \"~lib/lerpLine\";\n\nconst sketch = function(p) {\n  const GRID_SIZE = 30;\n  const SIZES = [1, 3, 8, 21];\n\n  let grid = [];\n  let w;\n  let h;\n\n  class Doodad {\n    constructor(x, y, size) {\n      this.x = x * GRID_SIZE;\n      this.y = y * GRID_SIZE;\n      this.size = size * GRID_SIZE;\n\n      this.square();\n    }\n    square() {\n      for (let y = this.y; y <= this.y + this.size; y++) {\n        lerpLine(\n          p,\n          this.x,\n          y,\n          this.x + this.size,\n          y,\n          p.noise(p.frameCount, y) / this.size\n        );\n      }\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.background(255);\n    p.stroke(0);\n    p.noFill();\n\n    w = p.floor(p.width / GRID_SIZE);\n    h = p.floor(p.height / GRID_SIZE);\n\n    for (let xx = 0; xx < w; xx++) {\n      grid.push([]);\n      for (let yy = 0; yy < h; yy++) {\n        grid[xx].push({\n          x: xx,\n          y: yy,\n          visited: false,\n        });\n      }\n    }\n  };\n\n  p.draw = function() {\n    const { x, y } = p.random(\n      [].concat(...grid).filter(({ visited }) => !visited)\n    );\n\n    if (!grid[x][y].visited) {\n      let size = Math.max(...SIZES);\n      let overlap;\n\n      do {\n        overlap = false;\n        for (let xx = x; xx < size + x; xx++) {\n          for (let yy = y; yy < size + y; yy++) {\n            if (x + size > w || y + size > h || grid[xx][yy].visited) {\n              overlap = true;\n            }\n          }\n        }\n        if (overlap) {\n          size = Math.max(...SIZES.filter(s => s < size));\n        }\n      } while (overlap);\n\n      new Doodad(x, y, size);\n\n      for (let xx = x; xx < size + x; xx++) {\n        for (let yy = y; yy < size + y; yy++) {\n          grid[xx][yy].visited = true;\n        }\n      }\n    }\n\n    if (![].concat(...grid).filter(({ visited }) => !visited).length) {\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","/**\n * Creates a line of points at a specified interval (the rate)\n *\n * @param {obj} p The current p5.js drawing context\n * @param {*} x1\n * @param {*} y1\n * @param {*} x2\n * @param {*} y2\n * @param {*} rate Number between 0 and 1 to determine how often to draw a point\n * @param {*} showFirstDot Defaults to true\n * @param {*} noisy Defaults to true\n */\nexport default function(\n  p,\n  x1,\n  y1,\n  x2,\n  y2,\n  rate,\n  showFirstDot = true,\n  noisy = true\n) {\n  const thisRate = Math.max(rate, 0.01 / p.dist(x1, y1, x2, y2));\n\n  for (let l = 0; l < 1; l += thisRate) {\n    if (l === 0 && !showFirstDot) continue;\n    if ((noisy && p.random() > l) || !noisy) {\n      p.point(p.lerp(x1, x2, l), p.lerp(y1, y2, l));\n    }\n  }\n}\n"],"sourceRoot":""}