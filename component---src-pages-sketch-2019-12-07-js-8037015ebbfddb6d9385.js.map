{"version":3,"sources":["webpack:///./src/pages/sketch/2019/12/07.js","webpack:///./src/lib/addNoise.js","webpack:///./src/lib/polarToCartesian.js"],"names":["sketch","p","y","RENDER","getURLParams","render","HUE","random","i","setup","pixelDensity","frameRate","createCanvas","background","createLoop","height","gif","open","noiseRadius","colorMode","HSB","addNoise","draw","stroke","ITERATIONS","noFill","blendMode","BURN","a","TWO_PI","map","noise","point","polarToCartesianEllipse","width","animLoop","noise1D","frameCount","noLoop","location","path","pathname","description","intensity","PTS","push","fill","noStroke","ellipse","randomGaussian","pop","polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","sin","centerX","centerY","radiusX","radiusY","asArray","x","polarToCartesian"],"mappings":"0+BAMA,IAAMA,EAAS,SAASC,GACtB,IAKIC,EALEC,EAASF,EAAEG,eAAeC,OAC1BC,EAAML,EAAEM,SAKVC,EAAI,EAERP,EAAEQ,MAAQ,WACJN,GACFF,EAAES,aAAa,GAEjBT,EAAEU,UAAU,IACZV,EAAEW,aAAa,IAAK,KACpBX,EAAEY,WAAW,KACbZ,EAAEa,WAAab,EAAEc,OAZN,EADM,EAa+B,GAAI,CAClDC,MAAKb,GAAS,CAAEE,QAAQ,EAAOY,MAAM,GACrCC,YAAa,IAEfjB,EAAEkB,UAAUlB,EAAEmB,IAjBG,GAmBjBC,YAASpB,GAETC,EAAID,EAAEc,OAAS,KAGjBd,EAAEqB,KAAO,WACPrB,EAAEsB,OAAOjB,EAAME,EAAGgB,EAzBD,EAyBgCA,GACjDvB,EAAEwB,SACFxB,EAAEyB,UAAUzB,EAAE0B,MAEd,IACE,IAAIC,EAAI,EACRA,EAAI3B,EAAE4B,OACND,GAAK3B,EAAE6B,IAAI7B,EAAE8B,MAAM,IAAM,EAAG,EAAG,KAAO,MAElC9B,EAAEM,SAAW,IACfN,EAAE+B,MAAF,MAAA/B,EAAC,EACIgC,YACDhC,EAAEiC,MAAQ,EAAKjC,EAAEiC,MAAQ,EAAKjC,EAAEkC,SAASC,QAAQ,IACjDlC,EACA0B,EACC3B,EAAEiC,MAAQ,EAAKjC,EAAE8B,MAAM,GAAK9B,EAAEoC,WAAa,KAC5C,GAAKpC,EAAE8B,MAAM,GAAK9B,EAAEoC,WAAa,MACjC,MAMRnC,GA/CW,IAiDF,MACPA,EAAID,EAAEc,OAAS,IACfP,KApDe,IAuDbA,IACDL,GAAUF,EAAEqC,WAKJ,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAcvC,OAAQA,EAAQwC,KAAMD,EAASE,SAAUC,YAAY,O,4CCnDtDrB,IApBE,SAACpB,EAAG0C,QAAoB,IAApBA,MAAY,IAC/B,IAAMC,EAAM3C,EAAEiC,MAAQjC,EAAEc,OAAS,IAEjCd,EAAE4C,OACF,IAAK,IAAIrC,EAAI,EAAGA,EAAIoC,EAAKpC,IACvBP,EAAE6C,KACAtC,EAAI,EAAJ,iBACqBmC,EADrB,2BAE2BA,EAF3B,KAIF1C,EAAE8C,WACF9C,EAAE+C,QACA/C,EAAEgD,eAAehD,EAAEiC,MAAQ,EAAGjC,EAAEiC,MAAQ,GACxCjC,EAAEgD,eAAehD,EAAEc,OAAS,EAAGd,EAAEc,OAAS,GAC1C,GAAKd,EAAES,eAAiB,IAG5BT,EAAEiD,Q,kCCjBJ,0GAAMC,EAAoB,SAACC,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKC,IAAIH,GAASC,GAE9BG,EAAoB,SAACL,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKG,IAAIL,GAASC,GAsB9BrB,EAA0B,SAC9B0B,EACAC,EACAP,EACAQ,EACAC,EACAC,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIL,EAAUJ,KAAKC,IAAIH,GAASQ,EAChC3D,EAAI0D,EAAUL,KAAKG,IAAIL,GAASS,EACtC,OAAOC,EAAU,CAACC,EAAG9D,GAAK,CAAE8D,IAAG9D,MAIlB+D,IAzBU,SACvBN,EACAC,EACAP,EACAC,EACAS,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIb,EAAkBQ,EAASN,EAAOC,GACtCpD,EAAIuD,EAAkBG,EAASP,EAAOC,GAC5C,OAAOS,EAAU,CAACC,EAAG9D,GAAK,CAAE8D,IAAG9D","file":"component---src-pages-sketch-2019-12-07-js-8037015ebbfddb6d9385.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport { polarToCartesianEllipse } from \"~lib/polarToCartesian\";\nimport addNoise from \"~lib/addNoise\";\nimport \"p5.createloop\";\n\nconst sketch = function(p) {\n  const RENDER = p.getURLParams().render;\n  const HUE = p.random();\n  const ITERATIONS = 4;\n  const RATE = 2;\n\n  let y;\n  let i = 0;\n\n  p.setup = function() {\n    if (RENDER) {\n      p.pixelDensity(1);\n    }\n    p.frameRate(30);\n    p.createCanvas(660, 840);\n    p.background(192);\n    p.createLoop(((p.height / RATE) * ITERATIONS) / 30, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 1,\n    });\n    p.colorMode(p.HSB, ITERATIONS);\n\n    addNoise(p);\n\n    y = p.height + 100;\n  };\n\n  p.draw = function() {\n    p.stroke(HUE + i, ITERATIONS * 0.75, ITERATIONS, ITERATIONS / 4);\n    p.noFill();\n    p.blendMode(p.BURN);\n\n    for (\n      let a = 0;\n      a < p.TWO_PI;\n      a += p.map(p.noise(0.6), 0, 1, 0.001, 0.005)\n    ) {\n      if (p.random() < 0.5) {\n        p.point(\n          ...polarToCartesianEllipse(\n            p.width / 2 + (p.width / 4) * p.animLoop.noise1D(0.7),\n            y,\n            a,\n            (p.width / 2) * p.noise(0.5, p.frameCount / 100),\n            50 * p.noise(0.4, p.frameCount / 100),\n            true\n          )\n        );\n      }\n    }\n\n    y -= RATE;\n\n    if (y < -100) {\n      y = p.height + 100;\n      i++;\n    }\n\n    if (i === ITERATIONS) {\n      !RENDER && p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const addNoise = (p, intensity = 0.5) => {\n  const PTS = p.width * p.height * 0.02;\n\n  p.push();\n  for (let i = 0; i < PTS; i++) {\n    p.fill(\n      i % 2\n        ? `rgba(0, 0, 0, ${intensity})`\n        : `rgba(255, 255, 255, ${intensity})`\n    );\n    p.noStroke();\n    p.ellipse(\n      p.randomGaussian(p.width / 2, p.width / 3),\n      p.randomGaussian(p.height / 2, p.height / 3),\n      1 / (p.pixelDensity() / 2)\n    );\n  }\n  p.pop();\n};\n\nexport default addNoise;\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}