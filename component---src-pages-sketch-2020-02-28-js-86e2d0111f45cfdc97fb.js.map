{"version":3,"sources":["webpack:///./src/pages/sketch/2020/02/28.js","webpack:///./src/lib/polarToCartesian.js"],"names":["sketch","p","RENDER","getURLParams","render","COLORS","shapes","Shape","angle","distance","this","draw","animLoop","theta","noise2D","polarToCartesian","width","height","map","cos","x","y","push","translate","rotate","QUARTER_PI","beginShape","a","TWO_PI","d","curveVertex","endShape","pop","setup","pixelDensity","frameRate","createCanvas","createLoop","gif","open","noiseRadius","noFill","noSmooth","stroke","curveTightness","Array","length","fill","_","i","j","random","noise","sin","background","blendMode","MULTIPLY","forEach","set","clr","color","setAlpha","e","location","path","pathname","description","polarToCartesianX","center","Math","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray"],"mappings":"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","file":"component---src-pages-sketch-2020-02-28-js-86e2d0111f45cfdc97fb.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport \"p5.createloop\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  const RENDER = p.getURLParams().render;\n  const DURATION = 60;\n  const RATE = 30;\n  const COUNT = 600;\n  const COLORS = [\"cyan\", \"magenta\", \"yellow\"];\n  const NOISE_SCALE = 300;\n  const SIDES = 3;\n\n  let shapes = [];\n\n  class Shape {\n    constructor(angle, distance) {\n      this.angle = angle;\n      this.distance = distance;\n    }\n\n    draw() {\n      const { theta, noise2D } = p.animLoop;\n      const { x, y } = polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        this.angle + theta,\n        this.distance *\n          p.map(\n            noise2D(this.distance / NOISE_SCALE, p.cos(this.angle)),\n            -1,\n            1,\n            0.5,\n            1.5\n          )\n      );\n      p.push();\n      p.translate(x, y);\n      p.rotate(\n        theta + p.QUARTER_PI * noise2D(x / NOISE_SCALE, y / NOISE_SCALE)\n      );\n      p.beginShape();\n      for (\n        let a = 0;\n        a < p.TWO_PI + p.TWO_PI * (3 / SIDES);\n        a += p.TWO_PI / SIDES\n      ) {\n        const d = p.map(\n          noise2D(this.distance / NOISE_SCALE, p.cos(this.angle)),\n          -1,\n          1,\n          p.width / 6,\n          p.width / 3\n        );\n\n        p.curveVertex(...polarToCartesian(0, 0, a, d, true));\n      }\n      p.endShape();\n      p.pop();\n    }\n  }\n\n  p.setup = function() {\n    p.pixelDensity(1);\n    p.frameRate(RATE);\n    p.createCanvas(660, 840);\n    p.createLoop(DURATION, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 3.2,\n    });\n    p.noFill();\n    p.noSmooth();\n    p.stroke(0.5);\n    p.curveTightness(0.5);\n\n    shapes = Array(COLORS.length)\n      .fill()\n      .map((_, i) =>\n        Array(COUNT)\n          .fill()\n          .map((_, j) => {\n            return new Shape(\n              p.random((p.TWO_PI / COUNT) * j, (p.TWO_PI / COUNT) * (j + 1)),\n              p.map(\n                p.noise(p.sin((p.TWO_PI / COUNT) * (j + 1) * (i + 1))),\n                0,\n                1,\n                p.width / 10,\n                p.width / 3\n              )\n            );\n          })\n      );\n  };\n\n  p.draw = function() {\n    p.background(255);\n\n    p.push();\n    p.blendMode(p.MULTIPLY);\n    shapes.forEach((set, i) => {\n      const clr = p.color(COLORS[i]);\n      clr.setAlpha(64);\n      p.stroke(clr);\n      set.forEach(e => e.draw());\n    });\n    p.pop();\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}