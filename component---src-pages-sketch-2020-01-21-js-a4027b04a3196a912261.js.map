{"version":3,"sources":["webpack:///./src/pages/sketch/2020/01/21.js","webpack:///./src/lib/polarToCartesian.js","webpack:///./src/lib/lineIntersection.js"],"names":["sketch","p","r","focus","cnvs","M","shuffle","OFFSET","QUARTER_PI","HALF_PI","PI","HUE","random","TWO_PI","SIDE_COUNT","floor","sides","complete","setup","frameRate","createCanvas","colorMode","HSB","createLoop","noiseRadius","width","push","polarToCartesian","height","createGraphics","blendMode","OVERLAY","draw","background","animLoop","theta","noise","thetaA","thetaB","a","x","y","b","i","length","lineIntersection","stroke","map","sin","cos","noFill","bezier","translate","rotate","scale","image","pop","progress","frameCount","console","info","DURATION","noLoop","location","path","pathname","description","polarToCartesianX","center","angle","distance","Math","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x1","y1","x2","y2","x3","y3","x4","y4","uA","uB"],"mappings":"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","file":"component---src-pages-sketch-2020-01-21-js-a4027b04a3196a912261.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport \"p5.createloop\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport lineIntersection from \"~lib/lineIntersection\";\n\nconst sketch = function(p) {\n  const DURATION = 60;\n  const RATE = 60;\n  const M = p.shuffle([1, 2, 3, 5, 7, 9, 11, 13, 17]);\n  const OFFSET = p.shuffle([p.QUARTER_PI, p.HALF_PI, p.PI]);\n  const HUE = p.random(p.TWO_PI);\n  const SIDE_COUNT = 4 * p.floor(p.random(1, 5));\n\n  let sides = [];\n  let r;\n  let complete = 0;\n  let focus;\n  let cnvs;\n\n  p.setup = function() {\n    p.frameRate(RATE);\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, p.TWO_PI);\n    p.createLoop(DURATION, {\n      noiseRadius: 2,\n    });\n\n    r = p.width / 2 - p.width / 20;\n\n    sides.push([\n      polarToCartesian(p.width / 2, p.height / 2, 0, r, true),\n      polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        p.TWO_PI / SIDE_COUNT,\n        r,\n        true\n      ),\n    ]);\n    sides.push([\n      polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        p.TWO_PI / SIDE_COUNT,\n        r,\n        true\n      ),\n      [p.width / 2, p.height / 2],\n    ]);\n    sides.push([\n      polarToCartesian(p.width / 2, p.height / 2, 0, r, true),\n      [p.width / 2, p.height / 2],\n    ]);\n\n    focus = polarToCartesian(\n      p.width / 2,\n      p.height / 2,\n      p.TWO_PI / SIDE_COUNT / 2,\n      r / 2,\n      true\n    );\n\n    cnvs = p.createGraphics(p.width, p.height);\n    cnvs.blendMode(p.OVERLAY);\n    cnvs.colorMode(p.HSB, p.TWO_PI);\n  };\n\n  p.draw = function() {\n    p.background(p.TWO_PI - HUE, p.TWO_PI, p.PI);\n\n    const { theta, noise } = p.animLoop;\n\n    const thetaA = theta * M[0];\n    const thetaB = theta * M[1] + OFFSET[0];\n\n    let a = { x: null, y: null };\n    let b = { x: null, y: null };\n\n    for (let i = 0; i < sides.length; i++) {\n      a =\n        a.x && a.y\n          ? a\n          : lineIntersection(\n              ...focus,\n              ...polarToCartesian(\n                p.width / 2,\n                p.height / 2,\n                thetaA,\n                p.width / 2,\n                true\n              ),\n              ...sides[i][0],\n              ...sides[i][1]\n            );\n\n      b =\n        b.x && b.y\n          ? b\n          : lineIntersection(\n              ...focus,\n              ...polarToCartesian(\n                p.width / 2,\n                p.height / 2,\n                thetaB,\n                p.width / 2,\n                true\n              ),\n              ...sides[i][0],\n              ...sides[i][1]\n            );\n    }\n\n    cnvs.stroke(\n      HUE,\n      p.map(p.sin(theta * M[2]), -1, 1, 0, p.TWO_PI),\n      p.map(p.cos(theta * M[3]), -1, 1, 0, p.TWO_PI),\n      p.HALF_PI\n    );\n    cnvs.noFill();\n    cnvs.bezier(\n      a.x,\n      a.y,\n      ...polarToCartesian(\n        ...focus,\n        theta * M[4],\n        p.map(noise(), -1, 1, 0, r / 4),\n        true\n      ),\n      ...polarToCartesian(\n        ...focus,\n        theta * M[5],\n        p.map(noise(), -1, 1, 0, r / 4),\n        true\n      ),\n      b.x,\n      b.y\n    );\n\n    p.translate(p.width / 2, p.height / 2);\n    for (let i = 0; i < SIDE_COUNT; i++) {\n      p.push();\n      p.rotate(p.TWO_PI / SIDE_COUNT / 2);\n      p.scale(i % 2 ? 1 : -1, 1);\n      p.rotate((p.TWO_PI / SIDE_COUNT) * i);\n      p.rotate(-(p.TWO_PI / SIDE_COUNT / 2));\n      p.image(cnvs, -p.width / 2, -p.height / 2);\n      p.pop();\n    }\n\n    const progress = p.floor((p.frameCount / (DURATION * RATE)) * 100);\n\n    if (progress > complete) {\n      complete = progress;\n      console.info(`${complete}%`);\n    }\n\n    p.frameCount === DURATION * RATE && p.noLoop();\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","/**\n *\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x4\n * @param {number} y4\n */\nexport default function lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n  const uA =\n    ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) /\n    ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n  const uB =\n    ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) /\n    ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n\n  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n    return { x: x1 + uA * (x2 - x1), y: y1 + uA * (y2 - y1) };\n  }\n  return { x: null, y: null };\n}\n"],"sourceRoot":""}