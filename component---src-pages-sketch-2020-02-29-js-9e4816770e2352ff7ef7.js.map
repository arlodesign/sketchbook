{"version":3,"sources":["webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2020/02/29.js"],"names":["polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y","polarToCartesian","sketch","p","RENDER","getURLParams","render","HUE","random","HUES","shuffle","shapes","Shape","this","draw","animLoop","theta","noise2D","progress","width","height","map","progressCurve","push","translate","rotate","QUARTER_PI","beginShape","a","TWO_PI","d","curveVertex","endShape","pop","setup","pixelDensity","frameRate","createCanvas","createLoop","gif","open","noiseRadius","noFill","noSmooth","stroke","curveTightness","colorMode","HSB","Array","length","fill","_","i","j","noise","background","blendMode","HARD_LIGHT","forEach","set","e","frameCount","DURATION","console","log","location","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2020-02-29-js-9e4816770e2352ff7ef7.js","sourcesContent":["const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport \"p5.createloop\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  const RENDER = p.getURLParams().render;\n  const DURATION = 30;\n  const RATE = 30;\n  const COUNT = 1000;\n  const NOISE_SCALE = 1000;\n  const SIDES = 4;\n  const HUE = p.random(1 / 4);\n  const HUES = p.shuffle([HUE, HUE + 1 / 4, HUE + 2 / 4, HUE + 3 / 4]);\n\n  let shapes = [];\n\n  class Shape {\n    constructor(angle, distance) {\n      this.angle = angle;\n      this.distance = distance;\n    }\n\n    draw() {\n      const { theta, noise2D, progress } = p.animLoop;\n      const { x, y } = polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        this.angle + theta,\n        this.distance *\n          p.map(\n            noise2D(this.distance / NOISE_SCALE, p.cos(this.angle)),\n            -1,\n            1,\n            0,\n            1.5\n          )\n      );\n      const progressCurve = -4 * progress * progress + 4 * progress;\n\n      p.push();\n      p.translate(x, y);\n      p.rotate(\n        theta + p.QUARTER_PI * noise2D(x / NOISE_SCALE, y / NOISE_SCALE)\n      );\n      p.beginShape();\n\n      for (\n        let a = 0;\n        a < p.TWO_PI + p.TWO_PI * (3 / SIDES);\n        a += p.TWO_PI / SIDES\n      ) {\n        const d = p.map(\n          noise2D(this.distance / NOISE_SCALE, p.cos(this.angle)),\n          -1,\n          1,\n          (p.width / 6) * (this.angle % (p.TWO_PI / (5 * progressCurve))),\n          (p.width / 3) * (this.angle % (p.TWO_PI / (5 * progressCurve)))\n        );\n\n        p.curveVertex(...polarToCartesian(0, 0, a, d, true));\n      }\n\n      p.endShape();\n      p.pop();\n    }\n  }\n\n  p.setup = function() {\n    p.pixelDensity(1);\n    p.frameRate(RATE);\n    p.createCanvas(660, 840);\n    p.createLoop(DURATION, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 0.8,\n    });\n    p.noFill();\n    p.noSmooth();\n    p.stroke(3);\n    p.curveTightness(0.5);\n    p.colorMode(p.HSB, 1);\n\n    shapes = Array(HUES.length)\n      .fill()\n      .map((_, i) =>\n        Array(COUNT)\n          .fill()\n          .map((_, j) => {\n            return new Shape(\n              (p.TWO_PI / COUNT) * j,\n              p.map(\n                p.noise(p.sin((p.TWO_PI / COUNT) * (j + 1) * (i + 1))),\n                0,\n                1,\n                p.width / 10,\n                p.width / 3\n              )\n            );\n          })\n      );\n  };\n\n  p.draw = function() {\n    p.background(0);\n\n    p.push();\n    p.blendMode(p.HARD_LIGHT);\n    shapes.forEach((set, i) => {\n      p.stroke(HUES[i], 1 / (i + 1), 0.8, 0.2);\n      set.forEach(e => e.draw());\n    });\n    p.pop();\n\n    p.frameCount < DURATION * RATE &&\n      console.log(`${p.frameCount} / ${DURATION * RATE}`);\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}