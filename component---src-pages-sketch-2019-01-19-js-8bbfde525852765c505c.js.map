{"version":3,"sources":["webpack:///./src/pages/sketch/2019/01/19.js"],"names":["sketch","p","myFont","maxDist","vectors","preload","loadFont","withPrefix","setup","pixelDensity","createCanvas","background","stroke","string","split","points","forEach","str","line","concat","textToPoints","sampleFactor","_ref","i","x","y","noiseFactor","map","length","push","vector","createVector","noise","reached","reachedBy","dist","width","height","draw","_ref2","_vectors$reachedBy$ve","distance","ceil","strokeWeight","reachedByIndex","unreachedIndex","shortestDist","uv","ui","rv","ri","thisDist","filter","v","noLoop","__webpack_exports__","_ref3","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_1__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_3__","path","pathname"],"mappings":"6IAIMA,EAAS,SAASC,GACtB,IACIC,EAIAC,EAFAC,EAAU,GAIdH,EAAEI,QAAU,WACVH,EAASD,EAAEK,SAASC,YAAW,gCAGjCN,EAAEO,MAAQ,WACRP,EAAEQ,aAAa,GACfR,EAAES,aAAa,IAAK,KACpBT,EAAEU,WAAW,GACbV,EAAEW,OAAO,KACT,IAAMC,EAAS,iDAAiDC,MAAM,MAClEC,EAAS,GACbF,EAAOG,QAAQ,SAACC,EAAKC,GACnBH,EAASA,EAAOI,OACdjB,EAAOkB,aAAaH,EAAK,GApBb,KAoB8BC,EAAO,GApBrC,IAoBoD,CAC9DG,aAAc,GAAKH,EAAO,QAIhCH,EAAOC,QAAQ,SAAAM,EAAWC,GAAM,IAAdC,EAAcF,EAAdE,EAAGC,EAAWH,EAAXG,EACbC,EAAczB,EAAE0B,IAAIJ,EAAG,EAAGR,EAAOa,OAAQ,EAAG,GAClDxB,EAAQyB,KAAK,CACXC,OAAQ7B,EAAE8B,aACRP,EAAIvB,EAAE0B,IAAI1B,EAAE+B,MAAMR,EAAGD,GAAI,EAAG,GAAIG,EAAaA,GAC7CD,EAAIxB,EAAE0B,IAAI1B,EAAE+B,MAAMP,EAAGF,GAAI,EAAG,GAAIG,EAAaA,IAE/CO,SAAS,EACTC,UAAW,MAGf9B,EAAQ,GAAG6B,SAAU,EACrB7B,EAAQ,GAAG8B,WAAa,EACxB/B,EAAUF,EAAEkC,KAAK,EAAG,EAAGlC,EAAEmC,MAAOnC,EAAEoC,SAGpCpC,EAAEqC,KAAO,WACPrC,EAAEU,WAAW,GACbP,EAAQY,QAAQ,SAAAuB,EAAiChB,GAAM,IAApCO,EAAoCS,EAApCT,OAAQG,EAA4BM,EAA5BN,QAASC,EAAmBK,EAAnBL,UAClC,GAAID,GAAWC,GAAa,EAAG,KAAAM,EACZpC,EAAQ8B,GAAWJ,OAA5BN,EADqBgB,EACrBhB,EAAGC,EADkBe,EAClBf,EACLgB,EAAWxC,EAAEyC,KAAKzC,EAAEkC,KAAKX,EAAGC,EAAGK,EAAON,EAAGM,EAAOL,IACtDxB,EAAE0C,aAAa1C,EAAE0B,IAAIc,EAAU,EAAG,GAAI,EAAG,GAAG,IAC5CxC,EAAEiB,KAAKM,EAAGC,EAAGK,EAAON,EAAGM,EAAOL,MAGlC,IACImB,EACAC,EAFAC,EAAe3C,EAGnBC,EAAQY,QAAQ,SAAC+B,EAAIC,GACdD,EAAGd,SACN7B,EAAQY,QAAQ,SAACiC,EAAIC,GACnB,GAAID,EAAGhB,QAAS,CACd,IAAMkB,EAAWlD,EAAEkC,KACjBY,EAAGjB,OAAON,EACVuB,EAAGjB,OAAOL,EACVwB,EAAGnB,OAAON,EACVyB,EAAGnB,OAAOL,GAER0B,EAAWL,IACbA,EAAeK,EACfN,EAAiBG,EACjBJ,EAAiBM,QAM3B9C,EAAQyC,GAAgBZ,SAAU,EAClC7B,EAAQyC,GAAgBX,UAAYU,EAEhCxC,EAAQgD,OAAO,SAAAC,GAAC,OAAIA,EAAEpB,UAASL,SAAWxB,EAAQwB,QACpD3B,EAAEqD,WAKOC,EAAA,iBAAAC,GAAA,IAAGC,EAAHD,EAAGC,SAAH,OACbC,OAAAC,EAAA,EAAAD,CAACE,EAAA,EAAD,CAAc5D,OAAQA,EAAQ6D,KAAMJ,EAASK","file":"component---src-pages-sketch-2019-01-19-js-8bbfde525852765c505c.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport { withPrefix } from \"gatsby\";\n\nconst sketch = function(p) {\n  const FONT_SIZE = 130;\n  let myFont;\n  let vectorCount;\n  let vectors = [];\n  let boundary;\n  let maxDist;\n\n  p.preload = function() {\n    myFont = p.loadFont(withPrefix(\"/assets/NewsCycle-Bold.ttf\"));\n  };\n\n  p.setup = function() {\n    p.pixelDensity(1);\n    p.createCanvas(660, 840);\n    p.background(0);\n    p.stroke(255);\n    const string = \"SELF-\\nESTEEM\\nSELF-\\nRELIANCE\\nSELF-\\nCONTROL\".split(\"\\n\");\n    let points = [];\n    string.forEach((str, line) => {\n      points = points.concat(\n        myFont.textToPoints(str, 25, FONT_SIZE * (line + 1), FONT_SIZE, {\n          sampleFactor: 1 / (line + 6),\n        })\n      );\n    });\n    points.forEach(({ x, y }, i) => {\n      const noiseFactor = p.map(i, 0, points.length, 0, 8);\n      vectors.push({\n        vector: p.createVector(\n          x + p.map(p.noise(x, i), 0, 1, -noiseFactor, noiseFactor),\n          y + p.map(p.noise(y, i), 0, 1, -noiseFactor, noiseFactor)\n        ),\n        reached: false,\n        reachedBy: 0,\n      });\n    });\n    vectors[0].reached = true;\n    vectors[0].reachedBy = -1;\n    maxDist = p.dist(0, 0, p.width, p.height);\n  };\n\n  p.draw = function() {\n    p.background(0);\n    vectors.forEach(({ vector, reached, reachedBy }, i) => {\n      if (reached && reachedBy > -1) {\n        const { x, y } = vectors[reachedBy].vector;\n        const distance = p.ceil(p.dist(x, y, vector.x, vector.y));\n        p.strokeWeight(p.map(distance, 5, 20, 1, 6, true));\n        p.line(x, y, vector.x, vector.y);\n      }\n    });\n    let shortestDist = maxDist;\n    let reachedByIndex;\n    let unreachedIndex;\n    vectors.forEach((uv, ui) => {\n      if (!uv.reached) {\n        vectors.forEach((rv, ri) => {\n          if (rv.reached) {\n            const thisDist = p.dist(\n              uv.vector.x,\n              uv.vector.y,\n              rv.vector.x,\n              rv.vector.y\n            );\n            if (thisDist < shortestDist) {\n              shortestDist = thisDist;\n              unreachedIndex = ui;\n              reachedByIndex = ri;\n            }\n          }\n        });\n      }\n    });\n    vectors[unreachedIndex].reached = true;\n    vectors[unreachedIndex].reachedBy = reachedByIndex;\n\n    if (vectors.filter(v => v.reached).length === vectors.length) {\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} />\n);\n"],"sourceRoot":""}