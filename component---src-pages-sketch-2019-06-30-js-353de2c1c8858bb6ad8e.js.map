{"version":3,"sources":["webpack:///./src/pages/sketch/2019/06/30.js"],"names":["sketch","p","w","h","DIR","random","GRID_SIZE","SIZES","grid","drawLines","xStart","yStart","xEnd","yEnd","dir","y","A","map","TWO_PI","COS","cos","stroke","strokeWeight","line","setup","createCanvas","background","fill","strokeCap","SQUARE","rectMode","CORNERS","floor","width","height","xx","push","yy","x","visited","draw","concat","filter","overlap","size","Math","max","s","length","noLoop","SketchPage"],"mappings":"yjBAIA,IAAMA,EAAS,SAASC,GACtB,IAKIC,EACAC,EANEC,EAAMH,EAAEI,OAAO,EAAC,GAAM,IACtBC,EAAY,GACZC,EAAQ,CAAC,EAAG,EAAG,IAEjBC,EAAO,GAIX,SAASC,EAAUC,EAAQC,EAAQC,EAAMC,EAAMC,QAAW,IAAXA,MAAMV,GACnD,IAAK,IAAIW,EAAIJ,EAAQI,GAAKF,EAAME,GAAKT,EAAW,CAC9C,IAAMU,EAAIf,EAAEgB,IAAIF,EAAGJ,EAAQE,EAAM,EAAGZ,EAAEiB,QAChCC,EAAMlB,EAAEmB,IAAIJ,GAElBf,EAAEoB,OAAO,KACTpB,EAAEqB,aAAahB,GACfL,EAAEsB,KAAKb,EAAQK,EAAGH,EAAMG,GAExBd,EAAEoB,OAAO,GACTpB,EAAEqB,aACArB,EAAEgB,IAAIE,GAAM,EAAG,EAAGL,EAAM,EAAgB,GAAZR,EAAiBQ,EAAkB,GAAZR,EAAkB,IAEvEL,EAAEsB,KAAKb,EAAQK,EAAGH,EAAMG,IAI5Bd,EAAEuB,MAAQ,WACRvB,EAAEwB,aAAa,IAAK,KACpBxB,EAAEyB,WAAW,KACbzB,EAAE0B,KAAK,KACP1B,EAAE2B,UAAU3B,EAAE4B,QACd5B,EAAE6B,SAAS7B,EAAE8B,SAEb7B,EAAID,EAAE+B,MAAM/B,EAAEgC,MAAQ3B,GACtBH,EAAIF,EAAE+B,MAAM/B,EAAEiC,OAAS5B,GAEvB,IAAK,IAAI6B,EAAK,EAAGA,EAAKjC,EAAGiC,IAAM,CAC7B3B,EAAK4B,KAAK,IACV,IAAK,IAAIC,EAAK,EAAGA,EAAKlC,EAAGkC,IACvB7B,EAAK2B,GAAIC,KAAK,CACZE,EAAGH,EACHpB,EAAGsB,EACHE,SAAS,IAKf9B,EAAU,EAAG,EAAGR,EAAEgC,MAAOhC,EAAEiC,QAAS9B,IAGtCH,EAAEuC,KAAO,WAAY,IAAD,MACDvC,EAAEI,QACjB,MAAGoC,OAAH,QAAajC,GAAMkC,QAAO,qBAAGH,YADvBD,EADU,EACVA,EAAGvB,EADO,EACPA,EAINP,EAAK8B,GAAGvB,GAAGwB,SAAU,WACxB,IACII,EADAC,EAAOC,KAAKC,IAAL,MAAAD,KAAYtC,GAGvB,EAAG,CACDoC,GAAU,EACV,IAAK,IAAIR,EAAKG,EAAGH,EAAKS,EAAON,EAAGH,IAC9B,IAAK,IAAIE,EAAKtB,EAAGsB,EAAKO,EAAO7B,EAAGsB,KAC1BC,EAAIM,EAAO1C,GAAKa,EAAI6B,EAAOzC,GAAKK,EAAK2B,GAAIE,GAAIE,WAC/CI,GAAU,GAIZA,IACFC,EAAOC,KAAKC,IAAL,MAAAD,KAAI,EAAQtC,EAAMmC,QAAO,SAAAK,GAAC,OAAIA,EAAIH,cAEpCD,GAETC,EAAO,GACLnC,EACE6B,EAAIhC,EACJS,EAAIT,EACJgC,EAAIhC,EAAYsC,EAAOtC,EACvBS,EAAIT,EAAYsC,EAAOtC,GAG3B,IAAK,IAAI6B,EAAKG,EAAGH,EAAKS,EAAON,EAAGH,IAC9B,IAAK,IAAIE,EAAKtB,EAAGsB,EAAKO,EAAO7B,EAAGsB,IAC9B7B,EAAK2B,GAAIE,GAAIE,SAAU,EA5BH,IAiCrB,MAAGE,OAAH,QAAajC,GAAMkC,QAAO,qBAAGH,WAAwBS,QACxD/C,EAAEgD,WAWOC,UANI,kBACjB,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAQlD,OAAQA","file":"component---src-pages-sketch-2019-06-30-js-353de2c1c8858bb6ad8e.js","sourcesContent":["import React from \"react\";\nimport Layout from \"~components/layout\";\nimport Sketch from \"~components/sketch\";\n\nconst sketch = function(p) {\n  const DIR = p.random([true, false]);\n  const GRID_SIZE = 15;\n  const SIZES = [1, 8, 13];\n\n  let grid = [];\n  let w;\n  let h;\n\n  function drawLines(xStart, yStart, xEnd, yEnd, dir = DIR) {\n    for (let y = yStart; y <= yEnd; y += GRID_SIZE) {\n      const A = p.map(y, yStart, yEnd, 0, p.TWO_PI);\n      const COS = p.cos(A);\n\n      p.stroke(255);\n      p.strokeWeight(GRID_SIZE);\n      p.line(xStart, y, xEnd, y);\n\n      p.stroke(0);\n      p.strokeWeight(\n        p.map(COS, -1, 1, dir ? 1 : GRID_SIZE * 0.8, dir ? GRID_SIZE * 0.8 : 1)\n      );\n      p.line(xStart, y, xEnd, y);\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.background(255);\n    p.fill(255);\n    p.strokeCap(p.SQUARE);\n    p.rectMode(p.CORNERS);\n\n    w = p.floor(p.width / GRID_SIZE);\n    h = p.floor(p.height / GRID_SIZE);\n\n    for (let xx = 0; xx < w; xx++) {\n      grid.push([]);\n      for (let yy = 0; yy < h; yy++) {\n        grid[xx].push({\n          x: xx,\n          y: yy,\n          visited: false,\n        });\n      }\n    }\n\n    drawLines(0, 0, p.width, p.height, !DIR);\n  };\n\n  p.draw = function() {\n    const { x, y } = p.random(\n      [].concat(...grid).filter(({ visited }) => !visited)\n    );\n\n    if (!grid[x][y].visited) {\n      let size = Math.max(...SIZES);\n      let overlap;\n\n      do {\n        overlap = false;\n        for (let xx = x; xx < size + x; xx++) {\n          for (let yy = y; yy < size + y; yy++) {\n            if (x + size > w || y + size > h || grid[xx][yy].visited) {\n              overlap = true;\n            }\n          }\n        }\n        if (overlap) {\n          size = Math.max(...SIZES.filter(s => s < size));\n        }\n      } while (overlap);\n\n      size > 1 &&\n        drawLines(\n          x * GRID_SIZE,\n          y * GRID_SIZE,\n          x * GRID_SIZE + size * GRID_SIZE,\n          y * GRID_SIZE + size * GRID_SIZE\n        );\n\n      for (let xx = x; xx < size + x; xx++) {\n        for (let yy = y; yy < size + y; yy++) {\n          grid[xx][yy].visited = true;\n        }\n      }\n    }\n\n    if (![].concat(...grid).filter(({ visited }) => !visited).length) {\n      p.noLoop();\n    }\n  };\n};\n\nconst SketchPage = () => (\n  <Layout>\n    <Sketch sketch={sketch} />\n  </Layout>\n);\n\nexport default SketchPage;\n"],"sourceRoot":""}