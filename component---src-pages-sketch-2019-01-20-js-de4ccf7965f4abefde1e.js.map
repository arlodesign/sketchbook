{"version":3,"sources":["webpack:///./src/pages/sketch/2019/01/20.js","webpack:///./src/lib/lineIntersection.js","webpack:///./src/lib/polarToCartesian.js"],"names":["sketch","p","speeds","drawing","lastPoint","guides","viewGuides","setup","createCanvas","createGraphics","width","height","background","stroke","strokeWeight","noFill","random","push","r","HALF_PI","speed","TWO_PI","direction","PI","Object","assign","draw","image","alpha","X0","polarToCartesianX","X1","Y1","sin","X2","Y2","Y3","color","line","i","length","x1","y1","x2","y2","x3","y3","x4","y4","uA","uB","x","y","frameCount","l","mousePressed","location","path","pathname","description","center","angle","distance","Math","cos","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","polarToCartesian"],"mappings":"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","file":"component---src-pages-sketch-2019-01-20-js-de4ccf7965f4abefde1e.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport { polarToCartesianX } from \"~lib/polarToCartesian\";\nimport lineIntersection from \"~lib/lineIntersection\";\n\nconst sketch = function(p) {\n  let speeds;\n  let guides = [];\n  let viewGuides = false;\n  let drawing;\n  let lastPoint;\n\n  function guideColor(alpha) {\n    return p.color(255, 0, 0, alpha);\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    drawing = p.createGraphics(p.width, p.height);\n    drawing.background(255);\n    drawing.stroke(0, 0, 0, 255 / 4);\n    drawing.strokeWeight(0.5);\n    drawing.noFill();\n    speeds = [p.random(0.2, 0.3), p.random(0.2, 0.3), p.random(0.2, 0.3)];\n    guides.push({\n      r: p.HALF_PI,\n      speed: speeds[0] / p.TWO_PI,\n      direction: p.random([-1, 1]),\n    });\n    guides.push({\n      r: 0,\n      speed: speeds[1] / p.TWO_PI,\n      direction: -1,\n    });\n    guides.push({\n      r: p.PI * 1.5,\n      speed: speeds[2] / p.TWO_PI,\n      direction: p.random([-1, 1]),\n    });\n    guides.push(Object.assign({}, guides[1]));\n  };\n\n  p.draw = function() {\n    p.background(255);\n    p.image(drawing, 0, 0);\n    const X0 = polarToCartesianX(p.width / 2, guides[0].r, p.width / 2 - 100);\n    const Y0 = 0;\n    const X1 = p.width;\n    const Y1 = p.height / 2 + p.sin(guides[1].r) * (p.height / 2 - 100);\n    const X2 = polarToCartesianX(p.width / 2, guides[2].r, p.width / 2 - 100);\n    const Y2 = p.height;\n    const X3 = 0;\n    const Y3 = p.height / 2 + p.sin(guides[3].r) * (p.height / 2 - 100);\n    if (viewGuides) {\n      p.stroke(guideColor(64));\n      p.strokeWeight(1);\n      p.line(X0, Y0, X2, Y2);\n      p.line(X1, Y1, X3, Y3);\n    }\n    for (let i = 0; i < guides.length; i++) {\n      guides[i].r += guides[i].speed * guides[i].direction;\n    }\n    const { x, y } = lineIntersection(X0, Y0, X2, Y2, X1, Y1, X3, Y3);\n    if (x && y && p.frameCount > 1) {\n      for (let l = 0; l < 1; l += 0.01) {\n        drawing.line(x, y, lastPoint.x, lastPoint.y);\n      }\n    }\n    lastPoint =\n      x && y\n        ? {\n            x,\n            y,\n          }\n        : lastPoint;\n  };\n\n  p.mousePressed = function() {\n    viewGuides = !viewGuides;\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout\n    sketch={sketch}\n    path={location.pathname}\n    description=\"Reload page for a different variation. Click or tap sketch to toggle guides.\"\n  />\n);\n","export default function lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n  const uA =\n    ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) /\n    ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n  const uB =\n    ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) /\n    ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n\n  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n    return { x: x1 + uA * (x2 - x1), y: y1 + uA * (y2 - y1) };\n  }\n  return { x: null, y: null };\n}\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}