{"version":3,"sources":["webpack:///./src/pages/sketch/2019/02/07.js","webpack:///./src/lib/polarToCartesian.js"],"names":["sketch","p","shapes","Shape","colorFunctions","angle","max","abs","sin","PI","cos","this","_cf","random","points","Array","fill","map","_","Point","_clr","color","frameCount","draw","beginShape","vertex","location","x","y","forEach","i","quadraticVertex","width","height","move","endShape","CLOSE","_angle","TWO_PI","_dist","_speed","_getLocation","polarToCartesian","setup","createCanvas","noStroke","blendMode","HARD_LIGHT","background","shape","path","pathname","description","polarToCartesianX","center","distance","Math","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray"],"mappings":"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","file":"component---src-pages-sketch-2019-02-07-js-8d8b0d002bb8e6dc35ee.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  let shapes = [];\n\n  class Shape {\n    constructor() {\n      const colorFunctions = [\n        angle => p.max(15, p.abs(p.sin(angle)) * 240),\n        angle => p.max(15, p.abs(p.sin(angle + p.PI)) * 240),\n        angle => p.max(15, p.abs(p.cos(-angle)) * 240),\n        angle => p.max(15, p.abs(p.cos(-angle + p.PI)) * 240),\n      ];\n      this._cf = [\n        p.random(colorFunctions),\n        p.random(colorFunctions),\n        p.random(colorFunctions),\n      ];\n      this.points = new Array(7).fill().map(_ => new Point());\n    }\n    _clr() {\n      return p.color(\n        this._cf[0](p.frameCount / 1000),\n        this._cf[1](p.frameCount / 1000),\n        this._cf[2](p.frameCount / 1000)\n      );\n    }\n    draw() {\n      p.fill(this._clr());\n      p.beginShape();\n      p.vertex(this.points[0].location.x, this.points[0].location.y);\n      this.points.forEach(({ location }, i) => {\n        if (i === 0) return;\n        p.quadraticVertex(p.width / 2, p.height / 2, location.x, location.y);\n        this.points[i].move();\n      });\n      p.quadraticVertex(\n        p.width / 2,\n        p.height / 2,\n        this.points[0].location.x,\n        this.points[0].location.y\n      );\n      p.endShape(p.CLOSE);\n    }\n  }\n\n  class Point {\n    constructor() {\n      this._angle = p.random(p.TWO_PI);\n      this._dist = p.random(p.height / 3, p.height / 2);\n      this._speed = p.random(-0.01, 0.01);\n      this.location = this._getLocation();\n    }\n\n    _getLocation() {\n      return polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        this._angle,\n        this._dist\n      );\n    }\n\n    move() {\n      this._angle += this._speed;\n      this.location = this._getLocation();\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    shapes = new Array(5).fill().map(_ => new Shape());\n    p.noStroke();\n    p.blendMode(p.HARD_LIGHT);\n  };\n\n  p.draw = function() {\n    p.background(0);\n    shapes.forEach((shape, i) => shape.draw());\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"Reload page for a different variation.\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}