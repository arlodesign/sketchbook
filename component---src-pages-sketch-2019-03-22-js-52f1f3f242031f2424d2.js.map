{"version":3,"sources":["webpack:///./src/pages/sketch/2019/03/22.js","webpack:///./src/lib/shuffle.js"],"names":["sketch","p","gridSize","maxDist","vectors","colors","drawShape","x","y","shape","push","translate","pop","triangle","rotate","random","HALF_PI","PI","beginShape","vertex","endShape","CLOSE","circle","scale","ellipse","square","rect","point","vector","reached","reachedBy","setup","createCanvas","colorMode","HSB","hue","shuffle","color","background","noStroke","fill","width","height","stroke","strokeWeight","dist","draw","reachedByIndex","unreachedIndex","shortestDist","forEach","uv","ui","rv","ri","thisDist","i","line","filter","v","length","_","location","path","pathname","description","a","j","Math","floor"],"mappings":"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","file":"component---src-pages-sketch-2019-03-22-js-52f1f3f242031f2424d2.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport shuffle from \"~lib/shuffle\";\n\nconst sketch = function(p) {\n  let gridSize;\n  let vectors = [];\n  let maxDist;\n  let colors = [];\n  let iteration = false;\n\n  function drawShape(x, y, shape) {\n    p.push();\n    p.translate(x + gridSize / 2, y + gridSize / 2);\n    shape(x, y);\n    p.pop();\n  }\n  const triangle = () => {\n    p.rotate(p.random([0, p.HALF_PI, p.PI, p.HALF_PI + p.PI]));\n    p.beginShape();\n    p.vertex(-gridSize / 2, -gridSize / 2);\n    p.vertex(gridSize / 2, gridSize / 2);\n    p.vertex(-gridSize / 2, gridSize / 2);\n    p.endShape(p.CLOSE);\n  };\n  const circle = () => {\n    p.scale(0.8);\n    p.ellipse(0, 0, gridSize);\n  };\n  const square = () => {\n    p.rect(-gridSize / 2, -gridSize / 2, gridSize, gridSize);\n  };\n  const point = (x, y) => {\n    p.point(0, 0);\n    vectors.push({\n      vector: { x: x + gridSize / 2, y: y + gridSize / 2 },\n      reached: false,\n      reachedBy: 0,\n    });\n  };\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, 100);\n\n    const hue = p.random(33);\n    colors = shuffle([\n      p.color(hue, p.random([20, 40, 60]), 33),\n      p.color(hue * 2, p.random([20, 40, 60]), 66),\n      p.color(hue * 3, p.random([20, 40, 60]), 99),\n    ]);\n\n    gridSize = p.random([20, 30, 60]);\n\n    p.background(colors[0]);\n\n    p.noStroke();\n    p.fill(colors[1]);\n\n    for (let x = 0; x < p.width; x += gridSize) {\n      for (let y = 0; y < p.height; y += gridSize) {\n        drawShape(\n          x,\n          y,\n          p.random([triangle, circle, square, point, point, point])\n        );\n      }\n    }\n\n    p.stroke(colors[0]);\n    p.strokeWeight(gridSize / 3);\n\n    vectors[0].reached = true;\n    vectors[0].reachedBy = -1;\n    maxDist = p.dist(0, 0, p.width, p.height);\n  };\n\n  p.draw = function() {\n    let shortestDist = maxDist;\n    let reachedByIndex;\n    let unreachedIndex;\n    vectors.forEach((uv, ui) => {\n      if (!uv.reached) {\n        vectors.forEach((rv, ri) => {\n          if (rv.reached) {\n            const thisDist = p.dist(\n              uv.vector.x,\n              uv.vector.y,\n              rv.vector.x,\n              rv.vector.y\n            );\n            if (thisDist < shortestDist) {\n              shortestDist = thisDist;\n              unreachedIndex = ui;\n              reachedByIndex = ri;\n            }\n          }\n        });\n      }\n    });\n    vectors[unreachedIndex].reached = true;\n    vectors[unreachedIndex].reachedBy = reachedByIndex;\n\n    vectors.forEach(({ vector, reached, reachedBy }, i) => {\n      if (reached && reachedBy > -1) {\n        const { x, y } = vectors[reachedBy].vector;\n        p.line(vector.x, vector.y, x, y);\n      }\n    });\n    if (vectors.filter(v => v.reached).length === vectors.length) {\n      if (iteration) {\n        p.noLoop();\n      } else {\n        p.stroke(colors[2]);\n        p.strokeWeight(gridSize / 5);\n        vectors.forEach((_, i) => {\n          vectors[i].reached = false;\n          vectors[i].reachedBy = 0;\n        });\n        vectors[0].reached = true;\n        vectors[0].reachedBy = -1;\n      }\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout\n    sketch={sketch}\n    path={location.pathname}\n    description=\"Be patient. Sometimes this will look like itâ€™s doing nothing for a few seconds. Refresh page for a different variation.\"\n  />\n);\n","export default function shuffle(a) {\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a;\n}\n"],"sourceRoot":""}