{"version":3,"sources":["webpack:///./src/pages/sketch/2019/08/08.js"],"names":["RENDER","process","DEV","sketch","p","SIZES","GRID_SIZE","grid","boxes","Box","x","y","size","this","direction","random","canvasSize","canvas","createGraphics","prototype","draw","noise","map","animLoop","noise2D","cos","theta","TWO_PI","blendMode","BLEND","background","SCREEN","push","noStroke","forEach","c","i","translate","noiseX","noiseY","sin","fill","circle","pop","image","setup","pixelDensity","frameRate","createCanvas","w","floor","width","h","height","createLoop","gif","render","open","noiseRadius","visited","_ref","concat","apply","filter","_ref2","length","_ref3","_p$random","_ref4","Math","max","overlap","xx","yy","s","b","__webpack_exports__","_ref5","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_1__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_3__","path","pathname","description"],"mappings":"sIAIMA,UAASC,GAAYC,MAAO,GAE5BC,EAAS,SAASC,GACtB,IAAMC,EAAQ,CAAC,EAAG,EAAG,EAAG,EAAG,GACrBC,EAAY,GAEdC,EAAO,GACPC,EAAQ,GAENC,EAPmB,WAQvB,SAAAA,EAAYC,EAAGC,EAAGC,GAChBC,KAAKH,EAAIA,EAAIJ,EACbO,KAAKF,EAAIA,EAAIL,EACbO,KAAKD,KAAOA,EACZC,KAAKC,UAAYV,EAAEW,OAAO,EAAE,EAAG,IAC/BF,KAAKG,WAAaV,EAAYM,EAC9BC,KAAKI,OAASb,EAAEc,eAAeL,KAAKG,WAAYH,KAAKG,YAdhC,OAAAP,EAAAU,UAiBvBC,KAAA,WAAO,IACGV,EAA8CG,KAA9CH,EAAGC,EAA2CE,KAA3CF,EAAGC,EAAwCC,KAAxCD,KAAiBK,GAAuBJ,KAAlCC,UAAkCD,KAAvBI,QAAQD,EAAeH,KAAfG,WACjCK,EAAQjB,EAAEkB,IAAIlB,EAAEmB,SAASC,QAAQd,EAAGC,IAAK,EAAG,EAAG,EAAG,GACzCP,EAAEkB,IAAIlB,EAAEqB,IAAIrB,EAAEmB,SAASG,QAAS,EAAG,EAAG,EAAGtB,EAAEuB,OAASN,GAEnEJ,EAAOW,UAAUxB,EAAEyB,OACnBZ,EAAOa,WAAW,GAClBb,EAAOW,UAAUxB,EAAE2B,QACnBd,EAAOe,OACPf,EAAOgB,WAEP,CAAC,MAAO,QAAS,QAAQC,QAAQ,SAACC,EAAGC,GACnCnB,EAAOe,OACPf,EAAOoB,UAAUrB,EAAa,EAAGA,EAAa,GAC9C,IAAMsB,EAASlC,EAAEmB,SAASC,QAAQpB,EAAEqB,IAAIrB,EAAEmB,SAASG,OAASU,EAAI,IAAK1B,GAC/D6B,EAASnC,EAAEmB,SAASC,QAAQpB,EAAEoC,IAAIpC,EAAEmB,SAASG,OAASU,EAAI,IAAKzB,GACrEM,EAAOoB,UACLrB,EAAaZ,EAAEkB,IAAIlB,EAAEqB,IAAIrB,EAAEmB,SAASG,QAAS,EAAG,EAAG,EAAGY,GACtDtB,EAAaZ,EAAEkB,IAAIlB,EAAEqB,IAAIrB,EAAEmB,SAASG,QAAS,EAAG,EAAG,EAAGa,IAExDtB,EAAOwB,KAAKN,GACZ,IAAK,IAAIC,EAAI,EAAGA,GAAKpB,EAAYoB,GAAKpB,EAAaJ,EACjDK,EAAOyB,OAAO,EAAG,EAAG1B,EAAa,GAEnCC,EAAO0B,QAET1B,EAAO0B,MAEPvC,EAAEwC,MAAM3B,EAAQP,EAAGC,IA7CEF,EAAA,GAiDzBL,EAAEyC,MAAQ,WACJ7C,IACFI,EAAE0C,aAAa,GACf1C,EAAE2C,UAAU,KAGd3C,EAAE4C,aAAa,IAAK,KACpB,IAAMC,EAAI7C,EAAE8C,MAAM9C,EAAE+C,MAAQ7C,GACtB8C,EAAIhD,EAAE8C,MAAM9C,EAAEiD,OAAS/C,GAE7BF,EAAEkD,WAAW,GAAI,CACfC,MAAKvD,GAAS,CAAEwD,QAAQ,EAAOC,MAAM,GACrCC,YAAa,IAGf,IAAK,IAAIhD,EAAI,EAAGA,EAAIN,EAAE+C,MAAQ7C,EAAWI,IAAK,CAC5CH,EAAKyB,KAAK,IACV,IAAK,IAAIrB,EAAI,EAAGA,EAAIP,EAAEiD,OAAS/C,EAAWK,IACxCJ,EAAKG,GAAGsB,KAAK,CACXtB,IACAC,IACAgD,SAAS,IAKf,MAAOC,EAAA,IAAGC,OAAHC,MAAAF,EAAarD,GAAMwD,OAAO,SAAAC,GAAA,OAAAA,EAAGL,UAAwBM,QAAQ,KAAAL,EAAAM,EAAAC,EACjD/D,EAAEW,QACjBmD,EAAA,IAAGL,OAAHC,MAAAI,EAAa3D,GAAMwD,OAAO,SAAAK,GAAA,OAAAA,EAAGT,WADvBjD,EAD0DyD,EAC1DzD,EAAGC,EADuDwD,EACvDxD,EAINJ,EAAKG,GAAGC,GAAGgD,SAAS,WACvB,IAAI/C,EAAOyD,KAAKC,IAALR,MAAAO,KAAYhE,GACnBkE,OAAO,EAEX,EAAG,CACDA,GAAU,EACV,IAAK,IAAIC,EAAK9D,EAAG8D,EAAK5D,EAAOF,EAAG8D,IAC9B,IAAK,IAAIC,EAAK9D,EAAG8D,EAAK7D,EAAOD,EAAG8D,KAC1B/D,EAAIE,EAAOqC,GAAKtC,EAAIC,EAAOwC,GAAK7C,EAAKiE,GAAIC,GAAId,WAC/CY,GAAU,GAIZA,IACF3D,EAAOyD,KAAKC,IAALR,MAAAO,KAAYhE,EAAM0D,OAAO,SAAAW,GAAC,OAAIA,EAAI9D,YAEpC2D,GAET/D,EAAMwB,KAAK,IAAIvB,EAAIC,EAAGC,EAAGC,IAEzB,IAAK,IAAI4D,EAAK9D,EAAG8D,EAAK5D,EAAOF,EAAG8D,IAC9B,IAAK,IAAIC,EAAK9D,EAAG8D,EAAK7D,EAAOD,EAAG8D,IAC9BlE,EAAKiE,GAAIC,GAAId,SAAU,EAtBJ,KA6B7BvD,EAAEgB,KAAO,WACPhB,EAAE0B,WAAW,GAEbtB,EAAM0B,QAAQ,SAAAyC,GAAC,OAAIA,EAAEvD,WAIVwD,EAAA,iBAAAC,GAAA,IAAGC,EAAHD,EAAGC,SAAH,OACbC,OAAAC,EAAA,EAAAD,CAACE,EAAA,EAAD,CAAc9E,OAAQA,EAAQ+E,KAAMJ,EAASK,SAAUC,YAAY","file":"component---src-pages-sketch-2019-08-08-js-fe3b203768343a0085ee.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport \"p5.createloop\";\n\nconst RENDER = process.env.DEV && false;\n\nconst sketch = function(p) {\n  const SIZES = [1, 2, 3, 5, 8];\n  const GRID_SIZE = 60;\n\n  let grid = [];\n  let boxes = [];\n\n  class Box {\n    constructor(x, y, size) {\n      this.x = x * GRID_SIZE;\n      this.y = y * GRID_SIZE;\n      this.size = size;\n      this.direction = p.random([-1, 1]);\n      this.canvasSize = GRID_SIZE * size;\n      this.canvas = p.createGraphics(this.canvasSize, this.canvasSize);\n    }\n\n    draw() {\n      const { x, y, size, direction, canvas, canvasSize } = this;\n      const noise = p.map(p.animLoop.noise2D(x, y), -1, 1, 0, 1);\n      const offset = p.map(p.cos(p.animLoop.theta), -1, 1, 0, p.TWO_PI * noise);\n\n      canvas.blendMode(p.BLEND);\n      canvas.background(0);\n      canvas.blendMode(p.SCREEN);\n      canvas.push();\n      canvas.noStroke();\n\n      [\"red\", \"green\", \"blue\"].forEach((c, i) => {\n        canvas.push();\n        canvas.translate(canvasSize / 2, canvasSize / 2);\n        const noiseX = p.animLoop.noise2D(p.cos(p.animLoop.theta * (i + 1)), x);\n        const noiseY = p.animLoop.noise2D(p.sin(p.animLoop.theta * (i + 1)), y);\n        canvas.translate(\n          canvasSize * p.map(p.cos(p.animLoop.theta), -1, 1, 0, noiseX),\n          canvasSize * p.map(p.cos(p.animLoop.theta), -1, 1, 0, noiseY)\n        );\n        canvas.fill(c);\n        for (let i = 0; i <= canvasSize; i += canvasSize / size) {\n          canvas.circle(0, 0, canvasSize / 2);\n        }\n        canvas.pop();\n      });\n      canvas.pop();\n\n      p.image(canvas, x, y);\n    }\n  }\n\n  p.setup = function() {\n    if (RENDER) {\n      p.pixelDensity(1);\n      p.frameRate(30);\n    }\n\n    p.createCanvas(660, 840);\n    const w = p.floor(p.width / GRID_SIZE);\n    const h = p.floor(p.height / GRID_SIZE);\n\n    p.createLoop(10, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 1,\n    });\n\n    for (let x = 0; x < p.width / GRID_SIZE; x++) {\n      grid.push([]);\n      for (let y = 0; y < p.height / GRID_SIZE; y++) {\n        grid[x].push({\n          x,\n          y,\n          visited: false,\n        });\n      }\n    }\n\n    while ([].concat(...grid).filter(({ visited }) => !visited).length) {\n      const { x, y } = p.random(\n        [].concat(...grid).filter(({ visited }) => !visited)\n      );\n\n      if (!grid[x][y].visited) {\n        let size = Math.max(...SIZES);\n        let overlap;\n\n        do {\n          overlap = false;\n          for (let xx = x; xx < size + x; xx++) {\n            for (let yy = y; yy < size + y; yy++) {\n              if (x + size > w || y + size > h || grid[xx][yy].visited) {\n                overlap = true;\n              }\n            }\n          }\n          if (overlap) {\n            size = Math.max(...SIZES.filter(s => s < size));\n          }\n        } while (overlap);\n\n        boxes.push(new Box(x, y, size));\n\n        for (let xx = x; xx < size + x; xx++) {\n          for (let yy = y; yy < size + y; yy++) {\n            grid[xx][yy].visited = true;\n          }\n        }\n      }\n    }\n  };\n\n  p.draw = function() {\n    p.background(0);\n\n    boxes.forEach(b => b.draw());\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}