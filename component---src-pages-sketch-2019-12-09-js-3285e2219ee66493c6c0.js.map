{"version":3,"sources":["webpack:///./src/pages/sketch/2019/12/09.js","webpack:///./src/lib/addNoise.js","webpack:///./src/lib/polarToCartesian.js"],"names":["sketch","p","y","HUE","random","i","points","Point","aLow","aHigh","this","aNoise","dNoise","get","noise1D","animLoop","polarToCartesian","map","setup","frameRate","createCanvas","colorMode","HSL","background","POINTS","createLoop","height","noiseRadius","strokeWeight","Array","fill","_","TWO_PI","draw","noFill","blendMode","OVERLAY","translate","width","rotate","theta","forEach","pt","ip","a","b","c","d","j","x","curvePoint","stroke","cos","sin","point","BLEND","addNoise","noLoop","location","path","pathname","description","intensity","PTS","push","noStroke","ellipse","randomGaussian","pixelDensity","pop","polarToCartesianX","center","angle","distance","Math","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray"],"mappings":"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","file":"component---src-pages-sketch-2019-12-09-js-3285e2219ee66493c6c0.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport addNoise from \"~lib/addNoise\";\nimport \"p5.createloop\";\n\nconst sketch = function(p) {\n  const ITERATIONS = 3;\n  const RATE = 0.5;\n  const POINTS = 7;\n  const HUE = p.random(POINTS);\n  const SIZE = 300;\n\n  let y;\n  let i = 0;\n  let points = [];\n\n  class Point {\n    constructor(aLow, aHigh) {\n      this.aLow = aLow;\n      this.aHigh = aHigh;\n      this.aNoise = p.random();\n      this.dNoise = p.random();\n    }\n    get() {\n      const { noise1D } = p.animLoop;\n      return polarToCartesian(\n        0,\n        0,\n        p.map(noise1D(this.aNoise), -1, 1, this.aLow, this.aHigh),\n        p.map(noise1D(this.dNoise), -1, 1, 0, SIZE)\n      );\n    }\n  }\n\n  p.setup = function() {\n    p.frameRate(30);\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSL, POINTS);\n    p.background(POINTS - HUE, POINTS / 3, POINTS / 2);\n    p.createLoop(((p.height / RATE) * ITERATIONS) / 30, {\n      noiseRadius: 0.5,\n    });\n    p.strokeWeight(2);\n\n    y = p.height + SIZE;\n    points = Array(POINTS)\n      .fill()\n      .map(\n        (_, i) =>\n          new Point((p.TWO_PI / POINTS) * i, (p.TWO_PI / POINTS) * (i + 1))\n      );\n  };\n\n  p.draw = function() {\n    p.noFill();\n    p.blendMode(p.OVERLAY);\n\n    p.translate(p.width / 2 + (p.width / 4) * p.animLoop.noise1D(0.7), y);\n    p.rotate(p.animLoop.theta);\n\n    points.forEach((pt, ip) => {\n      const a = pt.get();\n      const b = points[(ip + 1) % POINTS].get();\n      const c = points[(ip + 2) % POINTS].get();\n      const d = points[(ip + 3) % POINTS].get();\n\n      for (let j = 0; j < 1; j += 1 / 40) {\n        const x = p.curvePoint(a.x, b.x, c.x, d.x, j);\n        const y = p.curvePoint(a.y, b.y, c.y, d.y, j);\n\n        p.stroke(\n          HUE,\n          p.map(p.cos((ip + j) * (p.TWO_PI / POINTS)), -1, 1, POINTS, 0),\n          p.map(p.sin((ip + j) * (p.TWO_PI / POINTS)), -1, 1, 0, POINTS),\n          POINTS / 3\n        );\n        p.point(x, y);\n      }\n    });\n\n    y -= RATE;\n\n    if (y < -SIZE) {\n      y = p.height + SIZE;\n      i++;\n    }\n\n    if (i === ITERATIONS) {\n      p.blendMode(p.BLEND);\n      addNoise(p, 0.7);\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const addNoise = (p, intensity = 0.5) => {\n  const PTS = p.width * p.height * 0.02;\n\n  p.push();\n  for (let i = 0; i < PTS; i++) {\n    p.fill(\n      i % 2\n        ? `rgba(0, 0, 0, ${intensity})`\n        : `rgba(255, 255, 255, ${intensity})`\n    );\n    p.noStroke();\n    p.ellipse(\n      p.randomGaussian(p.width / 2, p.width / 3),\n      p.randomGaussian(p.height / 2, p.height / 3),\n      1 / (p.pixelDensity() / 2)\n    );\n  }\n  p.pop();\n};\n\nexport default addNoise;\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}