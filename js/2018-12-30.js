let maxSize,minSize,circles=[],increment=1,noDrawCount=0,noDrawLimit=1500;class Circle{constructor(i=0){this.distance=i,this.angle=frameCount/increment,this.r=constrain(noise(this.angle)*maxSize,minSize,maxSize),this._setXY()}_setXY(){this.x=width/2+cos(this.angle)*this.distance,this.y=height/2+sin(this.angle)*this.distance}setDistance(i){this.distance=i,this._setXY()}increaseDistance(){this.distance+=1,this._setXY()}isOnCanvas(){return this.x>this.r&&this.x<width-this.r&&this.y>this.r&&this.y<height-this.r}draw(){ellipse(this.x,this.y,2*this.r)}}function setup(){pixelDensity(4),createCanvas(660,840).parent("my-canvas"),maxSize=random(width/4,width/3),minSize=5,circles.push(new Circle),fill(0),stroke(0),circles[0].r=maxSize,circles[0].draw()}function draw(){background(255),maxSize===minSize&&noDrawCount===noDrawLimit&&(noLoop(),drawingComplete=!0),circles.forEach(i=>i.draw()),noDrawCount<noDrawLimit&&(push(),noStroke(),fill(255),rect(0,0,80,30),fill(0),text(`${noDrawCount}/${noDrawLimit}`,10,20),pop());const i=new Circle;for(i.setDistance(circles[0].r+i.r),noDrawCount<noDrawLimit&&(push(),stroke("red"),strokeWeight(1),line(width/2,height/2,width/2+cos(i.angle)*height,height/2+sin(i.angle)*height),pop());circles.some(e=>dist(i.x,i.y,e.x,e.y)<i.r+e.r);)i.increaseDistance();i.isOnCanvas()?(circles.push(i),maxSize>minSize&&(increment+=5),noDrawCount=0):(maxSize=max(maxSize-.1,minSize),increment=maxSize>minSize?max(1,increment-1):increment,noDrawCount++)}