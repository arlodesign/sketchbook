{"version":3,"sources":["webpack:///./src/pages/sketch/2019/04/01.js","webpack:///./src/lib/polarToCartesian.js"],"names":["__webpack_require__","r","__webpack_exports__","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_1__","_lib_polarToCartesian__WEBPACK_IMPORTED_MODULE_2__","sketch","p","ellipseA","ellipseB","speedA","random","TWO_PI","speedB","speedStart","angleA","angleB","PI","angleStart","curves","setup","createCanvas","colorMode","HSL","width","height","draw","background","stroke","noFill","push","pointA","polarToCartesianEllipse","apply","concat","pointB","hue","map","sin","frameCount","start","polarToCartesian","end","length","shift","forEach","c","i","beginShape","vertex","bezierVertex","endShape","line","_ref","location","a","createElement","path","pathname","description","d","polarToCartesianX","polarToCartesianY","center","angle","distance","Math","cos","centerX","centerY","radiusX","radiusY","asArray","x","y"],"mappings":"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","file":"component---src-pages-sketch-2019-04-01-js-fd5dec3989dbca9ea11e.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian, {\n  polarToCartesianEllipse,\n} from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  const CURVE_COUNT = 100;\n\n  let ellipseA = [];\n  let ellipseB = [];\n  let speedA = p.random(0.1, 0.5) / p.TWO_PI;\n  let speedB = p.random(0.1, 0.5) / p.TWO_PI;\n  let speedStart = p.random(0.01, 0.05) / p.TWO_PI;\n  let angleA = 0;\n  let angleB = p.PI;\n  let angleStart = 0;\n  let curves = [];\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSL, 100);\n    ellipseA = [\n      p.random(p.width / 3, p.width / 2),\n      p.random(p.height / 3, p.height / 2),\n    ];\n    ellipseB = [\n      p.random(p.width / 3, p.width / 2),\n      p.random(p.height / 3, p.height / 2),\n    ];\n  };\n\n  p.draw = function() {\n    p.background(0);\n    p.stroke(255);\n    p.noFill();\n\n    curves.push({\n      pointA: polarToCartesianEllipse(\n        p.width / 2,\n        p.height / 2,\n        angleA,\n        ...ellipseA,\n        true\n      ),\n      pointB: polarToCartesianEllipse(\n        p.width / 2,\n        p.height / 2,\n        angleB,\n        ...ellipseB,\n        true\n      ),\n      hue: p.map(p.sin(p.frameCount / 1000), -1, 1, 0, 100),\n    });\n\n    const start = polarToCartesian(\n      p.width / 2,\n      p.height / 2,\n      angleStart,\n      p.width * 0.4,\n      true\n    );\n    const end = polarToCartesian(\n      p.width / 2,\n      p.height / 2,\n      angleStart + p.PI,\n      p.width * 0.4,\n      true\n    );\n\n    if (curves.length > CURVE_COUNT) curves.shift();\n    curves.forEach((c, i) => {\n      p.stroke(c.hue, 50, 75, 100 * (i / CURVE_COUNT));\n      p.beginShape();\n      p.vertex(...start);\n      p.bezierVertex(...c.pointA, ...c.pointB, ...end);\n      p.endShape();\n      p.stroke(c.hue, 50, 50, 25);\n      p.line(...c.pointA, ...c.pointB);\n    });\n\n    angleA += speedA;\n    angleB -= speedB;\n    angleStart += speedStart;\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}