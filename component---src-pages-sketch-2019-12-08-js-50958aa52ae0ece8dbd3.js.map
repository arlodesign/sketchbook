{"version":3,"sources":["webpack:///./src/lib/addNoise.js","webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2019/12/08.js"],"names":["addNoise","p","intensity","PTS","width","height","push","i","fill","noStroke","ellipse","randomGaussian","pixelDensity","pop","polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y","polarToCartesian","sketch","HUE","random","setup","frameRate","createCanvas","colorMode","HSL","background","ITERATIONS","createLoop","noiseRadius","strokeWeight","draw","noFill","blendMode","OVERLAY","a","TWO_PI","map","noise","stroke","QUARTER_PI","point","animLoop","noise1D","frameCount","noLoop","location","path","pathname","description"],"mappings":"uGAoBeA,IApBE,SAACC,EAAGC,QAAoB,IAApBA,MAAY,IAC/B,IAAMC,EAAMF,EAAEG,MAAQH,EAAEI,OAAS,IAEjCJ,EAAEK,OACF,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAKI,IACvBN,EAAEO,KACAD,EAAI,EAAJ,iBACqBL,EADrB,2BAE2BA,EAF3B,KAIFD,EAAEQ,WACFR,EAAES,QACAT,EAAEU,eAAeV,EAAEG,MAAQ,EAAGH,EAAEG,MAAQ,GACxCH,EAAEU,eAAeV,EAAEI,OAAS,EAAGJ,EAAEI,OAAS,GAC1C,GAAKJ,EAAEW,eAAiB,IAG5BX,EAAEY,Q,kCCjBJ,0GAAMC,EAAoB,SAACC,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKC,IAAIH,GAASC,GAE9BG,EAAoB,SAACL,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKG,IAAIL,GAASC,GAsB9BK,EAA0B,SAC9BC,EACAC,EACAR,EACAS,EACAC,EACAC,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIL,EAAUL,KAAKC,IAAIH,GAASS,EAChCI,EAAIL,EAAUN,KAAKG,IAAIL,GAASU,EACtC,OAAOC,EAAU,CAACC,EAAGC,GAAK,CAAED,IAAGC,MAIlBC,IAzBU,SACvBP,EACAC,EACAR,EACAC,EACAU,QACG,IADHA,OAAU,GAEV,IAAMC,EAAId,EAAkBS,EAASP,EAAOC,GACtCY,EAAIT,EAAkBI,EAASR,EAAOC,GAC5C,OAAOU,EAAU,CAACC,EAAGC,GAAK,CAAED,IAAGC,O,66BClBjC,IAAME,EAAS,SAAS9B,GACtB,IAII4B,EAFEG,EAAM/B,EAAEgC,OAFK,GAKf1B,EAAI,EAERN,EAAEiC,MAAQ,WACRjC,EAAEkC,UAAU,IACZlC,EAAEmC,aAAa,IAAK,KACpBnC,EAAEoC,UAAUpC,EAAEqC,IAVG,GAWjBrC,EAAEsC,WAXe,EAWSP,EAAK,EAAGQ,IAClCvC,EAAEwC,WAAaxC,EAAEI,OAXN,EADM,EAY+B,GAAI,CAClDqC,YAAa,KAEfzC,EAAE0C,aAAa,GAEfd,EAAI5B,EAAEI,OAAS,KAGjBJ,EAAE2C,KAAO,WACP3C,EAAE4C,SACF5C,EAAE6C,UAAU7C,EAAE8C,SAEd,IACE,IAAIC,EAAI,EACRA,EAAI/C,EAAEgD,OACND,GAAK/C,EAAEiD,IAAIjD,EAAEkD,MAAM,IAAM,EAAG,EAAG,KAAO,MAEtClD,EAAEmD,OACApB,EACU,KAATzB,EAAI,GACLN,EAAEiD,IAAIjD,EAAEoB,IAAI2B,EAAI/C,EAAEoD,aAAc,EAAG,EAAG,GAAKb,MAhC9B,EAiCCjC,GAAK,IAGrBN,EAAEqD,MAAF,MAAArD,EAAC,EACIqB,YACDrB,EAAEG,MAAQ,EAAKH,EAAEG,MAAQ,EAAKH,EAAEsD,SAASC,QAAQ,IACjD3B,EACAmB,EACE/C,EAAEG,MAAQ,EAAKH,EAAEkD,MAAMlD,EAAEkB,IAAI6B,GAAI/C,EAAEwD,WAAa,MAASlD,EAAI,GAC/D,GAAKN,EAAEkD,MAAMlD,EAAEkB,IAAI6B,GAAI/C,EAAEwD,WAAa,MACtC,MAKN5B,GA/CW,IAiDF,MACPA,EAAI5B,EAAEI,OAAS,IACfE,KApDe,IAuDbA,IACFP,YAASC,EAAG,IACZA,EAAEyD,YAKO,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAc5B,OAAQA,EAAQ6B,KAAMD,EAASE,SAAUC,YAAY","file":"component---src-pages-sketch-2019-12-08-js-50958aa52ae0ece8dbd3.js","sourcesContent":["const addNoise = (p, intensity = 0.5) => {\n  const PTS = p.width * p.height * 0.02;\n\n  p.push();\n  for (let i = 0; i < PTS; i++) {\n    p.fill(\n      i % 2\n        ? `rgba(0, 0, 0, ${intensity})`\n        : `rgba(255, 255, 255, ${intensity})`\n    );\n    p.noStroke();\n    p.ellipse(\n      p.randomGaussian(p.width / 2, p.width / 3),\n      p.randomGaussian(p.height / 2, p.height / 3),\n      1 / (p.pixelDensity() / 2)\n    );\n  }\n  p.pop();\n};\n\nexport default addNoise;\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport { polarToCartesianEllipse } from \"~lib/polarToCartesian\";\nimport addNoise from \"~lib/addNoise\";\nimport \"p5.createloop\";\n\nconst sketch = function(p) {\n  const ITERATIONS = 3;\n  const RATE = 4;\n  const HUE = p.random(ITERATIONS);\n\n  let y;\n  let i = 0;\n\n  p.setup = function() {\n    p.frameRate(30);\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSL, ITERATIONS);\n    p.background(ITERATIONS - HUE, 1, ITERATIONS / 10);\n    p.createLoop(((p.height / RATE) * ITERATIONS) / 30, {\n      noiseRadius: 0.5,\n    });\n    p.strokeWeight(5);\n\n    y = p.height + 100;\n  };\n\n  p.draw = function() {\n    p.noFill();\n    p.blendMode(p.OVERLAY);\n\n    for (\n      let a = 0;\n      a < p.TWO_PI;\n      a += p.map(p.noise(0.6), 0, 1, 0.001, 0.005)\n    ) {\n      p.stroke(\n        HUE,\n        (i + 1) * 0.75,\n        p.map(p.sin(a + p.QUARTER_PI), -1, 1, 0.5, ITERATIONS - 0.5),\n        (ITERATIONS - i) / 10\n      );\n\n      p.point(\n        ...polarToCartesianEllipse(\n          p.width / 2 + (p.width / 4) * p.animLoop.noise1D(0.7),\n          y,\n          a,\n          ((p.width / 2) * p.noise(p.cos(a), p.frameCount / 100)) / (i + 1),\n          50 * p.noise(p.cos(a), p.frameCount / 100),\n          true\n        )\n      );\n    }\n\n    y -= RATE;\n\n    if (y < -100) {\n      y = p.height + 100;\n      i++;\n    }\n\n    if (i === ITERATIONS) {\n      addNoise(p, 0.7);\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}