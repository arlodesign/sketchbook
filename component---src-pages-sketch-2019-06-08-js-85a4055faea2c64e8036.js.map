{"version":3,"sources":["webpack:///./src/pages/sketch/2019/06/08.js","webpack:///./src/lib/polarToCartesian.js"],"names":["sketch","p","HUE","random","vertices","Vertex","this","angle","TWO_PI","distance","height","speed","get","polarToCartesian","width","update","setup","createCanvas","noStroke","colorMode","HSL","background","Array","from","draw","vs","filter","clr","color","map","cos","frameCount","sin","length","noFill","stroke","line","fill","beginShape","sort","a","b","forEach","v","vertex","endShape","CLOSE","noLoop","location","path","pathname","description","polarToCartesianX","center","Math","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y"],"mappings":"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","file":"component---src-pages-sketch-2019-06-08-js-85a4055faea2c64e8036.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  const HUE = p.random(80);\n  const V_QTY = 10;\n\n  let vertices = [];\n\n  class Vertex {\n    constructor() {\n      this.angle = p.random(p.TWO_PI);\n      this.distance = p.random(p.height * (2 / 3));\n      this.speed = p.random([-1, 1]) * p.random(0.0001, 0.001);\n    }\n    get() {\n      return polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        this.angle,\n        this.distance,\n        true\n      );\n    }\n    update() {\n      this.angle += this.speed;\n      if (this.angle < 0) {\n        this.angle = p.TWO_PI + this.angle;\n      }\n      if (this.angle > p.TWO_PI) {\n        this.angle = this.angle - p.TWO_PI;\n      }\n      this.distance = this.distance > 0 ? this.distance - 0.03 : 0;\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.noStroke();\n    p.colorMode(p.HSL, 100);\n    p.background(HUE, 100, 0);\n\n    vertices = Array.from(Array(V_QTY), () => new Vertex());\n  };\n\n  p.draw = function() {\n    const vs = vertices.filter(({ distance }) => distance > 0);\n    const clr = p.color(\n      p.map(p.cos(p.frameCount / 1000), -1, 1, HUE, HUE + 20),\n      p.map(p.sin(p.frameCount / 50), -1, 1, 80, 100),\n      p.map(p.cos(p.frameCount / 500), -1, 1, 0, 100),\n      80\n    );\n\n    if (vs.length === 1) {\n      p.noLoop();\n      return;\n    }\n\n    if (vs.length === 2) {\n      p.noFill();\n      p.stroke(clr);\n      p.line(...vs[0].get(), ...vs[1].get());\n      vs[0].update();\n      vs[1].update();\n    } else {\n      p.noStroke();\n      p.fill(clr);\n      p.beginShape();\n      vs.sort((a, b) => a.angle - b.angle).forEach(v => {\n        p.vertex(...v.get());\n        v.update();\n      });\n      p.endShape(p.CLOSE);\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}