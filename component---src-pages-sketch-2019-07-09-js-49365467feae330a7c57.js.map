{"version":3,"sources":["webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2019/07/09.js"],"names":["polarToCartesianEllipse","centerX","centerY","angle","radiusX","radiusY","asArray","x","Math","cos","y","sin","polarToCartesian","distance","center","polarToCartesianX","polarToCartesianY","sketch","p","COLORS","shuffle","circles","Circle","this","startA","random","TWO_PI","draw","forEach","c","i","fill","circle","animLoop","theta","length","map","SIZE","noise2D","setup","createCanvas","noStroke","createLoop","gif","noiseRadius","push","width","height","r","ai","dist","circleCount","floor","a","blendMode","BLEND","background","MULTIPLY","SketchPage"],"mappings":"4FAAA,sCAiBMA,EAA0B,SAC9BC,EACAC,EACAC,EACAC,EACAC,EACAC,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIN,EAAUO,KAAKC,IAAIN,GAASC,EAChCM,EAAIR,EAAUM,KAAKG,IAAIR,GAASE,EACtC,OAAOC,EAAU,CAACC,EAAGG,GAAK,CAAEH,IAAGG,MAIlBE,IAzBU,SACvBX,EACAC,EACAC,EACAU,EACAP,QACG,IADHA,OAAU,GAEV,IAAMC,EAbkB,SAACO,EAAQX,EAAOU,GACxC,OAAOC,EAASN,KAAKC,IAAIN,GAASU,EAYxBE,CAAkBd,EAASE,EAAOU,GACtCH,EAXkB,SAACI,EAAQX,EAAOU,GACxC,OAAOC,EAASN,KAAKG,IAAIR,GAASU,EAUxBG,CAAkBd,EAASC,EAAOU,GAC5C,OAAOP,EAAU,CAACC,EAAGG,GAAK,CAAEH,IAAGG,O,qjCCTjC,IAEMO,EAAS,SAASC,GACtB,IAAMC,EAASD,EAAEE,QAAQ,CAAC,OAAQ,SAAU,YAGxCC,EAAU,GAERC,EANmB,WAOvB,WAAYf,EAAGG,GACba,KAAKhB,EAAIA,EACTgB,KAAKb,EAAIA,EACTa,KAAKC,OAASN,EAAEO,OAAOP,EAAEQ,QAVJ,mBAYvBC,KAAA,WAAQ,IAAD,OACLR,EAAOS,SAAQ,SAACC,EAAGC,GACjBZ,EAAEa,KAAKF,GACPX,EAAEc,OAAF,MAAAd,EAAC,EACIN,YACD,EAAKL,EACL,EAAKG,EACL,EAAKc,OAASN,EAAEe,SAASC,MAAShB,EAAEQ,OAASP,EAAOgB,OAAUL,EAjB7D,GAkBMZ,EAAEkB,IAAIlB,EAAET,IAAIS,EAAEe,SAASC,QAAS,EAAG,EAAG,EAAG,IAChD,IANH,QAQChB,EAAEkB,IACAlB,EAAET,IAAIS,EAAEe,SAASC,QAChB,EACD,EACAG,GAzBC,GA0BDnB,EAAEkB,IAAIlB,EAAEe,SAASK,QAAQ,EAAK/B,EAAG,EAAKG,IAAK,EAAG,EAAG,EAAG,WA5BrC,KAkCzBQ,EAAEqB,MAAQ,WAMRrB,EAAEsB,aAAa,IAAK,KACpBtB,EAAEuB,WACFvB,EAAEwB,WAAW,EAAG,CACdC,KAA8C,EAC9CC,YAAa,KAEfvB,EAAQwB,KAAK,IAAIvB,EAAOJ,EAAE4B,MAAQ,EAAG5B,EAAE6B,OAAS,IAKhD,IAHA,IAAIC,EA9CK,GA+CLxB,EAAS,EAENwB,EAAI9B,EAAE4B,MAAQ,GAAG,CAEtB,IADA,IAAIG,EAAK,EAEP/B,EAAEgC,KAAF,MAAAhC,EAAC,EACIN,YAAiBM,EAAE4B,MAAQ,EAAG5B,EAAE6B,OAAS,EAAG,EAAGC,GAAG,IADtD,SAEIpC,YAAiBM,EAAE4B,MAAQ,EAAG5B,EAAE6B,OAAS,EAAGE,EAAID,GAAG,MAtDnD,IAyDLC,GAAU,KAKZ,IAFA,IAAME,EAAc3C,KAAK4C,MAAMlC,EAAEQ,OAASuB,GAEjCI,EAAI7B,EAAQ6B,EAAInC,EAAEQ,OAASF,EAAQ6B,GAAKnC,EAAEQ,OAASyB,EAC1D9B,EAAQwB,KAAR,EACMvB,EADN,EACgBV,YAAiBM,EAAE4B,MAAQ,EAAG5B,EAAE6B,OAAS,EAAGM,EAAGL,GAAG,MAIpEA,GApEO,GAqEPxB,GAAUyB,IAId/B,EAAES,KAAO,WACPT,EAAEoC,UAAUpC,EAAEqC,OACdrC,EAAEsC,WAAW,KACbtC,EAAEoC,UAAUpC,EAAEuC,UACdpC,EAAQO,SAAQ,SAAAC,GAAC,OAAIA,EAAEF,YAUZ+B,UANI,kBACjB,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAQzC,OAAQA","file":"component---src-pages-sketch-2019-07-09-js-49365467feae330a7c57.js","sourcesContent":["const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\nimport Layout from \"~components/layout\";\nimport Sketch from \"~components/sketch\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport \"p5.createloop\";\n\nconst RENDER = false;\n\nconst sketch = function(p) {\n  const COLORS = p.shuffle([\"cyan\", \"yellow\", \"magenta\"]);\n  let SIZE = 30;\n\n  let circles = [];\n\n  class Circle {\n    constructor(x, y) {\n      this.x = x;\n      this.y = y;\n      this.startA = p.random(p.TWO_PI);\n    }\n    draw() {\n      COLORS.forEach((c, i) => {\n        p.fill(c);\n        p.circle(\n          ...polarToCartesian(\n            this.x,\n            this.y,\n            this.startA + p.animLoop.theta + (p.TWO_PI / COLORS.length) * i,\n            SIZE * p.map(p.cos(p.animLoop.theta), -1, 1, 0, 2),\n            true\n          ),\n          p.map(\n            p.cos(p.animLoop.theta),\n            -1,\n            1,\n            SIZE / 3,\n            p.map(p.animLoop.noise2D(this.x, this.y), -1, 1, 1, 3) * SIZE\n          )\n        );\n      });\n    }\n  }\n  p.setup = function() {\n    if (RENDER) {\n      p.pixelDensity(1);\n      p.frameRate(30);\n    }\n\n    p.createCanvas(660, 840);\n    p.noStroke();\n    p.createLoop(5, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 0.2,\n    });\n    circles.push(new Circle(p.width / 2, p.height / 2));\n\n    let r = SIZE;\n    let startA = 0;\n\n    while (r < p.width / 2) {\n      let ai = 0;\n      while (\n        p.dist(\n          ...polarToCartesian(p.width / 2, p.height / 2, 0, r, true),\n          ...polarToCartesian(p.width / 2, p.height / 2, ai, r, true)\n        ) < SIZE\n      ) {\n        ai = ai + 0.001;\n      }\n\n      const circleCount = Math.floor(p.TWO_PI / ai);\n\n      for (let a = startA; a < p.TWO_PI + startA; a += p.TWO_PI / circleCount) {\n        circles.push(\n          new Circle(...polarToCartesian(p.width / 2, p.height / 2, a, r, true))\n        );\n      }\n\n      r += SIZE;\n      startA += ai;\n    }\n  };\n\n  p.draw = function() {\n    p.blendMode(p.BLEND);\n    p.background(255);\n    p.blendMode(p.MULTIPLY);\n    circles.forEach(c => c.draw());\n  };\n};\n\nconst SketchPage = () => (\n  <Layout>\n    <Sketch sketch={sketch} />\n  </Layout>\n);\n\nexport default SketchPage;\n"],"sourceRoot":""}