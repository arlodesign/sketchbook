{"version":3,"sources":["webpack:///./src/pages/sketch/2019/07/21.js","webpack:///./src/lib/polarToCartesian.js","webpack:///./node_modules/amp-is-object/is-object.js","webpack:///./node_modules/coordinate-systems/coordinate-systems.js","webpack:///./node_modules/amp-is-array/is-array.js","webpack:///./node_modules/amp-is-number/is-number.js","webpack:///./node_modules/amp-extend/extend.js"],"names":["RENDER","process","DEV","sketch","p","HUE","random","setup","pixelDensity","frameRate","createCanvas","colorMode","HSB","noFill","strokeWeight","createLoop","gif","render","open","noiseRadius","draw","blendMode","BLEND","background","OVERLAY","push","translate","width","height","a","HALF_PI","PI","stroke","map","_polarToCartesian","polarToCartesian","x","y","offset","sin","animLoop","theta","noise2D","bezier","cos","pop","__webpack_exports__","_ref","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_0__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_2__","path","pathname","description","__webpack_require__","d","polarToCartesianX","polarToCartesianY","polarToCartesianEllipse","center","angle","distance","Math","centerX","centerY","radiusX","radiusY","asArray","module","exports","obj","type","isArray","isNumber","isObject","extend","degPerRadian","Coordinate","config","isRadian","isDegree","_x","_y","_z","_r","_t","_p","pos","defineProperty","this","get","set","label","coords","Error","initialType","prototype","cartesian","cart","apply","arguments","options","temp","cartesian2d","cartesian3d","polarToCart2d","polar","cylindrical","sphericalToCart3d","spherical","cyl","cartesian2dToPolar","cartesian3dToCylindrical","sphericalToCylindrical","pol","sph","cartesian3dToSpherical","cylindricalToSpherical","baseCoord","arrToNumeric","length","nums","num","TypeError","i","parseFloat","rt","r","t","xy","sqrt","atan2","xyz","z","x2","y2","z2","rtz","sr","sp","rtp","cr","toString","nativeIsArray","Array","call","source","prop"],"mappings":"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","file":"component---src-pages-sketch-2019-07-21-js-c82b6ae7709a85d8dd5c.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport { polar } from \"coordinate-systems\";\nimport \"p5.createloop\";\n\nconst RENDER = process.env.DEV && false;\n\nconst sketch = function(p) {\n  const COUNT = 75;\n  const HUE = p.random();\n\n  p.setup = function() {\n    if (RENDER) {\n      p.pixelDensity(1);\n      p.frameRate(30);\n    }\n\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, 1);\n    p.noFill();\n    p.strokeWeight(2);\n\n    p.createLoop(10, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 1,\n    });\n  };\n\n  p.draw = function() {\n    p.blendMode(p.BLEND);\n    p.background(HUE, 0.5, 0.5);\n    p.blendMode(p.OVERLAY);\n\n    p.push();\n    p.translate(p.width / 2, p.height / 2);\n\n    for (let a = -p.HALF_PI + p.PI / COUNT; a < p.HALF_PI; a += p.PI / COUNT) {\n      p.stroke(\n        1 - HUE,\n        p.map(a, -p.HALF_PI, p.HALF_PI, 0.2, 0.8),\n        p.map(a, -p.HALF_PI, p.HALF_PI, 0, 1)\n      );\n\n      const { x, y } = polarToCartesian(0, 0, a, p.width / 3);\n      const offset = p.map(\n        p.sin(p.animLoop.theta),\n        -1,\n        1,\n        0,\n        p.animLoop.noise2D(a, y) * (p.width / 2)\n      );\n\n      p.bezier(\n        x,\n        y,\n        p.map(p.sin(p.animLoop.theta), -1, 1, x, offset),\n        p.map(p.sin(p.animLoop.theta), -1, 1, y, y - offset),\n        p.map(p.cos(p.animLoop.theta), -1, 1, -offset, -x),\n        p.map(p.cos(p.animLoop.theta), -1, 1, y + offset, y),\n        -x,\n        y\n      );\n    }\n\n    p.pop();\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","module.exports = function isObject(obj) {\n  var type = typeof obj;\n  return !!obj && (type === 'function' || type === 'object');\n};","\"use strict\";\n\nrequire(\"core-js/modules/es6.object.define-property\");\n\nvar isArray = require('amp-is-array');\n\nvar isNumber = require('amp-is-number');\n\nvar isObject = require('amp-is-object');\n\nvar extend = require('amp-extend');\n\nvar degPerRadian = 180 / Math.PI;\n/**\n * @constructor Coordinate\n * @description Defines object which can convert between coordinate systems.\n * It is recommended to use one of the Coodinate.STATIC_CONSTRUCTOR functions\n * to generate your first coordinate before conversions. e.g. Coodinate.spherical(...)\n * @param {Object} config\n * {\n *     label: 'type of initial coordinate',\n *     coords: {\n *         x/y/z/r/t/p: 'k-v pairs'\n *     },\n *     isDegree: Boolean\n * }\n */\n\nvar Coordinate = function Coordinate(config) {\n  var isRadian,\n      isDegree,\n      pos = {},\n      _x,\n      _y,\n      _z,\n      _r,\n      _t,\n      _p; // Override select setters/getts\n\n\n  Object.defineProperty(this, \"isRadian\", {\n    get: function get(x) {\n      return isRadian;\n    },\n    set: function set(x) {\n      isRadian = !!x;\n\n      if (isDegree !== !x) {\n        isDegree = !x;\n      } // jshint ignore:line\n\n    }\n  });\n  Object.defineProperty(this, \"isDegree\", {\n    get: function get(x) {\n      return isDegree;\n    },\n    set: function set(x) {\n      isDegree = x;\n\n      if (isRadian !== !x) {\n        isRadian = !x;\n      } // jshint ignore:line\n\n    }\n  });\n  Object.defineProperty(pos, \"cartesian2d\", {\n    get: function get(x) {\n      return [_x, _y];\n    },\n    set: function set(x) {\n      _x = x[0];\n      _y = x[1];\n    }\n  });\n  Object.defineProperty(pos, \"cartesian3d\", {\n    get: function get(x) {\n      return [_x, _y, _z];\n    },\n    set: function set(x) {\n      _x = x[0];\n      _y = x[1];\n      _z = x[2];\n    }\n  });\n  Object.defineProperty(pos, \"polar\", {\n    get: function get(x) {\n      return [_r, _t];\n    },\n    set: function set(x) {\n      _r = x[0];\n      _t = x[1];\n    }\n  });\n  Object.defineProperty(pos, \"cylindrical\", {\n    get: function get(x) {\n      return [_r, _t, _z];\n    },\n    set: function set(x) {\n      _r = x[0];\n      _t = x[1];\n      _z = x[2];\n    }\n  });\n  Object.defineProperty(pos, \"spherical\", {\n    get: function get(x) {\n      return [_r, _t, _p];\n    },\n    set: function set(x) {\n      _r = x[0];\n      _t = x[1];\n      _p = x[2];\n    }\n  }); // init from config\n\n  if (config.isDegree && !config.isRadian) {\n    this.isDegree = true;\n  } else {\n    this.isRadian = true;\n  }\n\n  if (!config.label || !config.coords) {\n    throw new Error(\"no coordinate type defined\");\n  }\n\n  this.initialType = config.label;\n  this.pos = pos;\n  this.pos[config.label] = config.coords;\n};\n/**\n * @method cartesian\n * Converts current coordinate to cartesian\n * @function cartesian\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cartesian = function () {\n  return this.cart.apply(this, arguments);\n};\n/**\n * @method cart\n * Converts current coordinate to cartesian\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cart = function (options) {\n  var temp;\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      return this.pos.cartesian2d;\n\n    case 'cartesian3d':\n      return this.pos.cartesian3d;\n\n    case 'polar':\n      this.pos.cartesian2d = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n      return this.pos.cartesian2d;\n\n    case 'cylindrical':\n      temp = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n      this.pos.cartesian3d = [temp[0], temp[1], this.pos.cylindrical[2]];\n      return this.pos.cartesian3d;\n\n    case 'spherical':\n      this.pos.cartesian3d = Coordinate.sphericalToCart3d(this.pos.spherical, this.isDegree);\n      return this.pos.cartesian3d;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n};\n/**\n * @method cylindrical\n * Converts current coordinate to cylindrical\n * @function cylindrical\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cylindrical = function () {\n  return this.cyl.apply(this, arguments);\n};\n/**\n * @method cyl\n * Converts current coordinate to cylindrical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cyl = function (options) {\n  var temp;\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n      this.pos.cylindrical = [temp[0], temp[1], 0];\n      return this.pos.cylindrical;\n\n    case 'cartesian3d':\n      this.pos.cylindrical = Coordinate.cartesian3dToCylindrical(this.pos.cartesian3d, this.isDegree, options.center);\n      return this.pos.cylindrical;\n\n    case 'polar':\n      temp = this.pos.polar;\n      return [temp[0], temp[1], 0];\n\n    case 'cylindrical':\n      return this.pos.cylindrical;\n\n    case 'spherical':\n      this.pos.cylindrical = Coordinate.sphericalToCylindrical(this.pos.spherical, this.isDegree);\n      return this.pos.cylindrical;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n};\n/**\n * @method pol\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.pol = function () {\n  return this.polar.apply(this, arguments);\n};\n/**\n * @method polar\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.polar = function (options) {\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      this.pos.polar = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n      return this.pos.polar;\n\n    case 'polar':\n      return this.pos.polar;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n};\n/**\n * @method spherical\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.spherical = function () {\n  return this.sph.apply(this, arguments);\n};\n/**\n * @method sph\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.sph = function (options) {\n  var temp;\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n      this.pos.spherical = [temp[0], temp[1], 0];\n      return this.pos.spherical;\n\n    case 'cartesian3d':\n      this.pos.spherical = Coordinate.cartesian3dToSpherical(this.pos.cartesian3d, this.isDegree, options.center);\n      return this.pos.spherical;\n\n    case 'polar':\n      temp = this.pos.polar;\n      return [temp[0], temp[1], 0];\n\n    case 'cylindrical':\n      this.pos.spherical = Coordinate.cylindricalToSpherical(this.pos.cylindrical, this.isDegree);\n      return this.pos.spherical;\n\n    case 'spherical':\n      return this.pos.spherical;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n}; ///\n/// Static Constructor Functions\n///\n\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cartesian = function (x) {\n  return Coordinate.cart(x);\n};\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cart = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length < 2 || options.coords.length > 3) {\n      throw new Error('expected exactly 2 or exactly 3 cartesian options');\n    }\n\n    baseCoord = {\n      label: 'cartesian2d',\n      options: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n\n    if (options.coords.length === 2) {\n      return new Coordinate(baseCoord);\n    }\n\n    baseCoord.label = 'cartesian3d';\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected options w/ array of [x,y,(z?)] coords');\n};\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cylindrical = function (x) {\n  return Coordinate.cyl(x);\n};\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cyl = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length !== 3) {\n      throw new Error('expected exactly 3 params [r, t, z]');\n    }\n\n    baseCoord = {\n      label: 'cylindrical',\n      coords: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected options w/ array of [r, t, z] coords');\n};\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.polar = function (x) {\n  return Coordinate.pol(x);\n};\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.pol = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length !== 2) {\n      throw new Error('expected exactly 2 params [r, t]');\n    }\n\n    baseCoord = {\n      label: 'polar',\n      coords: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected array of [r, t] options');\n};\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.spherical = function (options) {\n  return Coordinate.sph(options);\n};\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.sph = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length !== 3) {\n      throw new Error('expected exactly 3 params [r, t, p]');\n    }\n\n    baseCoord = {\n      label: 'spherical',\n      coords: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected options w/ array of [r, t, p] coords');\n};\n/**\n * Mutates an array of number-like looking values to purely numeric array\n * @example\n * [5, '2.4', '0'] => [5, 2.4, 0]\n * @param  {Array} nums\n * @return {undefined}\n */\n\n\nCoordinate.arrToNumeric = function (nums) {\n  var num;\n\n  if (!isArray(nums)) {\n    throw new TypeError(\"expected array of number-like values\");\n  }\n\n  for (var i = nums.length - 1; i >= 0; i--) {\n    num = nums[i];\n\n    if (typeof num === 'string') {\n      num = parseFloat(num);\n    }\n\n    if (!isNumber(num)) {\n      throw new TypeError(num + ' not numeric or numeric-like');\n    }\n  }\n};\n/**\n * Convert polar to 2d cartesian coordinates\n * @param  {Array}   rt        [radis, theta]\n * @param  {Boolean} isDegree specifies units\n * @return {Array}  [x, y]\n */\n\n\nCoordinate.polarToCart2d = function (rt, isDegree) {\n  var r, t, x, y;\n  r = rt[0];\n  t = rt[1];\n\n  if (isDegree) {\n    t = t * (1 / degPerRadian);\n  }\n\n  x = r * Math.cos(t);\n  y = r * Math.sin(t);\n  return [x, y];\n};\n/**\n * Convert cartesian 2d to polar coordinates\n * @param  {Array}  xy\n * @param {Boolean=} isDegree overrides default radian theta assumption\n * @param  {Array=} center [x, y] coords of center of circle.  Defaults to [0, 0],\n * however may be offset.  Note. Such functionality not supported yet for converting\n * polar to cartesian\n * @return {Array}  [radius, theta]\n */\n\n\nCoordinate.cartesian2dToPolar = function (xy, isDegree, center) {\n  var x, y, r, t;\n\n  if (!isArray(xy) && xy.length !== 2) {\n    throw new TypeError('expected [x, y] xy array');\n  }\n\n  x = xy[0];\n  y = xy[1];\n\n  if (center && !isArray(center) && center.length !== 2) {\n    throw new TypeError('expected [x, y] center array');\n  }\n\n  if (center) {\n    x = x - center[0];\n    y = y - center[1];\n  }\n\n  r = Math.sqrt(x * x + y * y);\n  t = Math.atan2(y, x);\n\n  if (isDegree) {\n    t = t * degPerRadian;\n  }\n\n  return [r, t];\n};\n/**\n * Convert 3d cartesian to 3d cylindrical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y] coords of center of circle\n * @return {Array}      [radius, theta, z]\n */\n\n\nCoordinate.cartesian3dToCylindrical = function (xyz, isDegree, center) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      rt;\n  rt = Coordinate.cartesian2dToPolar([x, y], isDegree, center);\n  return [rt[0], rt[1], z];\n};\n/**\n * Convert 3d cartesian to 3d spherical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y, z] coords of center of circle\n * @return {Array}      [radius, theta, phi]\n */\n\n\nCoordinate.cartesian3dToSpherical = function (xyz, isDegree, center) {\n  if (center && center.length !== 3) {\n    throw new Error('expected center value to have [x, y, z] coords' + 'for locating sphere center');\n  }\n\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      x2,\n      y2,\n      z2,\n      r,\n      t,\n      p;\n\n  if (center) {\n    x = x - center[0];\n    y = y - center[1];\n    z = z - center[2];\n  }\n\n  x2 = x * x;\n  y2 = y * y;\n  z2 = z * z;\n  r = Math.sqrt(x2 + y2 + z2);\n\n  if (!r) {\n    p = t = 0;\n  } else {\n    t = Math.atan2(y, x);\n    p = Math.atan2(Math.sqrt(x2 + y2), z);\n\n    if (isDegree) {\n      t = t * degPerRadian;\n      p = p * degPerRadian;\n    }\n  }\n\n  return [r, t, p];\n};\n/**\n * Convert a cylindrical to a spherical coordinates\n * @param  {Array}   rtz\n * @param  {Boolean} isDegree\n * @return {Array}   [radius, theta, phi]\n */\n\n\nCoordinate.cylindricalToSpherical = function (rtz, isDegree) {\n  var r = rtz[0],\n      t = rtz[1],\n      z = rtz[2];\n  var sr, sp; // sphere radius, sphere theta...\n\n  if (isDegree) {\n    t = t / degPerRadian;\n  }\n\n  sr = Math.sqrt(r * r + z * z);\n  sp = Math.atan2(r, z);\n\n  if (isDegree) {\n    sp = sp * degPerRadian;\n    t = t * degPerRadian;\n  }\n\n  return [sr, t, sp];\n};\n/**\n * Convert spherical to a cartesian coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\n\n\nCoordinate.sphericalToCart3d = function (rtp, isDegree) {\n  var r = rtp[0],\n      t = rtp[1],\n      p = rtp[2],\n      x,\n      y,\n      z;\n\n  if (isDegree) {\n    t = t / degPerRadian;\n    p = p / degPerRadian;\n  }\n\n  x = r * Math.sin(p) * Math.cos(t);\n  y = r * Math.sin(p) * Math.sin(t);\n  z = r * Math.cos(p);\n  return [x, y, z];\n};\n/**\n * Convert spherical to cylindrical coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\n\n\nCoordinate.sphericalToCylindrical = function (rtp, isDegree) {\n  var r = rtp[0],\n      t = rtp[1],\n      p = rtp[2],\n      cr,\n      z;\n\n  if (isDegree) {\n    t = t / degPerRadian;\n    p = p / degPerRadian;\n  }\n\n  cr = r * Math.sin(p);\n  z = r * Math.cos(p);\n\n  if (isDegree) {\n    t = t * degPerRadian;\n    p = p * degPerRadian;\n  }\n\n  return [cr, t, z];\n};\n\nmodule.exports = Coordinate;","require(\"core-js/modules/es6.array.is-array\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nvar toString = Object.prototype.toString;\nvar nativeIsArray = Array.isArray;\n\nmodule.exports = nativeIsArray || function isArray(obj) {\n  return toString.call(obj) === '[object Array]';\n};","require(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nvar toString = Object.prototype.toString;\n\nmodule.exports = function isNumber(obj) {\n  return toString.call(obj) === '[object Number]';\n};","var isObject = require('amp-is-object');\n\nmodule.exports = function (obj) {\n  if (!isObject(obj)) return obj;\n  var source, prop;\n\n  for (var i = 1, length = arguments.length; i < length; i++) {\n    source = arguments[i];\n\n    for (prop in source) {\n      obj[prop] = source[prop];\n    }\n  }\n\n  return obj;\n};"],"sourceRoot":""}