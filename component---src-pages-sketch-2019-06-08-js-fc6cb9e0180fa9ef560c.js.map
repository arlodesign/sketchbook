{"version":3,"sources":["webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2019/06/08.js"],"names":["polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y","polarToCartesian","sketch","p","HUE","random","vertices","Vertex","this","TWO_PI","height","speed","get","width","update","setup","createCanvas","noStroke","colorMode","HSL","background","Array","from","draw","vs","filter","clr","color","map","frameCount","length","noFill","stroke","line","fill","beginShape","sort","a","b","forEach","v","vertex","endShape","CLOSE","noLoop","location","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2019-06-08-js-fc6cb9e0180fa9ef560c.js","sourcesContent":["const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  const HUE = p.random(80);\n  const V_QTY = 10;\n\n  let vertices = [];\n\n  class Vertex {\n    constructor() {\n      this.angle = p.random(p.TWO_PI);\n      this.distance = p.random(p.height * (2 / 3));\n      this.speed = p.random([-1, 1]) * p.random(0.0001, 0.001);\n    }\n    get() {\n      return polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        this.angle,\n        this.distance,\n        true\n      );\n    }\n    update() {\n      this.angle += this.speed;\n      if (this.angle < 0) {\n        this.angle = p.TWO_PI + this.angle;\n      }\n      if (this.angle > p.TWO_PI) {\n        this.angle = this.angle - p.TWO_PI;\n      }\n      this.distance = this.distance > 0 ? this.distance - 0.03 : 0;\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.noStroke();\n    p.colorMode(p.HSL, 100);\n    p.background(HUE, 100, 0);\n\n    vertices = Array.from(Array(V_QTY), () => new Vertex());\n  };\n\n  p.draw = function() {\n    const vs = vertices.filter(({ distance }) => distance > 0);\n    const clr = p.color(\n      p.map(p.cos(p.frameCount / 1000), -1, 1, HUE, HUE + 20),\n      p.map(p.sin(p.frameCount / 50), -1, 1, 80, 100),\n      p.map(p.cos(p.frameCount / 500), -1, 1, 0, 100),\n      80\n    );\n\n    if (vs.length === 1) {\n      p.noLoop();\n      return;\n    }\n\n    if (vs.length === 2) {\n      p.noFill();\n      p.stroke(clr);\n      p.line(...vs[0].get(), ...vs[1].get());\n      vs[0].update();\n      vs[1].update();\n    } else {\n      p.noStroke();\n      p.fill(clr);\n      p.beginShape();\n      vs.sort((a, b) => a.angle - b.angle).forEach(v => {\n        p.vertex(...v.get());\n        v.update();\n      });\n      p.endShape(p.CLOSE);\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}