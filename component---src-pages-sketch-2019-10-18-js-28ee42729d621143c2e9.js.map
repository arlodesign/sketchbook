{"version":3,"sources":["webpack:///./node_modules/bezier-easing/src/index.js","webpack:///./src/pages/sketch/2019/10/18.js"],"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","LinearEasing","x","module","exports","mX1","mY1","mX2","mY2","Error","sampleValues","Array","i","getTForX","aX","intervalStart","currentSample","lastSample","guessForT","initialSlope","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","Math","abs","binarySubdivide","ease","bezierEasing","RENDER","process","DEV","sketch","p","HUE","random","R","HALF_PI","squiggles","lines","prevMod","Shape","y","this","rotate","QUARTER_PI","PI","scale","rotateDirection","turning","offset","noise","TWO_PI","Squiggle","draw","turn","theta","animLoop","turnVal","map","push","translate","GRID","strokeWeight","bezier","pop","Lines","line","setup","pixelDensity","createCanvas","colorMode","HSB","createLoop","gif","render","open","width","height","background","stroke","forEach","b","SketchPage"],"mappings":"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","file":"component---src-pages-sketch-2019-10-18-js-28ee42729d621143c2e9.js","sourcesContent":["require(\"core-js/modules/es6.typed.float32-array\");\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nfunction LinearEasing(x) {\n  return x;\n}\n\nmodule.exports = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};","import React from \"react\";\nimport Layout from \"~components/layout\";\nimport Sketch from \"~components/sketch\";\nimport \"p5.createloop\";\nimport bezierEasing from \"bezier-easing\";\n\nconst ease = bezierEasing(0, 1, 1, 0);\n\nconst RENDER = process.env.DEV && true;\nconst DURATION = 15;\nconst GRID = 45;\n\nconst sketch = function(p) {\n  const HUE = p.random();\n  const R = p.HALF_PI;\n\n  let squiggles = [];\n  let lines = [];\n  let prevMod = 0;\n\n  class Shape {\n    constructor(x, y) {\n      this.x = x;\n      this.y = y;\n      this.rotate = p.random([\n        p.QUARTER_PI,\n        p.HALF_PI + p.QUARTER_PI,\n        p.PI + p.QUARTER_PI,\n        p.HALF_PI + p.PI + p.QUARTER_PI,\n      ]);\n      this.scale = p.random([1, -1]);\n      this.rotateDirection = p.random([-1, 1]);\n      this.turning = false;\n      this.offset = p.noise(x, y) * p.TWO_PI;\n    }\n  }\n\n  class Squiggle extends Shape {\n    constructor(x, y) {\n      super(x, y);\n    }\n\n    draw(turn) {\n      const { theta } = p.animLoop;\n\n      if (turn) {\n        this.rotate += R * this.rotateDirection;\n      }\n\n      const turnVal = p.map(theta % R, 0, R, 0, 1);\n\n      p.push();\n      p.translate(this.x + GRID / 2, this.y + GRID / 2);\n      p.rotate(\n        p.map(\n          ease(turnVal),\n          0,\n          1,\n          this.rotate,\n          this.rotate + R * this.rotateDirection\n        )\n      );\n      p.scale(this.scale, 1);\n      p.strokeWeight(GRID / 2);\n\n      p.bezier(\n        -GRID / 2,\n        -GRID / 2,\n        GRID / 2,\n        -GRID / 2,\n        -GRID / 2,\n        GRID / 2,\n        GRID / 2,\n        GRID / 2\n      );\n      p.pop();\n    }\n  }\n\n  class Lines extends Shape {\n    constructor(x, y) {\n      super(x, y);\n    }\n\n    draw(turn) {\n      const { theta } = p.animLoop;\n\n      if (turn) {\n        this.rotate += R * this.rotateDirection;\n      }\n\n      const turnVal = p.map(theta % R, 0, R, 0, 1);\n\n      p.push();\n      p.translate(this.x + GRID / 2, this.y + GRID / 2);\n      p.rotate(\n        p.map(\n          ease(turnVal),\n          0,\n          1,\n          this.rotate,\n          this.rotate + R * this.rotateDirection\n        )\n      );\n      p.strokeWeight(1 + GRID / 3);\n\n      p.line(-GRID / 2, -GRID / 2, GRID / 2, GRID / 2);\n      p.pop();\n    }\n  }\n\n  p.setup = function() {\n    p.pixelDensity(RENDER ? 1 : 2);\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, 1);\n\n    p.createLoop(DURATION, {\n      gif: RENDER ? { render: false, open: true } : false,\n    });\n\n    for (let x = 0; x < p.width; x += GRID) {\n      for (let y = 0; y < p.height; y += GRID) {\n        squiggles.push(new Squiggle(x, y));\n        lines.push(new Lines(x, y));\n      }\n    }\n  };\n\n  p.draw = function() {\n    p.background(1 - HUE, 1, 1);\n\n    p.stroke(HUE, 0.8, 0.7);\n    squiggles.forEach(b => b.draw(p.animLoop.theta % R <= prevMod));\n\n    p.stroke(1 - HUE, 1, 1);\n    lines.forEach(b => b.draw(p.animLoop.theta % R <= prevMod));\n\n    prevMod = p.animLoop.theta % R;\n  };\n};\n\nconst SketchPage = () => (\n  <Layout>\n    <Sketch sketch={sketch} />\n  </Layout>\n);\n\nexport default SketchPage;\n"],"sourceRoot":""}