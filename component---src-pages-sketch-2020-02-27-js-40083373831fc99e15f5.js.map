{"version":3,"sources":["webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2020/02/27.js"],"names":["polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y","polarToCartesian","sketch","p","RENDER","getURLParams","render","COLORS","ellipses","Ellipse","this","draw","animLoop","theta","noise2D","width","height","map","circle","setup","pixelDensity","frameRate","createCanvas","createLoop","gif","open","noiseRadius","noFill","noSmooth","Array","length","fill","_","i","j","TWO_PI","noise","background","push","blendMode","SCREEN","forEach","set","stroke","e","pop","location","path","pathname","description"],"mappings":"6FAAA,0GAAMA,EAAoB,SAACC,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKC,IAAIH,GAASC,GAE9BG,EAAoB,SAACL,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKG,IAAIL,GAASC,GAsB9BK,EAA0B,SAC9BC,EACAC,EACAR,EACAS,EACAC,EACAC,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIL,EAAUL,KAAKC,IAAIH,GAASS,EAChCI,EAAIL,EAAUN,KAAKG,IAAIL,GAASU,EACtC,OAAOC,EAAU,CAACC,EAAGC,GAAK,CAAED,IAAGC,MAIlBC,IAzBU,SACvBP,EACAC,EACAR,EACAC,EACAU,QACG,IADHA,OAAU,GAEV,IAAMC,EAAId,EAAkBS,EAASP,EAAOC,GACtCY,EAAIT,EAAkBI,EAASR,EAAOC,GAC5C,OAAOU,EAAU,CAACC,EAAGC,GAAK,CAAED,IAAGC,O,iHCnB3BE,EAAS,SAASC,GACtB,IAAMC,EAASD,EAAEE,eAAeC,OAI1BC,EAAS,CAAC,MAAO,QAAS,QAI5BC,EAAW,GAETC,EAXmB,WAYvB,WAAYtB,EAAOC,GACjBsB,KAAKvB,MAAQA,EACbuB,KAAKtB,SAAWA,EAdK,mBAiBvBuB,KAAA,WAAQ,IAAD,EACsBR,EAAES,SAArBC,EADH,EACGA,MAAOC,EADV,EACUA,QADV,EAEYb,YACfE,EAAEY,MAAQ,EACVZ,EAAEa,OAAS,EACXN,KAAKvB,MAAQ0B,EACbH,KAAKtB,SACHe,EAAEc,IACAH,EAAQJ,KAAKtB,SAnBH,IAmB2Be,EAAEX,IAAIkB,KAAKvB,SAC/C,EACD,EACA,IACA,IAVEY,EAFH,EAEGA,EAAGC,EAFN,EAEMA,EAaXG,EAAEe,OACAnB,EACAC,EACU,IAAVG,EAAEY,MAAeD,EAAQf,EA7BX,IA6B4BC,EA7B5B,OANK,KAwCzBG,EAAEgB,MAAQ,WACRhB,EAAEiB,aAAa,GACfjB,EAAEkB,UAvCS,IAwCXlB,EAAEmB,aAAa,IAAK,KACpBnB,EAAEoB,WA1Ca,GA0CQ,CACrBC,MAAKpB,GAAS,CAAEE,QAAQ,EAAOmB,MAAM,GACrCC,YAAa,IAEfvB,EAAEwB,SACFxB,EAAEyB,WAEFpB,EAAWqB,MAAMtB,EAAOuB,QACrBC,OACAd,KAAI,SAACe,EAAGC,GAAJ,OACHJ,MAlDQ,KAmDLE,OACAd,KAAI,SAACe,EAAGE,GACP,OAAO,IAAIzB,EACRN,EAAEgC,OAtDD,IAsDmBD,EACrB/B,EAAEc,IACAd,EAAEiC,MAAMjC,EAAEX,IAAKW,EAAEgC,OAxDjB,KAwDoCD,EAAI,IAAMD,EAAI,KAClD,EACA,EACA9B,EAAEY,MAAQ,EACVZ,EAAEY,MAAQ,WAOxBZ,EAAEQ,KAAO,WACPR,EAAEkC,WAAW,GAEblC,EAAEmC,OACFnC,EAAEoC,UAAUpC,EAAEqC,QACdhC,EAASiC,SAAQ,SAACC,EAAKT,GACrB9B,EAAEwC,OAAOpC,EAAO0B,IAChBS,EAAID,SAAQ,SAAAG,GAAC,OAAIA,EAAEjC,aAErBR,EAAE0C,QAIS,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAc5C,OAAQA,EAAQ6C,KAAMD,EAASE,SAAUC,YAAY","file":"component---src-pages-sketch-2020-02-27-js-40083373831fc99e15f5.js","sourcesContent":["const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport \"p5.createloop\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  const RENDER = p.getURLParams().render;\n  const DURATION = 40;\n  const RATE = 30;\n  const COUNT = 1000;\n  const COLORS = [\"red\", \"green\", \"blue\"];\n  const NOISE_SCALE = 500;\n  const SIDES = 6;\n\n  let ellipses = [];\n\n  class Ellipse {\n    constructor(angle, distance) {\n      this.angle = angle;\n      this.distance = distance;\n    }\n\n    draw() {\n      const { theta, noise2D } = p.animLoop;\n      const { x, y } = polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        this.angle + theta,\n        this.distance *\n          p.map(\n            noise2D(this.distance / NOISE_SCALE, p.sin(this.angle)),\n            -1,\n            1,\n            0.25,\n            1\n          )\n      );\n      p.circle(\n        x,\n        y,\n        p.width * 0.75 * noise2D(x / NOISE_SCALE, y / NOISE_SCALE)\n      );\n    }\n  }\n\n  p.setup = function() {\n    p.pixelDensity(1);\n    p.frameRate(RATE);\n    p.createCanvas(660, 840);\n    p.createLoop(DURATION, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 2,\n    });\n    p.noFill();\n    p.noSmooth();\n\n    ellipses = Array(COLORS.length)\n      .fill()\n      .map((_, i) =>\n        Array(COUNT)\n          .fill()\n          .map((_, j) => {\n            return new Ellipse(\n              (p.TWO_PI / COUNT) * j,\n              p.map(\n                p.noise(p.sin((p.TWO_PI / COUNT) * (j + 1) * (i + 1))),\n                0,\n                1,\n                p.width / 4,\n                p.width / 2\n              )\n            );\n          })\n      );\n  };\n\n  p.draw = function() {\n    p.background(0);\n\n    p.push();\n    p.blendMode(p.SCREEN);\n    ellipses.forEach((set, i) => {\n      p.stroke(COLORS[i]);\n      set.forEach(e => e.draw());\n    });\n    p.pop();\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}