{"version":3,"sources":["webpack:///./src/pages/sketch/2019/02/17.js","webpack:///./node_modules/core-js/modules/es6.array.fill.js","webpack:///./node_modules/core-js/modules/_array-fill.js","webpack:///./src/lib/addNoise.js"],"names":["sketch","p","points","getVectors","position","createVector","randomGaussian","width","height","velocity","random","acceleration","setup","createCanvas","Array","fill","map","_","background","draw","forEach","_ref","i","add","x","y","points2","reached","_loop","shortest","dist","reachedIndex","unreachedIndex","point","point2","i2","THIS_DIST","stroke","cos","frameCount","line","filter","length","addNoise","noLoop","__webpack_exports__","_ref2","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_1__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_3__","path","pathname","$export","__webpack_require__","P","toObject","toAbsoluteIndex","toLength","module","exports","value","O","this","aLen","arguments","index","undefined","end","endPos","intensity","PTS","console","log","push","noStroke","ellipse","pixelDensity","pop"],"mappings":"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","file":"component---src-pages-sketch-2019-02-17-js-07def40e602185d9b9c1.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport addNoise from \"~lib/addNoise\";\n\nconst sketch = function(p) {\n  let points = [];\n\n  function getVectors() {\n    return {\n      position: p.createVector(\n        p.randomGaussian(p.width / 2, p.width / 15),\n        p.randomGaussian(p.height / 2, p.height / 15)\n      ),\n      velocity: p.createVector(p.random(-0.1, 0.1), p.random(-0.1, 0.1)),\n      acceleration: p.createVector(p.random(-0.1, 0.1), p.random(-0.1, 0.1)),\n    };\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    points = new Array(50).fill().map(_ => getVectors());\n    p.background(0);\n  };\n\n  p.draw = function() {\n    points.forEach(({ position, velocity, acceleration }, i) => {\n      points[i].position = position.add(velocity.add(acceleration));\n      if (\n        position.x < 0 ||\n        position.x > p.width ||\n        position.y < 0 ||\n        position.y > p.height\n      ) {\n        points[i] = getVectors();\n      }\n    });\n    let points2 = points.map(p => ({\n      position: p.position,\n      reached: false,\n    }));\n    points2[0].reached = true;\n    while (points2.filter(point => point.reached).length < points2.length) {\n      const MAX = p.dist(0, 0, p.width, p.height) * 2;\n      let shortest = MAX;\n      let reachedIndex;\n      let unreachedIndex;\n      points2.forEach((point, i) => {\n        if (!point.reached) return;\n        points2.forEach((point2, i2) => {\n          if (point2.reached) return;\n          const THIS_DIST = p.dist(\n            point.position.x,\n            point.position.y,\n            point2.position.x,\n            point2.position.y\n          );\n          if (THIS_DIST < shortest) {\n            shortest = THIS_DIST;\n            reachedIndex = i;\n            unreachedIndex = i2;\n          }\n        });\n      });\n      p.stroke(\n        255 * p.cos(p.frameCount / 100),\n        p.map(\n          p.dist(\n            p.width / 2,\n            p.height / 2,\n            points2[unreachedIndex].position.x,\n            points2[unreachedIndex].position.y\n          ),\n          0,\n          p.dist(0, 0, p.width / 2, p.height / 2),\n          64,\n          0\n        )\n      );\n      p.line(\n        points2[reachedIndex].position.x,\n        points2[reachedIndex].position.y,\n        points2[unreachedIndex].position.x,\n        points2[unreachedIndex].position.y\n      );\n      points2[unreachedIndex].reached = true;\n    }\n    addNoise(p, 0.02);\n    if (p.frameCount > 800) {\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} />\n);\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', { fill: require('./_array-fill') });\n\nrequire('./_add-to-unscopables')('fill');\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = require('./_to-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var aLen = arguments.length;\n  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);\n  var end = aLen > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n","const addNoise = (p, intensity = 0.5) => {\n  const PTS = p.width * p.height * 0.02;\n\n  console.log(PTS);\n\n  p.push();\n  for (let i = 0; i < PTS; i++) {\n    p.fill(\n      i % 2\n        ? `rgba(0, 0, 0, ${intensity})`\n        : `rgba(255, 255, 255, ${intensity})`\n    );\n    p.noStroke();\n    p.ellipse(\n      p.randomGaussian(p.width / 2, p.width / 3),\n      p.randomGaussian(p.height / 2, p.height / 3),\n      1 / (p.pixelDensity() / 2)\n    );\n  }\n  p.pop();\n};\n\nexport default addNoise;\n"],"sourceRoot":""}