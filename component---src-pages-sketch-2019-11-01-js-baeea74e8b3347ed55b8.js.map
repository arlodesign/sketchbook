{"version":3,"sources":["webpack:///./src/pages/sketch/2019/11/01.js","webpack:///./src/lib/polarToCartesian.js","webpack:///./src/lib/lerpLine.js"],"names":["RENDER","process","DEV","sketch","p","vRadius","hRadius","H1","random","H2","H3","setup","pixelDensity","createCanvas","background","createLoop","gif","render","open","noiseRadius","blendMode","MULTIPLY","colorMode","HSL","height","width","draw","animLoop","theta","noise1D","noise2D","translate","polarToCartesian","color","forEach","c","i","stroke","line","polarToCartesianEllipse","TWO_PI","map","lerpLine","sin","location","path","pathname","description","polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","centerX","centerY","radiusX","radiusY","asArray","x","y","x1","y1","x2","y2","rate","showFirstDot","noisy","thisRate","max","dist","l","point","lerp"],"mappings":"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","file":"component---src-pages-sketch-2019-11-01-js-baeea74e8b3347ed55b8.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian, {\n  polarToCartesianEllipse,\n} from \"~lib/polarToCartesian\";\nimport \"p5.createloop\";\nimport lerpLine from \"~lib/lerpLine\";\n\nconst RENDER = process.env.DEV && false;\n\nconst sketch = function(p) {\n  const H1 = p.random(120);\n  const H2 = p.random(120, 240);\n  const H3 = p.random(240, 360);\n  let vRadius;\n  let hRadius;\n\n  p.setup = function() {\n    p.pixelDensity(RENDER ? 1 : 2);\n    p.createCanvas(660, 840);\n    p.background(255);\n\n    p.createLoop(120, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 1,\n    });\n\n    p.blendMode(p.MULTIPLY);\n    p.colorMode(p.HSL, 360);\n\n    vRadius = p.height / 2 - p.width * 0.1;\n    hRadius = p.width / 2 - p.width * 0.1;\n  };\n\n  p.draw = function() {\n    const { theta, noise1D, noise2D } = p.animLoop;\n\n    p.translate(\n      ...polarToCartesian(p.width / 2, p.height / 2, theta, p.width * 0.1, true)\n    );\n\n    [\n      p.color(H1, 360, 180, 180),\n      p.color(H2, 360, 180, 180),\n      p.color(H3, 360, 180, 180),\n    ].forEach((c, i) => {\n      p.stroke(c);\n\n      p.line(\n        ...polarToCartesianEllipse(\n          0,\n          0,\n          theta + (p.TWO_PI / 3) * i,\n          p.map(noise1D(i / 1000 + 0.005), -1, 1, 0.1, 1) * hRadius,\n          p.map(noise1D(1 / 1000 + 0.004), -1, 1, 0.1, 1) * vRadius,\n          true\n        ),\n        ...polarToCartesian(\n          0,\n          0,\n          theta + (p.TWO_PI / 3) * i,\n          p.map(noise1D(1 / 1000 + 0.003), -1, 1, 0.1, 2) * hRadius,\n          true\n        )\n      );\n\n      lerpLine(\n        p,\n        ...polarToCartesianEllipse(\n          0,\n          0,\n          theta + (p.TWO_PI / 3) * (i + 1.5),\n          p.map(noise1D(i / 1000 + 0.005), -1, 1, 0.1, 1) * hRadius,\n          p.map(noise1D(1 / 1000 + 0.004), -1, 1, 0.1, 1) * vRadius,\n          true\n        ),\n        ...polarToCartesian(\n          0,\n          0,\n          theta + (p.TWO_PI / 3) * (i + 1.5),\n          p.map(noise1D(1 / 1000 + 0.003), -1, 1, 0.1, 2) * hRadius,\n          true\n        ),\n        p.map(noise2D(1 / 1000 + 0.002, p.sin(theta)), -1, 1, 0.1, 0.5)\n      );\n    });\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","/**\n * Creates a line of points at a specified interval (the rate)\n *\n * @param {obj} p The current p5.js drawing context\n * @param {*} x1\n * @param {*} y1\n * @param {*} x2\n * @param {*} y2\n * @param {*} rate Number between 0 and 1 to determine how often to draw a point\n * @param {*} showFirstDot Defaults to true\n * @param {*} noisy Defaults to true\n */\nexport default function(\n  p,\n  x1,\n  y1,\n  x2,\n  y2,\n  rate,\n  showFirstDot = true,\n  noisy = true\n) {\n  const thisRate = Math.max(rate, 0.01 / p.dist(x1, y1, x2, y2));\n\n  for (let l = 0; l < 1; l += thisRate) {\n    if (l === 0 && !showFirstDot) continue;\n    if ((noisy && p.random() > l) || !noisy) {\n      p.point(p.lerp(x1, x2, l), p.lerp(y1, y2, l));\n    }\n  }\n}\n"],"sourceRoot":""}