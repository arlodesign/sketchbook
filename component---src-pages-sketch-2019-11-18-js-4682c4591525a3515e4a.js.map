{"version":3,"sources":["webpack:///./src/pages/sketch/2019/11/18.js","webpack:///./src/lib/polarToCartesian.js"],"names":["sketch","w","h","p","RENDER","getURLParams","render","setup","pixelDensity","frameRate","min","windowWidth","floor","windowHeight","createCanvas","stroke","fill","strokeWeight","createLoop","gif","open","noiseRadius","draw","animLoop","theta","noise1D","blendMode","BLEND","background","DIFFERENCE","translate","width","height","rotate","a","TWO_PI","push","polarToCartesian","sin","beginShape","vertex","cos","endShape","CLOSE","pop","location","path","pathname","description","polarToCartesianX","center","angle","distance","Math","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y"],"mappings":"+gCAKA,IAAMA,EAAS,SAACC,EAAGC,GAAJ,OACb,SAASC,GACP,IAAMC,EAASD,EAAEE,eAAeC,OAEhCH,EAAEI,MAAQ,WACRJ,EAAEK,aAAa,GACfL,EAAEM,UAAU,IAEZR,EAAIA,GAAKE,EAAEO,IAAIP,EAAEQ,YAAa,MAC9BT,EAAIA,GAAKC,EAAES,MAAMX,GAAKE,EAAEU,aAAeV,EAAEQ,cAEzCR,EAAEW,aAAab,EAAGC,GAClBC,EAAEY,OAAO,KACTZ,EAAEa,KAAK,KACPb,EAAEc,aAAa,GAEfd,EAAEe,WAAW,GAAI,CACfC,MAAKf,GAAS,CAAEE,QAAQ,EAAOc,MAAM,GACrCC,YAAa,MAIjBlB,EAAEmB,KAAO,WAAY,IAAD,EACSnB,EAAEoB,SAArBC,EADU,EACVA,MAAOC,EADG,EACHA,QACftB,EAAEuB,UAAUvB,EAAEwB,OACdxB,EAAEyB,WAAW,GACbzB,EAAEuB,UAAUvB,EAAE0B,YACd1B,EAAE2B,UAAU3B,EAAE4B,MAAQ,EAAG5B,EAAE6B,OAAS,GACpC7B,EAAE8B,OAAO9B,EAAEoB,SAASC,OAEpB,IAAK,IAAIU,EAAI,EAAGA,EAAI/B,EAAEgC,OAAQD,GAAK/B,EAAEgC,OAAS,EAC5ChC,EAAEiC,OACFjC,EAAE8B,OAAOC,EAAIV,GACbrB,EAAE2B,UAAF,MAAA3B,EAAC,EACIkC,YACD,EACA,EACAlC,EAAEgC,OAAS,GACD,KAAVhC,EAAE4B,MAAgB5B,EAAEmC,IAAId,IACxB,KAGJrB,EAAE8B,OAAgB,GAART,GAEVrB,EAAEoC,aACFpC,EAAEqC,OAAF,MAAArC,EAAC,EACIkC,YACD,EACA,EACAlC,EAAEgC,OAASV,EAAQ,KACT,KAAVtB,EAAE4B,MAAgB5B,EAAEmC,IAAId,IACxB,KAGJrB,EAAEqC,OAAF,MAAArC,EAAC,EACIkC,YACD,EACA,EACW,KAAXlC,EAAEgC,OAAiBV,EAAQ,KACjB,KAAVtB,EAAE4B,MAAgB5B,EAAEsC,IAAIjB,IACxB,KAGJrB,EAAEqC,OAAF,MAAArC,EAAC,EACIkC,YACD,EACA,EACW,KAAXlC,EAAEgC,OAAiBV,EAAQ,KACjB,KAAVtB,EAAE4B,MAAgB5B,EAAEmC,IAAId,IACxB,KAGJrB,EAAEuC,SAASvC,EAAEwC,OACbxC,EAAEyC,SAKK,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CACE7C,OAAQA,EAAO,IAAK,KACpB8C,KAAMD,EAASE,SACfC,YAAY,O,kCCvFhB,0GAAMC,EAAoB,SAACC,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKZ,IAAIU,GAASC,GAE9BE,EAAoB,SAACJ,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKf,IAAIa,GAASC,GAsB9BG,EAA0B,SAC9BC,EACAC,EACAN,EACAO,EACAC,EACAC,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIL,EAAUH,KAAKZ,IAAIU,GAASO,EAChCI,EAAIL,EAAUJ,KAAKf,IAAIa,GAASQ,EACtC,OAAOC,EAAU,CAACC,EAAGC,GAAK,CAAED,IAAGC,MAIlBzB,IAzBU,SACvBmB,EACAC,EACAN,EACAC,EACAQ,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIZ,EAAkBO,EAASL,EAAOC,GACtCU,EAAIR,EAAkBG,EAASN,EAAOC,GAC5C,OAAOQ,EAAU,CAACC,EAAGC,GAAK,CAAED,IAAGC","file":"component---src-pages-sketch-2019-11-18-js-4682c4591525a3515e4a.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport \"p5.createloop\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = (w, h) =>\n  function(p) {\n    const RENDER = p.getURLParams().render;\n\n    p.setup = function() {\n      p.pixelDensity(1);\n      p.frameRate(30);\n\n      w = w || p.min(p.windowWidth, 1280);\n      h = h || p.floor(w * (p.windowHeight / p.windowWidth));\n\n      p.createCanvas(w, h);\n      p.stroke(255);\n      p.fill(255);\n      p.strokeWeight(2);\n\n      p.createLoop(40, {\n        gif: RENDER ? { render: false, open: true } : false,\n        noiseRadius: 0.5,\n      });\n    };\n\n    p.draw = function() {\n      const { theta, noise1D } = p.animLoop;\n      p.blendMode(p.BLEND);\n      p.background(0);\n      p.blendMode(p.DIFFERENCE);\n      p.translate(p.width / 2, p.height / 2);\n      p.rotate(p.animLoop.theta);\n\n      for (let a = 0; a < p.TWO_PI; a += p.TWO_PI / 9) {\n        p.push();\n        p.rotate(a + theta);\n        p.translate(\n          ...polarToCartesian(\n            0,\n            0,\n            p.TWO_PI / 12,\n            p.width * 0.333 * p.sin(theta),\n            true\n          )\n        );\n        p.rotate(-theta * 2);\n\n        p.beginShape();\n        p.vertex(\n          ...polarToCartesian(\n            0,\n            0,\n            p.TWO_PI * noise1D(0.05),\n            p.width * 0.333 * p.sin(theta),\n            true\n          )\n        );\n        p.vertex(\n          ...polarToCartesian(\n            0,\n            0,\n            p.TWO_PI * 0.333 * noise1D(0.06),\n            p.width * 0.333 * p.cos(theta),\n            true\n          )\n        );\n        p.vertex(\n          ...polarToCartesian(\n            0,\n            0,\n            p.TWO_PI * 0.666 * noise1D(0.07),\n            p.width * 0.333 * p.sin(theta),\n            true\n          )\n        );\n        p.endShape(p.CLOSE);\n        p.pop();\n      }\n    };\n  };\n\nexport default ({ location }) => (\n  <SketchLayout\n    sketch={sketch(660, 480)}\n    path={location.pathname}\n    description=\"\"\n  />\n);\n\nexport { sketch };\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}