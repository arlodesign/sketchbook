{"version":3,"sources":["webpack:///./src/pages/sketch/2019/06/19.js","webpack:///./node_modules/core-js/modules/es6.array.fill.js","webpack:///./node_modules/core-js/modules/_array-fill.js","webpack:///./node_modules/core-js/modules/es6.array.from.js","webpack:///./node_modules/core-js/modules/_create-property.js","webpack:///./node_modules/amp-is-object/is-object.js","webpack:///./node_modules/coordinate-systems/coordinate-systems.js","webpack:///./node_modules/amp-is-array/is-array.js","webpack:///./node_modules/amp-is-number/is-number.js","webpack:///./node_modules/amp-extend/extend.js"],"names":["sketch","p","points","initPoints","setup","createCanvas","WEBGL","Array","from","random","TWO_PI","concat","draw","background","directionalLight","min","frameCount","cos","sin","camera","noStroke","fill","specularMaterial","forEach","pt","i","v","createVector","apply","spherical","cart","normalize","push","translate","map","c","rotateX","atan2","y","z","cylinder","noise","x","pop","__webpack_exports__","_ref","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_3__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_6__","path","pathname","description","$export","__webpack_require__","P","toObject","toAbsoluteIndex","toLength","module","exports","value","O","this","length","aLen","arguments","index","undefined","end","endPos","ctx","call","isArrayIter","createProperty","getIterFn","S","F","iter","arrayLike","result","step","iterator","C","mapfn","mapping","iterFn","next","done","$defineProperty","createDesc","object","f","obj","type","isArray","isNumber","isObject","extend","degPerRadian","Math","PI","Coordinate","config","isRadian","isDegree","_x","_y","_z","_r","_t","_p","pos","defineProperty","get","set","label","coords","Error","initialType","prototype","cartesian","options","temp","cartesian2d","cartesian3d","polarToCart2d","polar","cylindrical","sphericalToCart3d","cyl","cartesian2dToPolar","center","cartesian3dToCylindrical","sphericalToCylindrical","pol","sph","cartesian3dToSpherical","cylindricalToSpherical","baseCoord","arrToNumeric","nums","num","TypeError","parseFloat","rt","r","t","xy","sqrt","xyz","x2","y2","z2","rtz","sr","sp","rtp","cr","toString","nativeIsArray","source","prop"],"mappings":"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","file":"component---src-pages-sketch-2019-06-19-js-a8b0fe74fd1cf0f4306c.js","sourcesContent":["import React from \"react\";\nimport { spherical } from \"coordinate-systems\";\nimport SketchLayout from \"~components/sketch-layout\";\n\nconst sketch = function(p) {\n  const SIZE = 200;\n\n  let points = [];\n  let initPoints = [];\n\n  p.setup = function() {\n    p.createCanvas(660, 840, p.WEBGL);\n    initPoints = Array.from(Array(50), () => [\n      SIZE,\n      p.random(p.TWO_PI),\n      p.random(p.TWO_PI),\n    ]);\n    points = [...initPoints];\n  };\n\n  p.draw = function() {\n    p.background(0);\n    p.directionalLight(\n      p.min(p.frameCount, 255),\n      p.min(p.frameCount, 255),\n      p.min(p.frameCount, 255),\n      p.cos(p.frameCount / 100),\n      p.sin(p.frameCount / 200),\n      p.sin(p.frameCount / 100) / 2\n    );\n    p.camera(\n      p.sin(p.frameCount / (SIZE * 5)) * (SIZE * 2),\n      p.cos(p.frameCount / (SIZE * 5)) * (SIZE * 2),\n      SIZE / 3,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    );\n\n    p.noStroke();\n    p.fill(0);\n    p.specularMaterial(255, 255, 255);\n\n    points.forEach((pt, i) => {\n      const v = p.createVector(...spherical(pt).cart());\n      v.normalize();\n\n      p.push();\n      p.translate(\n        ...spherical(pt)\n          .cart()\n          .map(c => c / 2)\n      );\n      p.rotateX(p.atan2(v.y, v.z));\n      p.cylinder(20 * p.noise(v.x, v.y, p.frameCount / 150), SIZE, 50);\n      p.pop();\n\n      points[i] = [\n        SIZE,\n        initPoints[i][1] * p.noise(initPoints[i][1], p.frameCount / 500),\n        initPoints[i][2] * p.noise(initPoints[i][2], p.frameCount / 500),\n      ];\n    });\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', { fill: require('./_array-fill') });\n\nrequire('./_add-to-unscopables')('fill');\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = require('./_to-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var aLen = arguments.length;\n  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);\n  var end = aLen > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n","'use strict';\nvar ctx = require('./_ctx');\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar toLength = require('./_to-length');\nvar createProperty = require('./_create-property');\nvar getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n","module.exports = function isObject(obj) {\n    var type = typeof obj;\n    return !!obj && (type === 'function' || type === 'object');\n};\n","\"use strict\";\nvar isArray = require('amp-is-array');\nvar isNumber = require('amp-is-number');\nvar isObject = require('amp-is-object');\nvar extend = require('amp-extend');\nvar degPerRadian = 180 / Math.PI;\n\n/**\n * @constructor Coordinate\n * @description Defines object which can convert between coordinate systems.\n * It is recommended to use one of the Coodinate.STATIC_CONSTRUCTOR functions\n * to generate your first coordinate before conversions. e.g. Coodinate.spherical(...)\n * @param {Object} config\n * {\n *     label: 'type of initial coordinate',\n *     coords: {\n *         x/y/z/r/t/p: 'k-v pairs'\n *     },\n *     isDegree: Boolean\n * }\n */\nvar Coordinate = function (config) {\n    var isRadian,\n        isDegree,\n        pos = {},\n        _x, _y, _z, _r, _t, _p;\n\n    // Override select setters/getts\n    Object.defineProperty(this, \"isRadian\", {\n        get: function (x) { return isRadian; },\n        set: function (x) {\n            isRadian = !!x;\n            if (isDegree !== !x) { isDegree = !x; } // jshint ignore:line\n        }\n    });\n    Object.defineProperty(this, \"isDegree\", {\n        get: function (x) { return isDegree; },\n        set: function (x) {\n            isDegree = x;\n            if (isRadian !== !x) { isRadian = !x; } // jshint ignore:line\n        }\n    });\n    Object.defineProperty(pos, \"cartesian2d\", {\n        get: function (x) { return [_x, _y]; },\n        set: function (x) { _x = x[0]; _y = x[1]; }\n    });\n    Object.defineProperty(pos, \"cartesian3d\", {\n        get: function (x) { return [_x, _y, _z]; },\n        set: function (x) { _x = x[0]; _y = x[1]; _z = x[2]; }\n    });\n    Object.defineProperty(pos, \"polar\", {\n        get: function (x) { return [_r, _t]; },\n        set: function (x) { _r = x[0]; _t = x[1]; }\n    });\n    Object.defineProperty(pos, \"cylindrical\", {\n        get: function (x) { return [_r, _t, _z]; },\n        set: function (x) { _r = x[0]; _t = x[1]; _z = x[2]; }\n    });\n    Object.defineProperty(pos, \"spherical\", {\n        get: function (x) { return [_r, _t, _p]; },\n        set: function (x) { _r = x[0]; _t = x[1]; _p = x[2]; }\n    });\n\n    // init from config\n    if (config.isDegree && !config.isRadian) {\n        this.isDegree = true;\n    } else {\n        this.isRadian = true;\n    }\n    if (!config.label || !config.coords) {\n        throw new Error(\"no coordinate type defined\");\n    }\n    this.initialType = config.label;\n    this.pos = pos;\n    this.pos[config.label] = config.coords;\n};\n\n\n\n/**\n * @method cartesian\n * Converts current coordinate to cartesian\n * @function cartesian\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cartesian = function () { return this.cart.apply(this, arguments); };\n/**\n * @method cart\n * Converts current coordinate to cartesian\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cart = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            return this.pos.cartesian2d;\n        case 'cartesian3d':\n            return this.pos.cartesian3d;\n        case 'polar':\n            this.pos.cartesian2d = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n            return this.pos.cartesian2d;\n        case 'cylindrical':\n            temp = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n            this.pos.cartesian3d = [temp[0], temp[1], this.pos.cylindrical[2]];\n            return this.pos.cartesian3d;\n        case 'spherical':\n            this.pos.cartesian3d = Coordinate.sphericalToCart3d(this.pos.spherical, this.isDegree);\n            return this.pos.cartesian3d;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n\n/**\n * @method cylindrical\n * Converts current coordinate to cylindrical\n * @function cylindrical\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cylindrical = function () { return this.cyl.apply(this, arguments); };\n/**\n * @method cyl\n * Converts current coordinate to cylindrical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cyl = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            this.pos.cylindrical = [temp[0], temp[1], 0];\n            return this.pos.cylindrical;\n        case 'cartesian3d':\n            this.pos.cylindrical = Coordinate.cartesian3dToCylindrical(this.pos.cartesian3d, this.isDegree, options.center);\n            return this.pos.cylindrical;\n        case 'polar':\n            temp = this.pos.polar;\n            return [temp[0], temp[1], 0];\n        case 'cylindrical':\n            return this.pos.cylindrical;\n        case 'spherical':\n            this.pos.cylindrical = Coordinate.sphericalToCylindrical(this.pos.spherical, this.isDegree);\n            return this.pos.cylindrical;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n/**\n * @method pol\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.pol = function () { return this.polar.apply(this, arguments); };\n/**\n * @method polar\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.polar = function (options) {\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            this.pos.polar = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            return this.pos.polar;\n        case 'polar':\n            return this.pos.polar;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n\n/**\n * @method spherical\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.spherical = function () { return this.sph.apply(this, arguments); };\n/**\n * @method sph\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.sph = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            this.pos.spherical = [temp[0], temp[1], 0];\n            return this.pos.spherical;\n        case 'cartesian3d':\n            this.pos.spherical = Coordinate.cartesian3dToSpherical(this.pos.cartesian3d, this.isDegree, options.center);\n            return this.pos.spherical;\n        case 'polar':\n            temp = this.pos.polar;\n            return [temp[0], temp[1], 0];\n        case 'cylindrical':\n            this.pos.spherical = Coordinate.cylindricalToSpherical(this.pos.cylindrical, this.isDegree);\n            return this.pos.spherical;\n        case 'spherical':\n            return this.pos.spherical;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n///\n/// Static Constructor Functions\n///\n\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cartesian = function(x) { return Coordinate.cart(x); };\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cart = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length < 2 || options.coords.length > 3) {\n            throw new Error('expected exactly 2 or exactly 3 cartesian options');\n        }\n        baseCoord = {\n            label: 'cartesian2d',\n            options: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        if (options.coords.length === 2) {\n            return new Coordinate(baseCoord);\n        }\n        baseCoord.label = 'cartesian3d';\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [x,y,(z?)] coords');\n};\n\n\n\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cylindrical = function(x) { return Coordinate.cyl(x); };\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cyl = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 3) {\n            throw new Error('expected exactly 3 params [r, t, z]');\n        }\n        baseCoord = {\n            label: 'cylindrical',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [r, t, z] coords');\n};\n\n\n\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.polar = function(x) { return Coordinate.pol(x); };\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.pol = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 2) {\n            throw new Error('expected exactly 2 params [r, t]');\n        }\n        baseCoord = {\n            label: 'polar',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected array of [r, t] options');\n};\n\n\n\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.spherical = function(options) { return Coordinate.sph(options); };\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.sph = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 3) {\n            throw new Error('expected exactly 3 params [r, t, p]');\n        }\n        baseCoord = {\n            label: 'spherical',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [r, t, p] coords');\n};\n\n\n\n/**\n * Mutates an array of number-like looking values to purely numeric array\n * @example\n * [5, '2.4', '0'] => [5, 2.4, 0]\n * @param  {Array} nums\n * @return {undefined}\n */\nCoordinate.arrToNumeric = function(nums) {\n    var num;\n    if (!isArray(nums)) {\n        throw new TypeError(\"expected array of number-like values\");\n    }\n    for (var i = nums.length - 1; i >= 0; i--) {\n        num = nums[i];\n        if (typeof num === 'string') {\n            num = parseFloat(num);\n        }\n        if (!isNumber(num)) {\n            throw new TypeError(num + ' not numeric or numeric-like');\n        }\n    }\n};\n\n\n\n/**\n * Convert polar to 2d cartesian coordinates\n * @param  {Array}   rt        [radis, theta]\n * @param  {Boolean} isDegree specifies units\n * @return {Array}  [x, y]\n */\nCoordinate.polarToCart2d = function(rt, isDegree) {\n    var r, t, x, y;\n    r = rt[0];\n    t = rt[1];\n    if (isDegree) {\n        t = t * (1/degPerRadian);\n    }\n    x = r * Math.cos(t);\n    y = r * Math.sin(t);\n    return [x, y];\n};\n\n\n\n/**\n * Convert cartesian 2d to polar coordinates\n * @param  {Array}  xy\n * @param {Boolean=} isDegree overrides default radian theta assumption\n * @param  {Array=} center [x, y] coords of center of circle.  Defaults to [0, 0],\n * however may be offset.  Note. Such functionality not supported yet for converting\n * polar to cartesian\n * @return {Array}  [radius, theta]\n */\nCoordinate.cartesian2dToPolar = function(xy, isDegree, center) {\n    var x, y, r, t;\n    if (!isArray(xy) && xy.length !== 2) {\n        throw new TypeError('expected [x, y] xy array');\n    }\n    x = xy[0];\n    y = xy[1];\n    if (center && !isArray(center) && center.length !== 2) {\n        throw new TypeError('expected [x, y] center array');\n    }\n    if (center) {\n        x = x - center[0];\n        y = y - center[1];\n    }\n    r = Math.sqrt(x*x + y*y);\n    t = Math.atan2(y, x);\n    if (isDegree) {\n        t = t * degPerRadian;\n    }\n    return [r, t];\n};\n\n\n\n/**\n * Convert 3d cartesian to 3d cylindrical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y] coords of center of circle\n * @return {Array}      [radius, theta, z]\n */\nCoordinate.cartesian3dToCylindrical = function (xyz, isDegree, center) {\n    var x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        rt;\n    rt = Coordinate.cartesian2dToPolar([x, y], isDegree, center);\n    return [rt[0], rt[1], z];\n};\n\n\n\n/**\n * Convert 3d cartesian to 3d spherical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y, z] coords of center of circle\n * @return {Array}      [radius, theta, phi]\n */\nCoordinate.cartesian3dToSpherical = function (xyz, isDegree, center) {\n    if (center && center.length !== 3) {\n        throw new Error('expected center value to have [x, y, z] coords' +\n            'for locating sphere center');\n    }\n    var x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        x2, y2, z2,\n        r, t, p;\n    if (center) {\n        x = x - center[0];\n        y = y - center[1];\n        z = z - center[2];\n    }\n    x2 = x*x; y2 = y*y; z2 = z*z;\n    r = Math.sqrt(x2 + y2 + z2);\n    if (!r) {\n        p = t = 0;\n    } else {\n        t = Math.atan2(y,x);\n        p = Math.atan2(Math.sqrt(x2 + y2), z);\n        if (isDegree) {\n            t = t * degPerRadian;\n            p = p * degPerRadian;\n        }\n    }\n    return [r, t, p];\n};\n\n\n\n/**\n * Convert a cylindrical to a spherical coordinates\n * @param  {Array}   rtz\n * @param  {Boolean} isDegree\n * @return {Array}   [radius, theta, phi]\n */\nCoordinate.cylindricalToSpherical = function(rtz, isDegree) {\n    var r = rtz[0], t = rtz[1], z = rtz[2];\n    var sr, sp; // sphere radius, sphere theta...\n    if (isDegree) {\n        t = t / degPerRadian;\n    }\n    sr = Math.sqrt(r*r + z*z);\n    sp = Math.atan2(r, z);\n    if (isDegree) {\n        sp = sp * degPerRadian;\n        t = t * degPerRadian;\n    }\n    return [sr, t, sp];\n};\n\n\n\n/**\n * Convert spherical to a cartesian coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\nCoordinate.sphericalToCart3d = function (rtp, isDegree) {\n    var r = rtp[0], t = rtp[1], p = rtp[2],\n        x,y,z;\n    if (isDegree) {\n        t = t / degPerRadian;\n        p = p / degPerRadian;\n    }\n    x = r * Math.sin(p) * Math.cos(t);\n    y = r * Math.sin(p) * Math.sin(t);\n    z = r * Math.cos(p);\n    return [x, y, z];\n};\n\n\n\n/**\n * Convert spherical to cylindrical coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\nCoordinate.sphericalToCylindrical = function (rtp, isDegree) {\n    var r = rtp[0], t = rtp[1], p = rtp[2],\n        cr, z;\n    if (isDegree) {\n        t = t / degPerRadian;\n        p = p / degPerRadian;\n    }\n    cr = r * Math.sin(p);\n    z = r * Math.cos(p);\n    if (isDegree) {\n        t = t * degPerRadian;\n        p = p * degPerRadian;\n    }\n    return [cr, t, z];\n};\n\nmodule.exports = Coordinate;\n","var toString = Object.prototype.toString;\nvar nativeIsArray = Array.isArray;\n\n\nmodule.exports = nativeIsArray || function isArray(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n","var toString = Object.prototype.toString;\n\n\nmodule.exports = function isNumber(obj) {\n    return toString.call(obj) === '[object Number]';\n};\n","var isObject = require('amp-is-object');\n\n\nmodule.exports = function(obj) {\n    if (!isObject(obj)) return obj;\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n        source = arguments[i];\n        for (prop in source) {\n            obj[prop] = source[prop];\n        }\n    }\n    return obj;\n};\n"],"sourceRoot":""}