{"version":3,"sources":["webpack:///./node_modules/bezier-easing/src/index.js","webpack:///./src/pages/sketch/2019/10/18.js"],"names":["float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","LinearEasing","x","module","exports","mX1","mY1","mX2","mY2","Error","sampleValues","Array","i","getTForX","aX","intervalStart","currentSample","kSplineTableSize","guessForT","initialSlope","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","Math","abs","binarySubdivide","ease","bezierEasing","RENDER","process","DEV","sketch","p","HUE","random","R","HALF_PI","squiggles","lines","prevMod","Shape","sqrt","GRID","y","this","rotate","QUARTER_PI","PI","scale","rotateDirection","turning","offset","noise","TWO_PI","Squiggle","draw","turn","theta","animLoop","turnVal","map","push","translate","strokeWeight","bezier","pop","Lines","line","setup","pixelDensity","createCanvas","colorMode","HSB","createLoop","gif","render","open","width","height","background","stroke","forEach","b","location","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2019-10-18-js-b580d7522bf1d0bf1bab.js","sourcesContent":["require(\"core-js/modules/es6.typed.float32-array\");\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nfunction LinearEasing(x) {\n  return x;\n}\n\nmodule.exports = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport \"p5.createloop\";\nimport bezierEasing from \"bezier-easing\";\nimport Link from \"~components/link\";\n\nconst ease = bezierEasing(0, 1, 1, 0);\n\nconst RENDER = process.env.DEV && true;\nconst DURATION = 15;\nconst GRID = 45;\n\nconst sketch = function(p) {\n  const HUE = p.random();\n  const R = p.HALF_PI;\n\n  let squiggles = [];\n  let lines = [];\n  let prevMod = 0;\n  let d = p.sqrt(GRID * GRID + GRID * GRID);\n  let w = GRID / 2;\n\n  class Shape {\n    constructor(x, y) {\n      this.x = x;\n      this.y = y;\n      this.rotate = p.random([\n        p.QUARTER_PI,\n        p.HALF_PI + p.QUARTER_PI,\n        p.PI + p.QUARTER_PI,\n        p.HALF_PI + p.PI + p.QUARTER_PI,\n      ]);\n      this.scale = p.random([1, -1]);\n      this.rotateDirection = p.random([-1, 1]);\n      this.turning = false;\n      this.offset = p.noise(x, y) * p.TWO_PI;\n    }\n  }\n\n  class Squiggle extends Shape {\n    constructor(x, y) {\n      super(x, y);\n    }\n\n    draw(turn) {\n      const { theta } = p.animLoop;\n\n      if (turn) {\n        this.rotate += R * this.rotateDirection;\n      }\n\n      const turnVal = p.map(theta % R, 0, R, 0, 1);\n\n      p.push();\n      p.translate(this.x + GRID / 2, this.y + GRID / 2);\n      p.rotate(\n        p.map(\n          ease(turnVal),\n          0,\n          1,\n          this.rotate,\n          this.rotate + R * this.rotateDirection\n        )\n      );\n      p.scale(this.scale, 1);\n      p.strokeWeight(GRID / 2);\n\n      p.bezier(\n        -GRID / 2,\n        -GRID / 2,\n        GRID / 2,\n        -GRID / 2,\n        -GRID / 2,\n        GRID / 2,\n        GRID / 2,\n        GRID / 2\n      );\n      p.pop();\n    }\n  }\n\n  class Lines extends Shape {\n    constructor(x, y) {\n      super(x, y);\n    }\n\n    draw(turn) {\n      const { theta } = p.animLoop;\n\n      if (turn) {\n        this.rotate += R * this.rotateDirection;\n      }\n\n      const turnVal = p.map(theta % R, 0, R, 0, 1);\n\n      p.push();\n      p.translate(this.x + GRID / 2, this.y + GRID / 2);\n      p.rotate(\n        p.map(\n          ease(turnVal),\n          0,\n          1,\n          this.rotate,\n          this.rotate + R * this.rotateDirection\n        )\n      );\n      p.strokeWeight(1 + GRID / 3);\n\n      p.line(-GRID / 2, -GRID / 2, GRID / 2, GRID / 2);\n      p.pop();\n    }\n  }\n\n  p.setup = function() {\n    p.pixelDensity(RENDER ? 1 : 2);\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, 1);\n\n    p.createLoop(DURATION, {\n      gif: RENDER ? { render: false, open: true } : false,\n    });\n\n    for (let x = 0; x < p.width; x += GRID) {\n      for (let y = 0; y < p.height; y += GRID) {\n        squiggles.push(new Squiggle(x, y));\n        lines.push(new Lines(x, y));\n      }\n    }\n  };\n\n  p.draw = function() {\n    p.background(1 - HUE, 1, 1);\n\n    p.stroke(HUE, 0.8, 0.7);\n    squiggles.forEach(b => b.draw(p.animLoop.theta % R <= prevMod));\n\n    p.stroke(1 - HUE, 1, 1);\n    lines.forEach(b => b.draw(p.animLoop.theta % R <= prevMod));\n\n    prevMod = p.animLoop.theta % R;\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}