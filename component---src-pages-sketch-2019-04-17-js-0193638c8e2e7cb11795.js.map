{"version":3,"sources":["webpack:///./src/pages/sketch/2019/04/17.js"],"names":["sketch","p","w","h","GRID_SIZE","SIZES","LINES","grid","Doodad","x","y","size","this","lines","drawFunc","random","squareH","squareV","arc","_proto","prototype","push","translate","i","line","pop","rotate","HALF_PI","PI","setup","createCanvas","colorMode","HSB","hue","background","stroke","strokeWeight","strokeCap","PROJECT","noFill","floor","width","height","xx","yy","visited","draw","_ref","_ref3","_p$random","concat","apply","filter","_ref2","overlap","Math","max","s","_ref4","length","noLoop","__webpack_exports__","_ref5","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_0__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_2__","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2019-04-17-js-0193638c8e2e7cb11795.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\n\nconst sketch = function(p) {\n  const GRID_SIZE = 30;\n  const SIZES = [1, 2, 5];\n  const LINES = 3;\n\n  let grid = [];\n  let w;\n  let h;\n\n  class Doodad {\n    constructor(x, y, size) {\n      this.x = x * GRID_SIZE;\n      this.y = y * GRID_SIZE;\n      this.size = size * GRID_SIZE;\n      this.lines = size * LINES;\n\n      this.drawFunc = p.random([\n        this.squareH,\n        this.squareV,\n        this.arc,\n        this.arc,\n      ]);\n      this.drawFunc();\n    }\n    squareH() {\n      p.push();\n      p.translate(this.x, this.y);\n      for (let i = 0; i <= this.size; i += this.size / this.lines) {\n        p.line(0, i, this.size, i);\n      }\n      p.pop();\n    }\n    squareV() {\n      p.push();\n      p.translate(this.x, this.y);\n      for (let i = 0; i <= this.size; i += this.size / this.lines) {\n        p.line(i, 0, i, this.size);\n      }\n      p.pop();\n    }\n\n    arc() {\n      p.push();\n      p.translate(this.x + this.size / 2, this.y + this.size / 2);\n      p.rotate(p.random([0, p.HALF_PI, p.PI, p.HALF_PI + p.PI]));\n      for (let i = 0; i <= this.size * 2; i += (this.size * 2) / this.lines) {\n        p.arc(-this.size / 2, -this.size / 2, i, i, 0, p.HALF_PI);\n      }\n      p.pop();\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, 100);\n\n    p.colorMode(p.HSB, 100);\n\n    const hue = p.random(100);\n    p.background(hue, 75, 100);\n    p.stroke(hue, 50, 15);\n    p.strokeWeight(2);\n    p.strokeCap(p.PROJECT);\n\n    p.noFill();\n\n    w = p.floor(p.width / GRID_SIZE);\n    h = p.floor(p.height / GRID_SIZE);\n\n    for (let xx = 0; xx < w; xx++) {\n      grid.push([]);\n      for (let yy = 0; yy < h; yy++) {\n        grid[xx].push({\n          x: xx,\n          y: yy,\n          visited: false,\n        });\n      }\n    }\n  };\n\n  p.draw = function() {\n    const { x, y } = p.random(\n      [].concat(...grid).filter(({ visited }) => !visited)\n    );\n\n    if (!grid[x][y].visited) {\n      let size = Math.max(...SIZES);\n      let overlap;\n\n      do {\n        overlap = false;\n        for (let xx = x; xx < size + x; xx++) {\n          for (let yy = y; yy < size + y; yy++) {\n            if (x + size > w || y + size > h || grid[xx][yy].visited) {\n              overlap = true;\n            }\n          }\n        }\n        if (overlap) {\n          size = Math.max(...SIZES.filter(s => s < size));\n        }\n      } while (overlap);\n\n      new Doodad(x, y, size);\n\n      for (let xx = x; xx < size + x; xx++) {\n        for (let yy = y; yy < size + y; yy++) {\n          grid[xx][yy].visited = true;\n        }\n      }\n    }\n\n    if (![].concat(...grid).filter(({ visited }) => !visited).length) {\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}