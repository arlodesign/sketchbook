{"version":3,"sources":["webpack:///./node_modules/bezier-easing/src/index.js","webpack:///./src/pages/sketch/2019/12/11.js","webpack:///./src/lib/polarToCartesian.js"],"names":["float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","LinearEasing","x","module","exports","mX1","mY1","mX2","mY2","Error","sampleValues","Array","i","getTForX","aX","intervalStart","currentSample","kSplineTableSize","guessForT","initialSlope","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","Math","abs","binarySubdivide","ease","bezierEasing","sketch","p","RENDER","getURLParams","render","COLORS","shuffle","SHAPES","length","shapes","Point","aLow","aHigh","this","aNoise","random","dNoise","get","animLoop","noise1D","theta","noise2D","polarToCartesian","map","cos","width","Shape","direction","color","points","fill","_","TWO_PI","draw","push","stroke","noFill","translate","height","rotate","beginShape","forEach","pt","curveVertex","endShape","pop","setup","pixelDensity","frameRate","createCanvas","colorMode","HSB","createLoop","gif","open","noiseRadius","strokeWeight","blendMode","BLEND","background","SCREEN","shape","location","path","pathname","description","polarToCartesianX","center","angle","distance","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","y"],"mappings":"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","file":"component---src-pages-sketch-2019-12-11-js-34525e088af52d3ad58d.js","sourcesContent":["require(\"core-js/modules/es6.typed.float32-array\");\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nfunction LinearEasing(x) {\n  return x;\n}\n\nmodule.exports = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport bezierEasing from \"bezier-easing\";\nimport \"p5.createloop\";\n\nconst ease = bezierEasing(0, 0.8, 1, 0.2);\n\nconst sketch = function(p) {\n  const RENDER = p.getURLParams().render;\n  const POINTS = 9;\n  const COLORS = p.shuffle([\"red\", \"green\", \"blue\", \"yellow\"]);\n  const SHAPES = COLORS.length;\n\n  let shapes = [];\n\n  class Point {\n    constructor(aLow, aHigh) {\n      this.aLow = aLow;\n      this.aHigh = aHigh;\n      this.aNoise = p.random();\n      this.dNoise = p.random();\n    }\n    get() {\n      const { noise1D, noise2D, theta } = p.animLoop;\n\n      return polarToCartesian(\n        0,\n        0,\n        p.map(\n          ease(p.map(noise1D(this.aNoise) * p.cos(theta * 3), -1, 1, 0, 1)),\n          0,\n          1,\n          this.aLow,\n          this.aHigh\n        ),\n        p.map(\n          ease(p.map(noise1D(this.dNoise) * p.cos(theta * 7), -1, 1, 0, 1)),\n          0,\n          1,\n          0,\n          p.width * 0.5\n        ),\n        true\n      );\n    }\n  }\n\n  class Shape {\n    constructor(i, ...color) {\n      this.i = i;\n      this.direction = [-1, 1][i % 2];\n      this.color = p.color(...color);\n      this.points = Array(POINTS)\n        .fill()\n        .map(\n          (_, i) =>\n            new Point((p.TWO_PI / POINTS) * i, (p.TWO_PI / POINTS) * (i + 1))\n        );\n    }\n    draw() {\n      p.push();\n      p.stroke(this.color);\n      p.noFill();\n      p.translate(p.width / 2, p.height / 2);\n      p.rotate(p.animLoop.theta * this.direction);\n\n      p.beginShape();\n      this.points.forEach(pt => {\n        p.curveVertex(...pt.get());\n      });\n      p.curveVertex(...this.points[0].get());\n      p.curveVertex(...this.points[1].get());\n      p.curveVertex(...this.points[2].get());\n      p.endShape();\n\n      p.pop();\n    }\n  }\n\n  p.setup = function() {\n    if (RENDER) {\n      p.pixelDensity(1);\n      p.frameRate(30);\n    }\n\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, 1);\n    p.createLoop(20, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 2,\n    });\n    p.strokeWeight(100);\n\n    shapes = Array(SHAPES)\n      .fill()\n      .map((_, i) => new Shape(i, COLORS[i]));\n  };\n\n  p.draw = function() {\n    p.blendMode(p.BLEND);\n    p.background(0);\n    p.blendMode(p.SCREEN);\n    shapes.forEach(shape => shape.draw());\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}