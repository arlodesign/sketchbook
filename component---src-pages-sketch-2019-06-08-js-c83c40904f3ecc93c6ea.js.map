{"version":3,"sources":["webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2019/06/08.js"],"names":["polarToCartesianEllipse","centerX","centerY","angle","radiusX","radiusY","asArray","x","Math","cos","y","sin","polarToCartesian","distance","center","polarToCartesianX","polarToCartesianY","sketch","p","HUE","random","vertices","Vertex","this","TWO_PI","height","speed","get","width","update","setup","createCanvas","noStroke","colorMode","HSL","background","Array","from","draw","vs","filter","clr","color","map","frameCount","length","noFill","stroke","line","fill","beginShape","sort","a","b","forEach","v","vertex","endShape","CLOSE","noLoop","SketchPage"],"mappings":"4FAAA,sCAiBMA,EAA0B,SAC9BC,EACAC,EACAC,EACAC,EACAC,EACAC,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIN,EAAUO,KAAKC,IAAIN,GAASC,EAChCM,EAAIR,EAAUM,KAAKG,IAAIR,GAASE,EACtC,OAAOC,EAAU,CAACC,EAAGG,GAAK,CAAEH,IAAGG,MAIlBE,IAzBU,SACvBX,EACAC,EACAC,EACAU,EACAP,QACG,IADHA,OAAU,GAEV,IAAMC,EAbkB,SAACO,EAAQX,EAAOU,GACxC,OAAOC,EAASN,KAAKC,IAAIN,GAASU,EAYxBE,CAAkBd,EAASE,EAAOU,GACtCH,EAXkB,SAACI,EAAQX,EAAOU,GACxC,OAAOC,EAASN,KAAKG,IAAIR,GAASU,EAUxBG,CAAkBd,EAASC,EAAOU,GAC5C,OAAOP,EAAU,CAACC,EAAGG,GAAK,CAAEH,IAAGG,O,qhBCVjC,IAAMO,EAAS,SAASC,GACtB,IAAMC,EAAMD,EAAEE,OAAO,IAGjBC,EAAW,GAETC,EANmB,WAOvB,aACEC,KAAKpB,MAAQe,EAAEE,OAAOF,EAAEM,QACxBD,KAAKV,SAAWK,EAAEE,OAAOF,EAAEO,QAAU,EAAI,IACzCF,KAAKG,MAAQR,EAAEE,OAAO,EAAE,EAAG,IAAMF,EAAEE,OAAO,KAAQ,MAV7B,2BAYvBO,IAAA,WACE,OAAOf,YACLM,EAAEU,MAAQ,EACVV,EAAEO,OAAS,EACXF,KAAKpB,MACLoB,KAAKV,UACL,IAlBmB,EAqBvBgB,OAAA,WACEN,KAAKpB,OAASoB,KAAKG,MACfH,KAAKpB,MAAQ,IACfoB,KAAKpB,MAAQe,EAAEM,OAASD,KAAKpB,OAE3BoB,KAAKpB,MAAQe,EAAEM,SACjBD,KAAKpB,MAAQoB,KAAKpB,MAAQe,EAAEM,QAE9BD,KAAKV,SAAWU,KAAKV,SAAW,EAAIU,KAAKV,SAAW,IAAO,GA7BtC,KAiCzBK,EAAEY,MAAQ,WACRZ,EAAEa,aAAa,IAAK,KACpBb,EAAEc,WACFd,EAAEe,UAAUf,EAAEgB,IAAK,KACnBhB,EAAEiB,WAAWhB,EAAK,IAAK,GAEvBE,EAAWe,MAAMC,KAAKD,MArCV,KAqCwB,kBAAM,IAAId,MAGhDJ,EAAEoB,KAAO,WACP,IAAMC,EAAKlB,EAASmB,QAAO,qBAAG3B,SAA0B,KAClD4B,EAAMvB,EAAEwB,MACZxB,EAAEyB,IAAIzB,EAAET,IAAIS,EAAE0B,WAAa,MAAQ,EAAG,EAAGzB,EAAKA,EAAM,IACpDD,EAAEyB,IAAIzB,EAAEP,IAAIO,EAAE0B,WAAa,KAAM,EAAG,EAAG,GAAI,KAC3C1B,EAAEyB,IAAIzB,EAAET,IAAIS,EAAE0B,WAAa,MAAO,EAAG,EAAG,EAAG,KAC3C,IAGgB,IAAdL,EAAGM,OAKW,IAAdN,EAAGM,QACL3B,EAAE4B,SACF5B,EAAE6B,OAAON,GACTvB,EAAE8B,KAAF,MAAA9B,EAAC,EAASqB,EAAG,GAAGZ,OAAf,SAAyBY,EAAG,GAAGZ,SAChCY,EAAG,GAAGV,SACNU,EAAG,GAAGV,WAENX,EAAEc,WACFd,EAAE+B,KAAKR,GACPvB,EAAEgC,aACFX,EAAGY,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEjD,MAAQkD,EAAElD,SAAOmD,SAAQ,SAAAC,GAC3CrC,EAAEsC,OAAF,MAAAtC,EAAC,EAAWqC,EAAE5B,QACd4B,EAAE1B,YAEJX,EAAEuC,SAASvC,EAAEwC,QAlBbxC,EAAEyC,WA6BOC,UANI,kBACjB,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAQ3C,OAAQA","file":"component---src-pages-sketch-2019-06-08-js-c83c40904f3ecc93c6ea.js","sourcesContent":["const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\nimport Layout from \"~components/layout\";\nimport Sketch from \"~components/sketch\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  const HUE = p.random(80);\n  const V_QTY = 10;\n\n  let vertices = [];\n\n  class Vertex {\n    constructor() {\n      this.angle = p.random(p.TWO_PI);\n      this.distance = p.random(p.height * (2 / 3));\n      this.speed = p.random([-1, 1]) * p.random(0.0001, 0.001);\n    }\n    get() {\n      return polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        this.angle,\n        this.distance,\n        true\n      );\n    }\n    update() {\n      this.angle += this.speed;\n      if (this.angle < 0) {\n        this.angle = p.TWO_PI + this.angle;\n      }\n      if (this.angle > p.TWO_PI) {\n        this.angle = this.angle - p.TWO_PI;\n      }\n      this.distance = this.distance > 0 ? this.distance - 0.03 : 0;\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.noStroke();\n    p.colorMode(p.HSL, 100);\n    p.background(HUE, 100, 0);\n\n    vertices = Array.from(Array(V_QTY), () => new Vertex());\n  };\n\n  p.draw = function() {\n    const vs = vertices.filter(({ distance }) => distance > 0);\n    const clr = p.color(\n      p.map(p.cos(p.frameCount / 1000), -1, 1, HUE, HUE + 20),\n      p.map(p.sin(p.frameCount / 50), -1, 1, 80, 100),\n      p.map(p.cos(p.frameCount / 500), -1, 1, 0, 100),\n      80\n    );\n\n    if (vs.length === 1) {\n      p.noLoop();\n      return;\n    }\n\n    if (vs.length === 2) {\n      p.noFill();\n      p.stroke(clr);\n      p.line(...vs[0].get(), ...vs[1].get());\n      vs[0].update();\n      vs[1].update();\n    } else {\n      p.noStroke();\n      p.fill(clr);\n      p.beginShape();\n      vs.sort((a, b) => a.angle - b.angle).forEach(v => {\n        p.vertex(...v.get());\n        v.update();\n      });\n      p.endShape(p.CLOSE);\n    }\n  };\n};\n\nconst SketchPage = () => (\n  <Layout>\n    <Sketch sketch={sketch} />\n  </Layout>\n);\n\nexport default SketchPage;\n"],"sourceRoot":""}