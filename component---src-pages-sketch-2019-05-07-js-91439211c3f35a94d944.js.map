{"version":3,"sources":["webpack:///./src/pages/sketch/2019/05/07.js","webpack:///./src/lib/polarToCartesian.js","webpack:///./src/lib/lerpLine.js","webpack:///./src/lib/addNoise.js"],"names":["sketch","p","w","h","SIZES","gridSize","iterations","grid","Doodad","x","y","size","this","drawFunc","random","drawBackslash","drawSlash","stroke","_proto","prototype","lerpLine","setup","createCanvas","background","noFill","draw","_ref","_ref3","length","strokeWeight","floor","width","height","xx","push","yy","visited","_p$random","concat","apply","filter","_ref2","overlap","Math","max","s","_ref4","noLoop","__webpack_exports__","_ref5","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_0__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_2__","path","pathname","description","__webpack_require__","d","polarToCartesianX","polarToCartesianY","polarToCartesianEllipse","center","angle","distance","cos","sin","centerX","centerY","radiusX","radiusY","asArray","polarToCartesian","x1","y1","x2","y2","rate","showFirstDot","Error","l","point","lerp","addNoise","intensity","PTS","console","log","i","fill","noStroke","ellipse","randomGaussian","pixelDensity","pop"],"mappings":"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","file":"component---src-pages-sketch-2019-05-07-js-91439211c3f35a94d944.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport addNoise from \"~lib/addNoise\";\nimport lerpLine from \"~lib/lerpLine\";\n\nconst sketch = function(p) {\n  const SIZES = [1, 2, 3, 5, 8];\n\n  let gridSize = 60;\n  let iterations = 3;\n  let grid = [];\n  let w;\n  let h;\n\n  class Doodad {\n    constructor(x, y, size) {\n      this.x = x * gridSize;\n      this.y = y * gridSize;\n      this.size = size * gridSize;\n\n      this.drawFunc = p.random() < 0.1 ? this.drawBackslash : this.drawSlash;\n      p.stroke(p.random() < 0.3 ? 255 : 0);\n      this.drawFunc();\n    }\n    drawSlash() {\n      lerpLine(\n        p,\n        this.x,\n        this.y + this.size,\n        this.x + this.size,\n        this.y,\n        p.random()\n      );\n    }\n    drawBackslash() {\n      lerpLine(\n        p,\n        this.x,\n        this.y,\n        this.x + this.size,\n        this.y + this.size,\n        p.random()\n      );\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.background(128);\n    p.noFill();\n  };\n\n  p.draw = function() {\n    if (grid.length == 0) {\n      p.strokeWeight(gridSize / 3);\n\n      w = p.floor(p.width / gridSize);\n      h = p.floor(p.height / gridSize);\n\n      for (let xx = 0; xx < w; xx++) {\n        grid.push([]);\n        for (let yy = 0; yy < h; yy++) {\n          grid[xx].push({\n            x: xx,\n            y: yy,\n            visited: false,\n          });\n        }\n      }\n    }\n\n    const { x, y } = p.random(\n      [].concat(...grid).filter(({ visited }) => !visited)\n    );\n\n    if (!grid[x][y].visited) {\n      let size = Math.max(...SIZES);\n      let overlap;\n\n      do {\n        overlap = false;\n        for (let xx = x; xx < size + x; xx++) {\n          for (let yy = y; yy < size + y; yy++) {\n            if (x + size > w || y + size > h || grid[xx][yy].visited) {\n              overlap = true;\n            }\n          }\n        }\n        if (overlap) {\n          size = Math.max(...SIZES.filter(s => s < size));\n        }\n      } while (overlap);\n\n      new Doodad(x, y, size);\n\n      for (let xx = x; xx < size + x; xx++) {\n        for (let yy = y; yy < size + y; yy++) {\n          grid[xx][yy].visited = true;\n        }\n      }\n    }\n\n    if (![].concat(...grid).filter(({ visited }) => !visited).length) {\n      iterations--;\n      if (iterations > 0) {\n        gridSize /= 3;\n        grid = [];\n      } else {\n        p.noLoop();\n      }\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","export default function(p, x1, y1, x2, y2, rate, showFirstDot = true) {\n  if (rate <= 0)\n    throw new Error(\"rate for lerpLine() must be greater than zero\");\n\n  for (let l = 0; l < 1; l += rate) {\n    if (l === 0 && !showFirstDot) continue;\n    p.random() > l && p.point(p.lerp(x1, x2, l), p.lerp(y1, y2, l));\n  }\n}\n","const addNoise = (p, intensity = 0.5) => {\n  const PTS = p.width * p.height * 0.02;\n\n  console.log(PTS);\n\n  p.push();\n  for (let i = 0; i < PTS; i++) {\n    p.fill(\n      i % 2\n        ? `rgba(0, 0, 0, ${intensity})`\n        : `rgba(255, 255, 255, ${intensity})`\n    );\n    p.noStroke();\n    p.ellipse(\n      p.randomGaussian(p.width / 2, p.width / 3),\n      p.randomGaussian(p.height / 2, p.height / 3),\n      1 / (p.pixelDensity() / 2)\n    );\n  }\n  p.pop();\n};\n\nexport default addNoise;\n"],"sourceRoot":""}