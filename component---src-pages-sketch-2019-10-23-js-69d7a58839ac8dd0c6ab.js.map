{"version":3,"sources":["webpack:///./src/pages/sketch/2019/10/23.js","webpack:///./src/lib/polarToCartesian.js"],"names":["RENDER","process","DEV","sketch","p","stripeCount","points","Array","highlightPoints","Point","i","this","_angle","random","TWO_PI","distance","width","seed","animLoop","noise1D","polarToCartesian","height","angle","setup","pixelDensity","frameRate","createCanvas","createLoop","gif","render","open","noiseRadius","noStroke","map","sin","theta","fill","_","draw","background","stripes","createGraphics","x","rect","mask","beginShape","forEach","coord","vertex","endShape","CLOSE","stripesImage","get","image","blendMode","SCREEN","BLEND","location","path","pathname","description","polarToCartesianX","center","Math","cos","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","y"],"mappings":"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","file":"component---src-pages-sketch-2019-10-23-js-69d7a58839ac8dd0c6ab.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport \"p5.createloop\";\n\nconst POINT_COUNT = 3;\nconst RENDER = process.env.DEV && false;\n\nconst sketch = function(p) {\n  let points = Array(POINT_COUNT);\n  let highlightPoints = Array(POINT_COUNT);\n  let stripeCount;\n\n  class Point {\n    constructor(i) {\n      this._angle = p.random(p.TWO_PI * i, p.TWO_PI * (i + 1));\n      this.distance = p.width / 2;\n      this.seed = p.random(0.1);\n    }\n\n    get angle() {\n      return this._angle * p.animLoop.noise1D(this.seed);\n    }\n\n    get coord() {\n      return polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        this.angle,\n        this.distance,\n        true\n      );\n    }\n  }\n\n  p.setup = function() {\n    p.pixelDensity(1);\n    p.frameRate(30);\n    p.createCanvas(660, 840);\n    p.createLoop(49, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 0.1,\n    });\n    p.noStroke();\n\n    stripeCount = () => p.map(p.sin(p.animLoop.theta), -1, 1, 10, 40);\n\n    points = points.fill(null).map((_, i) => new Point(i));\n    highlightPoints = highlightPoints.fill(null).map((_, i) => new Point(i));\n  };\n\n  p.draw = function() {\n    p.background(255);\n\n    const stripes = p.createGraphics(p.width, p.height);\n    stripes.fill(0);\n    for (let x = 0; x < p.width; x += p.width / stripeCount()) {\n      stripes.rect(x, 0, p.width / stripeCount() / 2, p.height);\n    }\n\n    const mask = p.createGraphics(p.width, p.height);\n\n    mask.fill(0);\n    mask.beginShape();\n    points.forEach(({ coord }) => mask.vertex(...coord));\n    mask.endShape(mask.CLOSE);\n\n    const stripesImage = stripes.get();\n    stripesImage.mask(mask);\n\n    p.image(stripesImage, 0, 0);\n\n    p.blendMode(p.SCREEN);\n    p.fill(\"lightblue\");\n    p.rect(0, 0, p.width, p.height);\n    p.blendMode(p.BLEND);\n\n    for (\n      let x =\n        (p.width * -p.animLoop.theta) / p.TWO_PI + p.width / stripeCount() / 2;\n      x < p.width;\n      x += p.width / stripeCount()\n    ) {\n      p.rect(x, 0, p.width / stripeCount() / 2, p.height);\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}