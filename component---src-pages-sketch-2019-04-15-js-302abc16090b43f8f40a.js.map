{"version":3,"sources":["webpack:///./src/lib/addNoise.js","webpack:///./src/pages/sketch/2019/04/15.js","webpack:///./src/lib/polarToCartesian.js"],"names":["addNoise","p","intensity","PTS","width","height","push","i","fill","noStroke","ellipse","randomGaussian","pixelDensity","pop","sketch","w","h","SIZES","gridSize","iterations","grid","Doodad","x","y","size","this","drawFunc","random","drawBackslash","drawSlash","line","setup","createCanvas","colorMode","HSB","hue","background","stroke","noFill","draw","length","strokeWeight","floor","xx","yy","visited","concat","filter","overlap","Math","max","s","noLoop","location","path","pathname","description","polarToCartesianX","center","angle","distance","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","polarToCartesian"],"mappings":"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","file":"component---src-pages-sketch-2019-04-15-js-302abc16090b43f8f40a.js","sourcesContent":["const addNoise = (p, intensity = 0.5) => {\n  const PTS = p.width * p.height * 0.02;\n\n  p.push();\n  for (let i = 0; i < PTS; i++) {\n    p.fill(\n      i % 2\n        ? `rgba(0, 0, 0, ${intensity})`\n        : `rgba(255, 255, 255, ${intensity})`\n    );\n    p.noStroke();\n    p.ellipse(\n      p.randomGaussian(p.width / 2, p.width / 3),\n      p.randomGaussian(p.height / 2, p.height / 3),\n      1 / (p.pixelDensity() / 2)\n    );\n  }\n  p.pop();\n};\n\nexport default addNoise;\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport addNoise from \"~lib/addNoise\";\n\nconst sketch = function(p) {\n  const SIZES = [1, 2, 3, 5, 8];\n\n  let gridSize = 60;\n  let iterations = 3;\n  let grid = [];\n  let w;\n  let h;\n\n  class Doodad {\n    constructor(x, y, size) {\n      this.x = x * gridSize;\n      this.y = y * gridSize;\n      this.size = size * gridSize;\n      // this.drawFunc = p.random([\n      //   this.drawSlash,\n      //   this.drawSlash,\n      //   this.drawBackslash,\n      // ]);\n      this.drawFunc = p.random() < 0.1 ? this.drawBackslash : this.drawSlash;\n      this.drawFunc();\n    }\n    drawSlash() {\n      p.line(this.x, this.y + this.size, this.x + this.size, this.y);\n    }\n    drawBackslash() {\n      p.line(this.x, this.y, this.x + this.size, this.y + this.size);\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, 100);\n\n    const hue = p.random(100);\n    p.background(100 - hue, 50, 75);\n    p.stroke(hue, 25, 25);\n    p.noFill();\n  };\n\n  p.draw = function() {\n    if (grid.length == 0) {\n      p.strokeWeight(gridSize / 3);\n\n      w = p.floor(p.width / gridSize);\n      h = p.floor(p.height / gridSize);\n\n      for (let xx = 0; xx < w; xx++) {\n        grid.push([]);\n        for (let yy = 0; yy < h; yy++) {\n          grid[xx].push({\n            x: xx,\n            y: yy,\n            visited: false,\n          });\n        }\n      }\n    }\n\n    const { x, y } = p.random(\n      [].concat(...grid).filter(({ visited }) => !visited)\n    );\n\n    if (!grid[x][y].visited) {\n      let size = Math.max(...SIZES);\n      let overlap;\n\n      do {\n        overlap = false;\n        for (let xx = x; xx < size + x; xx++) {\n          for (let yy = y; yy < size + y; yy++) {\n            if (x + size > w || y + size > h || grid[xx][yy].visited) {\n              overlap = true;\n            }\n          }\n        }\n        if (overlap) {\n          size = Math.max(...SIZES.filter(s => s < size));\n        }\n      } while (overlap);\n\n      new Doodad(x, y, size);\n\n      for (let xx = x; xx < size + x; xx++) {\n        for (let yy = y; yy < size + y; yy++) {\n          grid[xx][yy].visited = true;\n        }\n      }\n    }\n\n    if (![].concat(...grid).filter(({ visited }) => !visited).length) {\n      iterations--;\n      if (iterations > 0) {\n        gridSize /= 2;\n        grid = [];\n      } else {\n        p.noLoop();\n      }\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}