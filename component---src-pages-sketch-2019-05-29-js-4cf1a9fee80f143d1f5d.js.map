{"version":3,"sources":["webpack:///./src/lib/lerpLine.js","webpack:///./src/pages/sketch/2019/05/29.js"],"names":["p","x1","y1","x2","y2","rate","showFirstDot","noisy","thisRate","Math","max","dist","l","random","point","lerp","sketch","w","h","GRID_SIZE","SIZES","LINES","grid","Doodad","x","y","size","this","lines","drawFunc","square","triangle","push","translate","rotate","HALF_PI","PI","i","DIST","lerpLine","pop","setup","createCanvas","colorMode","HSB","hue","background","stroke","strokeWeight","strokeCap","ROUND","noFill","floor","width","height","xx","yy","visited","draw","concat","filter","overlap","s","length","noLoop","location","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2019-05-29-js-4cf1a9fee80f143d1f5d.js","sourcesContent":["/**\n * Creates a line of points at a specified interval (the rate)\n *\n * @param {obj} p The current p5.js drawing context\n * @param {*} x1\n * @param {*} y1\n * @param {*} x2\n * @param {*} y2\n * @param {*} rate Number between 0 and 1 to determine how often to draw a point\n * @param {*} showFirstDot Defaults to true\n * @param {*} noisy Defaults to true\n */\nexport default function(\n  p,\n  x1,\n  y1,\n  x2,\n  y2,\n  rate,\n  showFirstDot = true,\n  noisy = true\n) {\n  const thisRate = Math.max(rate, 0.01 / p.dist(x1, y1, x2, y2));\n\n  for (let l = 0; l < 1; l += thisRate) {\n    if (l === 0 && !showFirstDot) continue;\n    if ((noisy && p.random() > l) || !noisy) {\n      p.point(p.lerp(x1, x2, l), p.lerp(y1, y2, l));\n    }\n  }\n}\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport lerpLine from \"~lib/lerpLine\";\n\nconst sketch = function(p) {\n  const GRID_SIZE = 60;\n  const SIZES = [1, 2, 3];\n  const LINES = 10;\n\n  let grid = [];\n  let w;\n  let h;\n\n  class Doodad {\n    constructor(x, y, size) {\n      this.x = x * GRID_SIZE;\n      this.y = y * GRID_SIZE;\n      this.size = size * GRID_SIZE;\n      this.lines = size * LINES;\n      this.rate = 0.03 / size;\n\n      this.drawFunc = p.random([this.square, this.triangle]);\n      this.drawFunc();\n    }\n\n    square() {\n      p.push();\n      p.translate(this.x + this.size / 2, this.y + this.size / 2);\n      p.rotate(p.random([0, p.HALF_PI, p.PI, p.HALF_PI + p.PI]));\n\n      for (let i = 0; i <= this.lines; i++) {\n        const DIST = (this.size / this.lines) * i;\n\n        lerpLine(\n          p,\n          -this.size / 2 + DIST,\n          -this.size / 2,\n          -this.size / 2 + DIST,\n          this.size / 2,\n          this.rate\n        );\n      }\n      p.pop();\n    }\n\n    triangle() {\n      p.push();\n      p.translate(this.x + this.size / 2, this.y + this.size / 2);\n      p.rotate(p.random([0, p.HALF_PI, p.PI, p.HALF_PI + p.PI]));\n\n      for (let i = 0; i <= this.lines; i++) {\n        const DIST = (this.size / this.lines) * i;\n\n        lerpLine(\n          p,\n          this.size / 2,\n          -this.size / 2 + DIST,\n          -this.size / 2 + DIST,\n          this.size / 2,\n          this.rate\n        );\n      }\n      for (let i = 0; i <= this.lines; i++) {\n        const DIST = (this.size / this.lines) * i;\n\n        lerpLine(\n          p,\n          this.size / 2 - DIST,\n          -this.size / 2,\n          -this.size / 2,\n          this.size / 2 - DIST,\n          this.rate\n        );\n      }\n      p.pop();\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, 100);\n\n    const hue = p.random(100);\n    p.background(hue, 75, 100);\n    p.stroke(hue, 50, 15);\n    p.strokeWeight(2);\n    p.strokeCap(p.ROUND);\n\n    p.noFill();\n\n    w = p.floor(p.width / GRID_SIZE);\n    h = p.floor(p.height / GRID_SIZE);\n\n    for (let xx = 0; xx < w; xx++) {\n      grid.push([]);\n      for (let yy = 0; yy < h; yy++) {\n        grid[xx].push({\n          x: xx,\n          y: yy,\n          visited: false,\n        });\n      }\n    }\n  };\n\n  p.draw = function() {\n    const { x, y } = p.random(\n      [].concat(...grid).filter(({ visited }) => !visited)\n    );\n\n    if (!grid[x][y].visited) {\n      let size = Math.max(...SIZES);\n      let overlap;\n\n      do {\n        overlap = false;\n        for (let xx = x; xx < size + x; xx++) {\n          for (let yy = y; yy < size + y; yy++) {\n            if (x + size > w || y + size > h || grid[xx][yy].visited) {\n              overlap = true;\n            }\n          }\n        }\n        if (overlap) {\n          size = Math.max(...SIZES.filter(s => s < size));\n        }\n      } while (overlap);\n\n      new Doodad(x, y, size);\n\n      for (let xx = x; xx < size + x; xx++) {\n        for (let yy = y; yy < size + y; yy++) {\n          grid[xx][yy].visited = true;\n        }\n      }\n    }\n\n    if (![].concat(...grid).filter(({ visited }) => !visited).length) {\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}