{"version":3,"sources":["webpack:///./src/pages/sketch/2019/07/16.js","webpack:///./src/lib/polarToCartesian.js"],"names":["RENDER","process","DEV","sketch","p","setup","pixelDensity","frameRate","createCanvas","strokeWeight","createLoop","gif","render","open","noiseRadius","draw","blendMode","BLEND","background","SCREEN","NOISE","animLoop","noise","i","push","noFill","stroke","translate","width","height","rotate","TWO_PI","theta","ellipse","polarToCartesian","map","sin","cos","pop","location","path","pathname","description","polarToCartesianX","center","angle","distance","Math","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y"],"mappings":"49BAKA,IAAMA,EAASC,GAAYC,MAAO,EAE5BC,EAAS,SAASC,GACtBA,EAAEC,MAAQ,WACJL,IACFI,EAAEE,aAAa,GACfF,EAAEG,UAAU,KAGdH,EAAEI,aAAa,IAAK,KACpBJ,EAAEK,aAAa,IAEfL,EAAEM,WAAW,GAAI,CACfC,MAAKX,GAAS,CAAEY,QAAQ,EAAOC,MAAM,GACrCC,YAAa,MAIjBV,EAAEW,KAAO,WACPX,EAAEY,UAAUZ,EAAEa,OACdb,EAAEc,WAAW,GACbd,EAAEY,UAAUZ,EAAEe,QAId,IAFA,IAAMC,EAAQhB,EAAEiB,SAASC,QAAU,EAE1BC,EAAI,EAAGA,EAAI,GAAIA,IACtBnB,EAAEoB,OACFpB,EAAEqB,SACFrB,EAAEsB,OAAO,CAAC,MAAO,QAAS,QAAQH,EAAI,IACtCnB,EAAEuB,UAAUvB,EAAEwB,MAAQ,EAAGxB,EAAEyB,OAAS,GACpCzB,EAAE0B,OAAQ1B,EAAE2B,OAAS,GAAMR,EAAInB,EAAEiB,SAASW,OAC1C5B,EAAE6B,QAAF,MAAA7B,EAAC,EACI8B,YACD,EACA,EACC9B,EAAE2B,OAAS,GAAMR,EACjBnB,EAAEwB,MAAQ,GAAMR,GACjB,IANH,QAQEhB,EAAEwB,MAAQ,EAAKxB,EAAE+B,IAAI/B,EAAEgC,IAAIhC,EAAEiB,SAASW,QAAS,EAAG,EAAGZ,EAAO,GAC5DhB,EAAEyB,OAAS,EAAKzB,EAAE+B,IAAI/B,EAAEiC,IAAIjC,EAAEiB,SAASW,QAAS,EAAG,EAAG,EAAGZ,MAE5DhB,EAAEkC,QAgBO,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAcpC,OAAQA,EAAQqC,KAAMD,EAASE,SAAUC,YAAY,O,kCChErE,0GAAMC,EAAoB,SAACC,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKV,IAAIQ,GAASC,GAE9BE,EAAoB,SAACJ,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKX,IAAIS,GAASC,GAsB9BG,EAA0B,SAC9BC,EACAC,EACAN,EACAO,EACAC,EACAC,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIL,EAAUH,KAAKV,IAAIQ,GAASO,EAChCI,EAAIL,EAAUJ,KAAKX,IAAIS,GAASQ,EACtC,OAAOC,EAAU,CAACC,EAAGC,GAAK,CAAED,IAAGC,MAIlBtB,IAzBU,SACvBgB,EACAC,EACAN,EACAC,EACAQ,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIZ,EAAkBO,EAASL,EAAOC,GACtCU,EAAIR,EAAkBG,EAASN,EAAOC,GAC5C,OAAOQ,EAAU,CAACC,EAAGC,GAAK,CAAED,IAAGC","file":"component---src-pages-sketch-2019-07-16-js-edc18d5b9a451d7f63fe.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport \"p5.createloop\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst RENDER = process.env.DEV && false;\n\nconst sketch = function(p) {\n  p.setup = function() {\n    if (RENDER) {\n      p.pixelDensity(1);\n      p.frameRate(30);\n    }\n\n    p.createCanvas(660, 840);\n    p.strokeWeight(10);\n\n    p.createLoop(10, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 0.1,\n    });\n  };\n\n  p.draw = function() {\n    p.blendMode(p.BLEND);\n    p.background(0);\n    p.blendMode(p.SCREEN);\n\n    const NOISE = p.animLoop.noise() + 1;\n\n    for (let i = 0; i < 33; i++) {\n      p.push();\n      p.noFill();\n      p.stroke([\"red\", \"green\", \"blue\"][i % 3]);\n      p.translate(p.width / 2, p.height / 2);\n      p.rotate((p.TWO_PI / 33) * i + p.animLoop.theta);\n      p.ellipse(\n        ...polarToCartesian(\n          0,\n          0,\n          (p.TWO_PI / 33) * i,\n          (p.width / 10) * NOISE,\n          true\n        ),\n        (p.width / 2) * p.map(p.sin(p.animLoop.theta), -1, 1, NOISE, 0),\n        (p.height / 2) * p.map(p.cos(p.animLoop.theta), -1, 1, 0, NOISE)\n      );\n      p.pop();\n    }\n  };\n\n  // p.touchMoved = function() {\n  //  if (\n  //    p.mouseX >= 0 &&\n  //    p.mouseY >= 0 &&\n  //    p.mouseX <= p.width &&\n  //    p.mouseY <= p.height\n  //  ) {\n  //    return false;\n  //  }\n  // };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}