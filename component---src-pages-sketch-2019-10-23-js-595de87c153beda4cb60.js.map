{"version":3,"sources":["webpack:///./src/pages/sketch/2019/10/23.js","webpack:///./src/lib/polarToCartesian.js"],"names":["RENDER","process","DEV","sketch","p","stripeCount","points","Array","highlightPoints","Point","i","this","_angle","random","TWO_PI","distance","width","seed","animLoop","noise1D","polarToCartesian","height","angle","setup","pixelDensity","frameRate","createCanvas","createLoop","gif","render","open","noiseRadius","noStroke","map","sin","theta","fill","_","draw","background","stripes","createGraphics","x","rect","mask","beginShape","forEach","coord","vertex","endShape","CLOSE","stripesImage","get","image","blendMode","SCREEN","BLEND","SketchPage","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","Math","cos","y","center","polarToCartesianX","polarToCartesianY"],"mappings":"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","file":"component---src-pages-sketch-2019-10-23-js-595de87c153beda4cb60.js","sourcesContent":["import React from \"react\";\nimport Layout from \"~components/layout\";\nimport Sketch from \"~components/sketch\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport \"p5.createloop\";\n\nconst POINT_COUNT = 3;\nconst RENDER = process.env.DEV && false;\n\nconst sketch = function(p) {\n  let points = Array(POINT_COUNT);\n  let highlightPoints = Array(POINT_COUNT);\n  let stripeCount;\n\n  class Point {\n    constructor(i) {\n      this._angle = p.random(p.TWO_PI * i, p.TWO_PI * (i + 1));\n      this.distance = p.width / 2;\n      this.seed = p.random(0.1);\n    }\n\n    get angle() {\n      return this._angle * p.animLoop.noise1D(this.seed);\n    }\n\n    get coord() {\n      return polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        this.angle,\n        this.distance,\n        true\n      );\n    }\n  }\n\n  p.setup = function() {\n    p.pixelDensity(1);\n    p.frameRate(30);\n    p.createCanvas(660, 840);\n    p.createLoop(49, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 0.1,\n    });\n    p.noStroke();\n\n    stripeCount = () => p.map(p.sin(p.animLoop.theta), -1, 1, 10, 40);\n\n    points = points.fill(null).map((_, i) => new Point(i));\n    highlightPoints = highlightPoints.fill(null).map((_, i) => new Point(i));\n  };\n\n  p.draw = function() {\n    p.background(255);\n\n    const stripes = p.createGraphics(p.width, p.height);\n    stripes.fill(0);\n    for (let x = 0; x < p.width; x += p.width / stripeCount()) {\n      stripes.rect(x, 0, p.width / stripeCount() / 2, p.height);\n    }\n\n    const mask = p.createGraphics(p.width, p.height);\n\n    mask.fill(0);\n    mask.beginShape();\n    points.forEach(({ coord }) => mask.vertex(...coord));\n    mask.endShape(mask.CLOSE);\n\n    const stripesImage = stripes.get();\n    stripesImage.mask(mask);\n\n    p.image(stripesImage, 0, 0);\n\n    p.blendMode(p.SCREEN);\n    p.fill(\"lightblue\");\n    p.rect(0, 0, p.width, p.height);\n    p.blendMode(p.BLEND);\n\n    for (\n      let x =\n        (p.width * -p.animLoop.theta) / p.TWO_PI + p.width / stripeCount() / 2;\n      x < p.width;\n      x += p.width / stripeCount()\n    ) {\n      p.rect(x, 0, p.width / stripeCount() / 2, p.height);\n    }\n  };\n};\n\nconst SketchPage = () => (\n  <Layout>\n    <Sketch sketch={sketch} />\n  </Layout>\n);\n\nexport default SketchPage;\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}