{"version":3,"sources":["webpack:///./src/pages/sketch/2019/08/20.js","webpack:///./node_modules/amp-is-object/is-object.js","webpack:///./node_modules/coordinate-systems/coordinate-systems.js","webpack:///./node_modules/amp-is-array/is-array.js","webpack:///./node_modules/amp-is-number/is-number.js","webpack:///./node_modules/amp-extend/extend.js","webpack:///./src/lib/easing.js"],"names":["RENDER","process","DEV","sketch","p","HUE","random","ROTATION","TWO_PI","boxes","Box","x","y","this","rotate","QUARTER_PI","rotateDirection","offset","noise","length","prevMod","prototype","draw","myTheta","animLoop","theta","HALF_PI","turnVal","map","push","translate","rotateX","ease","rotateY","rotateZ","box","GRID","pop","setup","pixelDensity","frameRate","createCanvas","WEBGL","colorMode","HSB","noStroke","createLoop","gif","render","open","noiseRadius","width","height","background","specularMaterial","pointLight","apply","concat","spherical","PI","cart","forEach","b","__webpack_exports__","_ref","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_0__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_2__","path","pathname","description","module","exports","obj","type","__webpack_require__","isArray","isNumber","isObject","extend","degPerRadian","Math","Coordinate","config","isRadian","isDegree","_x","_y","_z","_r","_t","_p","pos","defineProperty","get","set","label","coords","Error","initialType","cartesian","arguments","options","temp","cartesian2d","cartesian3d","polarToCart2d","polar","cylindrical","sphericalToCart3d","cyl","cartesian2dToPolar","center","cartesian3dToCylindrical","sphericalToCylindrical","pol","sph","cartesian3dToSpherical","cylindricalToSpherical","baseCoord","arrToNumeric","nums","num","TypeError","i","parseFloat","rt","r","t","cos","sin","xy","sqrt","atan2","xyz","z","x2","y2","z2","rtz","sr","sp","rtp","cr","toString","nativeIsArray","Array","call","source","prop","d","easeInOutQuad","easeInOutCubic","easeInOutQuart","easeInOutQuint"],"mappings":"0JAOMA,UAASC,GAAYC,MAAO,GAG5BC,EAAS,SAASC,GACtB,IACMC,EAAMD,EAAEE,OAAO,KAEfC,EAAWH,EAAEI,OADY,EAG3BC,EAAQ,GAENC,EARmB,WASvB,SAAAA,EAAYC,EAAGC,GACbC,KAAKF,EAAIA,EACTE,KAAKD,EAAIA,EACTC,KAAKC,OAASV,EAAEW,WAChBF,KAAKG,gBAAkBZ,EAAEE,OAAO,EAAE,EAAG,IACrCO,KAAKI,OAASb,EAAEc,MAAMP,EAAGC,EAAGH,EAAMU,OAAS,GAAKf,EAAEW,WAClDF,KAAKO,QAAU,EAfM,OAAAV,EAAAW,UAkBvBC,KAAA,WAAO,IAGCC,EAFYnB,EAAEoB,SAAZC,MAEgBZ,KAAKI,OAEzBM,EAAUhB,GAAYM,KAAKO,UAC7BP,KAAKC,QAAUV,EAAEsB,QAAUb,KAAKG,iBAGlC,IAAMW,EAAUvB,EAAEwB,IAAIL,EAAUhB,EAAU,EAAGH,EAAEsB,QAAS,EAAG,GAE3DtB,EAAEyB,OACFzB,EAAE0B,UAAUjB,KAAKF,EAAGE,KAAKD,EAAG,GAC5BR,EAAE2B,QACA3B,EAAEwB,IACAI,YAAKL,GACL,EACA,EACAd,KAAKC,OACLD,KAAKC,OAASV,EAAEsB,QAAUb,KAAKG,kBAGnCZ,EAAE6B,QACA7B,EAAEwB,IACAI,YAAKL,GACL,EACA,EACAd,KAAKC,OACLD,KAAKC,OAASV,EAAEsB,QAAUb,KAAKG,kBAGnCZ,EAAE8B,SACC9B,EAAEwB,IACDI,YAAKL,GACL,EACA,EACAd,KAAKC,OACLD,KAAKC,OAASV,EAAEsB,QAAUb,KAAKG,kBAGnCZ,EAAE+B,IAAIC,IACNhC,EAAEiC,MAEFxB,KAAKO,QAAUG,EAAUhB,GA7DJG,EAAA,GAiEzBN,EAAEkC,MAAQ,WACJtC,IACFI,EAAEmC,aAAa,GACfnC,EAAEoC,UAAU,KAGdpC,EAAEqC,aAAa,IAAK,IAAKrC,EAAEsC,OAC3BtC,EAAEuC,UAAUvC,EAAEwC,IAAK,KACnBxC,EAAEyC,WAEFzC,EAAE0C,WA7EW,GA6EU,CACrBC,MAAK/C,GAAS,CAAEgD,QAAQ,EAAOC,MAAM,GACrCC,YAAa,KAGf,IAAK,IAAIvC,GAAKP,EAAE+C,MAAQ,EAAGxC,EAAIP,EAAE+C,MAAQ,EAAGxC,GA/EjC,GAgFT,IAAK,IAAIC,GAAKR,EAAEgD,OAAS,EAAGxC,EAAIR,EAAEgD,OAAS,EAAGxC,GAhFrC,GAiFPH,EAAMoB,KAAK,IAAInB,EAAIC,EAAIyB,GAAUxB,EAAIwB,MAK3ChC,EAAEkB,KAAO,WACPlB,EAAEiD,WAAW,GACbjD,EAAEkD,iBAAiBjD,EAAK,IAAK,IAC7BD,EAAEmD,WAAFC,MAAApD,EAAC,CAAY,EAAG,EAAG,KAAlBqD,OAA0BC,oBAAU,CAAC,IAAM,EAAGtD,EAAEuD,KAAKC,SACtDnD,EAAMoD,QAAQ,SAAAC,GAAC,OAAIA,EAAExC,WAIVyC,EAAA,iBAAAC,GAAA,IAAGC,EAAHD,EAAGC,SAAH,OACbC,OAAAC,EAAA,EAAAD,CAACE,EAAA,EAAD,CAAcjE,OAAQA,EAAQkE,KAAMJ,EAASK,SAAUC,YAAY,yBC1GrEC,EAAAC,QAAA,SAAAC,GACA,IAAAC,SAAAD,EACA,QAAAA,IAAA,aAAAC,GAAA,WAAAA,sCCAAC,EAAQ,KAER,IAAAC,EAAcD,EAAQ,KAEtBE,EAAeF,EAAQ,KAEvBG,EAAeH,EAAQ,KAEvBI,EAAaJ,EAAQ,KAErBK,EAAA,IAAAC,KAAAvB,GAgBAwB,EAAA,SAAAC,GACA,IAAAC,EACAC,EAEAC,EACAC,EACAC,EACAC,EACAC,EACAC,EANAC,EAAA,GA0FA,GAjFA3B,OAAA4B,eAAAjF,KAAA,YACAkF,IAAA,SAAApF,GACA,OAAA0E,GAEAW,IAAA,SAAArF,GACA0E,IAAA1E,EAEA2E,KAAA3E,IACA2E,GAAA3E,MAKAuD,OAAA4B,eAAAjF,KAAA,YACAkF,IAAA,SAAApF,GACA,OAAA2E,GAEAU,IAAA,SAAArF,GACA2E,EAAA3E,EAEA0E,KAAA1E,IACA0E,GAAA1E,MAKAuD,OAAA4B,eAAAD,EAAA,eACAE,IAAA,SAAApF,GACA,OAAA4E,EAAAC,IAEAQ,IAAA,SAAArF,GACA4E,EAAA5E,EAAA,GACA6E,EAAA7E,EAAA,MAGAuD,OAAA4B,eAAAD,EAAA,eACAE,IAAA,SAAApF,GACA,OAAA4E,EAAAC,EAAAC,IAEAO,IAAA,SAAArF,GACA4E,EAAA5E,EAAA,GACA6E,EAAA7E,EAAA,GACA8E,EAAA9E,EAAA,MAGAuD,OAAA4B,eAAAD,EAAA,SACAE,IAAA,SAAApF,GACA,OAAA+E,EAAAC,IAEAK,IAAA,SAAArF,GACA+E,EAAA/E,EAAA,GACAgF,EAAAhF,EAAA,MAGAuD,OAAA4B,eAAAD,EAAA,eACAE,IAAA,SAAApF,GACA,OAAA+E,EAAAC,EAAAF,IAEAO,IAAA,SAAArF,GACA+E,EAAA/E,EAAA,GACAgF,EAAAhF,EAAA,GACA8E,EAAA9E,EAAA,MAGAuD,OAAA4B,eAAAD,EAAA,aACAE,IAAA,SAAApF,GACA,OAAA+E,EAAAC,EAAAC,IAEAI,IAAA,SAAArF,GACA+E,EAAA/E,EAAA,GACAgF,EAAAhF,EAAA,GACAiF,EAAAjF,EAAA,MAIAyE,EAAAE,WAAAF,EAAAC,SACAxE,KAAAyE,UAAA,EAEAzE,KAAAwE,UAAA,GAGAD,EAAAa,QAAAb,EAAAc,OACA,UAAAC,MAAA,8BAGAtF,KAAAuF,YAAAhB,EAAAa,MACApF,KAAAgF,MACAhF,KAAAgF,IAAAT,EAAAa,OAAAb,EAAAc,QAYAf,EAAA9D,UAAAgF,UAAA,WACA,OAAAxF,KAAA+C,KAAAJ,MAAA3C,KAAAyF,YAUAnB,EAAA9D,UAAAuC,KAAA,SAAA2C,GACA,IAAAC,EAGA,OAFAD,KAAA,GAEA1F,KAAAuF,aACA,kBACA,OAAAvF,KAAAgF,IAAAY,YAEA,kBACA,OAAA5F,KAAAgF,IAAAa,YAEA,YAEA,OADA7F,KAAAgF,IAAAY,YAAAtB,EAAAwB,cAAA9F,KAAAgF,IAAAe,MAAA/F,KAAAyE,UACAzE,KAAAgF,IAAAY,YAEA,kBAGA,OAFAD,EAAArB,EAAAwB,cAAA9F,KAAAgF,IAAAe,MAAA/F,KAAAyE,UACAzE,KAAAgF,IAAAa,YAAA,CAAAF,EAAA,GAAAA,EAAA,GAAA3F,KAAAgF,IAAAgB,YAAA,IACAhG,KAAAgF,IAAAa,YAEA,gBAEA,OADA7F,KAAAgF,IAAAa,YAAAvB,EAAA2B,kBAAAjG,KAAAgF,IAAAnC,UAAA7C,KAAAyE,UACAzE,KAAAgF,IAAAa,YAEA,QACA,UAAAP,MAAA,qDAaAhB,EAAA9D,UAAAwF,YAAA,WACA,OAAAhG,KAAAkG,IAAAvD,MAAA3C,KAAAyF,YAUAnB,EAAA9D,UAAA0F,IAAA,SAAAR,GACA,IAAAC,EAGA,OAFAD,KAAA,GAEA1F,KAAAuF,aACA,kBAGA,OAFAI,EAAArB,EAAA6B,mBAAAnG,KAAAgF,IAAAY,YAAA5F,KAAAyE,SAAAiB,EAAAU,QACApG,KAAAgF,IAAAgB,YAAA,CAAAL,EAAA,GAAAA,EAAA,MACA3F,KAAAgF,IAAAgB,YAEA,kBAEA,OADAhG,KAAAgF,IAAAgB,YAAA1B,EAAA+B,yBAAArG,KAAAgF,IAAAa,YAAA7F,KAAAyE,SAAAiB,EAAAU,QACApG,KAAAgF,IAAAgB,YAEA,YAEA,QADAL,EAAA3F,KAAAgF,IAAAe,OACA,GAAAJ,EAAA,MAEA,kBACA,OAAA3F,KAAAgF,IAAAgB,YAEA,gBAEA,OADAhG,KAAAgF,IAAAgB,YAAA1B,EAAAgC,uBAAAtG,KAAAgF,IAAAnC,UAAA7C,KAAAyE,UACAzE,KAAAgF,IAAAgB,YAEA,QACA,UAAAV,MAAA,qDAWAhB,EAAA9D,UAAA+F,IAAA,WACA,OAAAvG,KAAA+F,MAAApD,MAAA3C,KAAAyF,YAUAnB,EAAA9D,UAAAuF,MAAA,SAAAL,GAGA,OAFAA,KAAA,GAEA1F,KAAAuF,aACA,kBAEA,OADAvF,KAAAgF,IAAAe,MAAAzB,EAAA6B,mBAAAnG,KAAAgF,IAAAY,YAAA5F,KAAAyE,SAAAiB,EAAAU,QACApG,KAAAgF,IAAAe,MAEA,YACA,OAAA/F,KAAAgF,IAAAe,MAEA,QACA,UAAAT,MAAA,qDAWAhB,EAAA9D,UAAAqC,UAAA,WACA,OAAA7C,KAAAwG,IAAA7D,MAAA3C,KAAAyF,YAUAnB,EAAA9D,UAAAgG,IAAA,SAAAd,GACA,IAAAC,EAGA,OAFAD,KAAA,GAEA1F,KAAAuF,aACA,kBAGA,OAFAI,EAAArB,EAAA6B,mBAAAnG,KAAAgF,IAAAY,YAAA5F,KAAAyE,SAAAiB,EAAAU,QACApG,KAAAgF,IAAAnC,UAAA,CAAA8C,EAAA,GAAAA,EAAA,MACA3F,KAAAgF,IAAAnC,UAEA,kBAEA,OADA7C,KAAAgF,IAAAnC,UAAAyB,EAAAmC,uBAAAzG,KAAAgF,IAAAa,YAAA7F,KAAAyE,SAAAiB,EAAAU,QACApG,KAAAgF,IAAAnC,UAEA,YAEA,QADA8C,EAAA3F,KAAAgF,IAAAe,OACA,GAAAJ,EAAA,MAEA,kBAEA,OADA3F,KAAAgF,IAAAnC,UAAAyB,EAAAoC,uBAAA1G,KAAAgF,IAAAgB,YAAAhG,KAAAyE,UACAzE,KAAAgF,IAAAnC,UAEA,gBACA,OAAA7C,KAAAgF,IAAAnC,UAEA,QACA,UAAAyC,MAAA,qDAaAhB,EAAAkB,UAAA,SAAA1F,GACA,OAAAwE,EAAAvB,KAAAjD,IASAwE,EAAAvB,KAAA,SAAA2C,GACA,IAAAiB,EAQA,GANA3C,EAAA0B,KACAA,EAAA,CACAL,OAAAK,IAIAxB,EAAAwB,IAAA1B,EAAA0B,EAAAL,QAAA,CAGA,GAFAf,EAAAsC,aAAAlB,EAAAL,QAEAK,EAAAL,OAAA/E,OAAA,GAAAoF,EAAAL,OAAA/E,OAAA,EACA,UAAAgF,MAAA,qDASA,OANAqB,EAAA,CACAvB,MAAA,cACAM,UAAAL,QAEAsB,EAAAxC,EAAAwC,EAAAjB,GAEA,IAAAA,EAAAL,OAAA/E,OACA,IAAAgE,EAAAqC,IAGAA,EAAAvB,MAAA,cACA,IAAAd,EAAAqC,IAGA,UAAArB,MAAA,mDASAhB,EAAA0B,YAAA,SAAAlG,GACA,OAAAwE,EAAA4B,IAAApG,IASAwE,EAAA4B,IAAA,SAAAR,GACA,IAAAiB,EAQA,GANA3C,EAAA0B,KACAA,EAAA,CACAL,OAAAK,IAIAxB,EAAAwB,IAAA1B,EAAA0B,EAAAL,QAAA,CAGA,GAFAf,EAAAsC,aAAAlB,EAAAL,QAEA,IAAAK,EAAAL,OAAA/E,OACA,UAAAgF,MAAA,uCAQA,OALAqB,EAAA,CACAvB,MAAA,cACAC,OAAAK,EAAAL,QAEAsB,EAAAxC,EAAAwC,EAAAjB,GACA,IAAApB,EAAAqC,GAGA,UAAArB,MAAA,kDASAhB,EAAAyB,MAAA,SAAAjG,GACA,OAAAwE,EAAAiC,IAAAzG,IASAwE,EAAAiC,IAAA,SAAAb,GACA,IAAAiB,EAQA,GANA3C,EAAA0B,KACAA,EAAA,CACAL,OAAAK,IAIAxB,EAAAwB,IAAA1B,EAAA0B,EAAAL,QAAA,CAGA,GAFAf,EAAAsC,aAAAlB,EAAAL,QAEA,IAAAK,EAAAL,OAAA/E,OACA,UAAAgF,MAAA,oCAQA,OALAqB,EAAA,CACAvB,MAAA,QACAC,OAAAK,EAAAL,QAEAsB,EAAAxC,EAAAwC,EAAAjB,GACA,IAAApB,EAAAqC,GAGA,UAAArB,MAAA,qCASAhB,EAAAzB,UAAA,SAAA6C,GACA,OAAApB,EAAAkC,IAAAd,IASApB,EAAAkC,IAAA,SAAAd,GACA,IAAAiB,EAQA,GANA3C,EAAA0B,KACAA,EAAA,CACAL,OAAAK,IAIAxB,EAAAwB,IAAA1B,EAAA0B,EAAAL,QAAA,CAGA,GAFAf,EAAAsC,aAAAlB,EAAAL,QAEA,IAAAK,EAAAL,OAAA/E,OACA,UAAAgF,MAAA,uCAQA,OALAqB,EAAA,CACAvB,MAAA,YACAC,OAAAK,EAAAL,QAEAsB,EAAAxC,EAAAwC,EAAAjB,GACA,IAAApB,EAAAqC,GAGA,UAAArB,MAAA,kDAWAhB,EAAAsC,aAAA,SAAAC,GACA,IAAAC,EAEA,IAAA9C,EAAA6C,GACA,UAAAE,UAAA,wCAGA,QAAAC,EAAAH,EAAAvG,OAAA,EAA+B0G,GAAA,EAAQA,IAOvC,GAJA,iBAFAF,EAAAD,EAAAG,MAGAF,EAAAG,WAAAH,KAGA7C,EAAA6C,GACA,UAAAC,UAAAD,EAAA,iCAYAxC,EAAAwB,cAAA,SAAAoB,EAAAzC,GACA,IAAA0C,EAAAC,EAUA,OATAD,EAAAD,EAAA,GACAE,EAAAF,EAAA,GAEAzC,IACA2C,GAAA,EAAAhD,GAKA,CAFA+C,EAAA9C,KAAAgD,IAAAD,GACAD,EAAA9C,KAAAiD,IAAAF,KAcA9C,EAAA6B,mBAAA,SAAAoB,EAAA9C,EAAA2B,GACA,IAAAtG,EAAAC,EAAAoH,EAAAC,EAEA,IAAApD,EAAAuD,IAAA,IAAAA,EAAAjH,OACA,UAAAyG,UAAA,4BAMA,GAHAjH,EAAAyH,EAAA,GACAxH,EAAAwH,EAAA,GAEAnB,IAAApC,EAAAoC,IAAA,IAAAA,EAAA9F,OACA,UAAAyG,UAAA,gCAeA,OAZAX,IACAtG,GAAAsG,EAAA,GACArG,GAAAqG,EAAA,IAGAe,EAAA9C,KAAAmD,KAAA1H,IAAAC,KACAqH,EAAA/C,KAAAoD,MAAA1H,EAAAD,GAEA2E,IACA2C,GAAAhD,GAGA,CAAA+C,EAAAC,IAWA9C,EAAA+B,yBAAA,SAAAqB,EAAAjD,EAAA2B,GACA,IAGAc,EAHApH,EAAA4H,EAAA,GACA3H,EAAA2H,EAAA,GACAC,EAAAD,EAAA,GAGA,QADAR,EAAA5C,EAAA6B,mBAAA,CAAArG,EAAAC,GAAA0E,EAAA2B,IACA,GAAAc,EAAA,GAAAS,IAWArD,EAAAmC,uBAAA,SAAAiB,EAAAjD,EAAA2B,GACA,GAAAA,GAAA,IAAAA,EAAA9F,OACA,UAAAgF,MAAA,4EAGA,IAGAsC,EACAC,EACAC,EACAX,EACAC,EACA7H,EARAO,EAAA4H,EAAA,GACA3H,EAAA2H,EAAA,GACAC,EAAAD,EAAA,GA+BA,OAvBAtB,IACAtG,GAAAsG,EAAA,GACArG,GAAAqG,EAAA,GACAuB,GAAAvB,EAAA,IAGAwB,EAAA9H,IACA+H,EAAA9H,IACA+H,EAAAH,KACAR,EAAA9C,KAAAmD,KAAAI,EAAAC,EAAAC,KAKAV,EAAA/C,KAAAoD,MAAA1H,EAAAD,GACAP,EAAA8E,KAAAoD,MAAApD,KAAAmD,KAAAI,EAAAC,GAAAF,GAEAlD,IACA2C,GAAAhD,EACA7E,GAAA6E,IAPA7E,EAAA6H,EAAA,EAWA,CAAAD,EAAAC,EAAA7H,IAUA+E,EAAAoC,uBAAA,SAAAqB,EAAAtD,GACA,IAGAuD,EAAAC,EAHAd,EAAAY,EAAA,GACAX,EAAAW,EAAA,GACAJ,EAAAI,EAAA,GAeA,OAZAtD,IACA2C,GAAAhD,GAGA4D,EAAA3D,KAAAmD,KAAAL,IAAAQ,KACAM,EAAA5D,KAAAoD,MAAAN,EAAAQ,GAEAlD,IACAwD,GAAA7D,EACAgD,GAAAhD,GAGA,CAAA4D,EAAAZ,EAAAa,IAUA3D,EAAA2B,kBAAA,SAAAiC,EAAAzD,GACA,IAAA0C,EAAAe,EAAA,GACAd,EAAAc,EAAA,GACA3I,EAAA2I,EAAA,GAaA,OARAzD,IACA2C,GAAAhD,EACA7E,GAAA6E,GAMA,CAHA+C,EAAA9C,KAAAiD,IAAA/H,GAAA8E,KAAAgD,IAAAD,GACAD,EAAA9C,KAAAiD,IAAA/H,GAAA8E,KAAAiD,IAAAF,GACAD,EAAA9C,KAAAgD,IAAA9H,KAWA+E,EAAAgC,uBAAA,SAAA4B,EAAAzD,GACA,IAGA0D,EACAR,EAJAR,EAAAe,EAAA,GACAd,EAAAc,EAAA,GACA3I,EAAA2I,EAAA,GAiBA,OAbAzD,IACA2C,GAAAhD,EACA7E,GAAA6E,GAGA+D,EAAAhB,EAAA9C,KAAAiD,IAAA/H,GACAoI,EAAAR,EAAA9C,KAAAgD,IAAA9H,GAEAkF,IACA2C,GAAAhD,EACA7E,GAAA6E,GAGA,CAAA+D,EAAAf,EAAAO,IAGAhE,EAAAC,QAAAU,uBC1tBAP,EAAQ,IAERA,EAAQ,IAERA,EAAQ,IAERA,EAAQ,IAER,IAAAqE,EAAA/E,OAAA7C,UAAA4H,SACAC,EAAAC,MAAAtE,QAEAL,EAAAC,QAAAyE,GAAA,SAAAxE,GACA,yBAAAuE,EAAAG,KAAA1E,yBCZAE,EAAQ,IAERA,EAAQ,IAERA,EAAQ,IAER,IAAAqE,EAAA/E,OAAA7C,UAAA4H,SAEAzE,EAAAC,QAAA,SAAAC,GACA,0BAAAuE,EAAAG,KAAA1E,yBCTA,IAAAK,EAAeH,EAAQ,KAEvBJ,EAAAC,QAAA,SAAAC,GACA,IAAAK,EAAAL,GAAA,OAAAA,EAGA,IAFA,IAAA2E,EAAAC,EAEAzB,EAAA,EAAA1G,EAAAmF,UAAAnF,OAA4C0G,EAAA1G,EAAY0G,IAGxD,IAAAyB,KAFAD,EAAA/C,UAAAuB,GAGAnD,EAAA4E,GAAAD,EAAAC,GAIA,OAAA5E,qCCdAE,EAAA2E,EAAAxF,EAAA,sBAAAyF,IAAA5E,EAAA2E,EAAAxF,EAAA,sBAAA0F,IAAA7E,EAAA2E,EAAAxF,EAAA,sBAAA2F,IAAA9E,EAAA2E,EAAAxF,EAAA,sBAAA4F,IAGA,IASMH,EAAgB,SAAAvB,GAAC,OAAKA,EAAI,GAAM,EAAIA,EAAIA,GAAU,EAAI,EAAIA,GAAKA,EAAlB,GAS7CwB,EAAiB,SAAAxB,GAAC,OACtBA,EAAI,GAAM,EAAIA,EAAIA,EAAIA,GAAKA,EAAI,IAAM,EAAIA,EAAI,IAAM,EAAIA,EAAI,GAAK,GAS5DyB,EAAiB,SAAAzB,GAAC,OACtBA,EAAI,GAAM,EAAIA,EAAIA,EAAIA,EAAIA,EAAI,EAAI,IAAMA,EAAIA,EAAIA,EAAIA,GAShD0B,EAAiB,SAAA1B,GAAC,OACtBA,EAAI,GAAM,GAAKA,EAAIA,EAAIA,EAAIA,EAAIA,EAAI,EAAI,KAAOA,EAAIA,EAAIA,EAAIA,EAAIA","file":"component---src-pages-sketch-2019-08-20-js-7215b8338d1fc27cc8a8.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport \"p5.createloop\";\nimport { spherical } from \"coordinate-systems\";\nimport { easeInOutQuint as ease } from \"~lib/easing\";\nimport Link from \"~components/link\";\n\nconst RENDER = process.env.DEV && true;\nconst DURATION = 20;\n\nconst sketch = function(p) {\n  const GRID = 30;\n  const HUE = p.random(100);\n  const ROTATIONS_PER_DURATION = 4;\n  const ROTATION = p.TWO_PI / ROTATIONS_PER_DURATION;\n\n  let boxes = [];\n\n  class Box {\n    constructor(x, y) {\n      this.x = x;\n      this.y = y;\n      this.rotate = p.QUARTER_PI;\n      this.rotateDirection = p.random([-1, 1]);\n      this.offset = p.noise(x, y, boxes.length + 1) * p.QUARTER_PI;\n      this.prevMod = 0;\n    }\n\n    draw() {\n      const { theta } = p.animLoop;\n\n      const myTheta = theta + this.offset;\n\n      if (myTheta % ROTATION <= this.prevMod) {\n        this.rotate += p.HALF_PI * this.rotateDirection;\n      }\n\n      const turnVal = p.map(myTheta % ROTATION, 0, p.HALF_PI, 0, 1);\n\n      p.push();\n      p.translate(this.x, this.y, 0);\n      p.rotateX(\n        p.map(\n          ease(turnVal),\n          0,\n          1,\n          this.rotate,\n          this.rotate + p.HALF_PI * this.rotateDirection\n        )\n      );\n      p.rotateY(\n        p.map(\n          ease(turnVal),\n          0,\n          1,\n          this.rotate,\n          this.rotate + p.HALF_PI * this.rotateDirection\n        )\n      );\n      p.rotateZ(\n        -p.map(\n          ease(turnVal),\n          0,\n          1,\n          this.rotate,\n          this.rotate + p.HALF_PI * this.rotateDirection\n        )\n      );\n      p.box(GRID * 2);\n      p.pop();\n\n      this.prevMod = myTheta % ROTATION;\n    }\n  }\n\n  p.setup = function() {\n    if (RENDER) {\n      p.pixelDensity(1);\n      p.frameRate(30);\n    }\n\n    p.createCanvas(660, 840, p.WEBGL);\n    p.colorMode(p.HSB, 100);\n    p.noStroke();\n\n    p.createLoop(DURATION, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 0.3,\n    });\n\n    for (let x = -p.width / 2; x < p.width / 2; x += GRID) {\n      for (let y = -p.height / 2; y < p.height / 2; y += GRID) {\n        boxes.push(new Box(x + GRID / 2, y + GRID / 2));\n      }\n    }\n  };\n\n  p.draw = function() {\n    p.background(0);\n    p.specularMaterial(HUE, 100, 75);\n    p.pointLight(0, 0, 100, ...spherical([1000, 0, p.PI]).cart());\n    boxes.forEach(b => b.draw());\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","module.exports = function isObject(obj) {\n  var type = typeof obj;\n  return !!obj && (type === 'function' || type === 'object');\n};","\"use strict\";\n\nrequire(\"core-js/modules/es6.object.define-property\");\n\nvar isArray = require('amp-is-array');\n\nvar isNumber = require('amp-is-number');\n\nvar isObject = require('amp-is-object');\n\nvar extend = require('amp-extend');\n\nvar degPerRadian = 180 / Math.PI;\n/**\n * @constructor Coordinate\n * @description Defines object which can convert between coordinate systems.\n * It is recommended to use one of the Coodinate.STATIC_CONSTRUCTOR functions\n * to generate your first coordinate before conversions. e.g. Coodinate.spherical(...)\n * @param {Object} config\n * {\n *     label: 'type of initial coordinate',\n *     coords: {\n *         x/y/z/r/t/p: 'k-v pairs'\n *     },\n *     isDegree: Boolean\n * }\n */\n\nvar Coordinate = function Coordinate(config) {\n  var isRadian,\n      isDegree,\n      pos = {},\n      _x,\n      _y,\n      _z,\n      _r,\n      _t,\n      _p; // Override select setters/getts\n\n\n  Object.defineProperty(this, \"isRadian\", {\n    get: function get(x) {\n      return isRadian;\n    },\n    set: function set(x) {\n      isRadian = !!x;\n\n      if (isDegree !== !x) {\n        isDegree = !x;\n      } // jshint ignore:line\n\n    }\n  });\n  Object.defineProperty(this, \"isDegree\", {\n    get: function get(x) {\n      return isDegree;\n    },\n    set: function set(x) {\n      isDegree = x;\n\n      if (isRadian !== !x) {\n        isRadian = !x;\n      } // jshint ignore:line\n\n    }\n  });\n  Object.defineProperty(pos, \"cartesian2d\", {\n    get: function get(x) {\n      return [_x, _y];\n    },\n    set: function set(x) {\n      _x = x[0];\n      _y = x[1];\n    }\n  });\n  Object.defineProperty(pos, \"cartesian3d\", {\n    get: function get(x) {\n      return [_x, _y, _z];\n    },\n    set: function set(x) {\n      _x = x[0];\n      _y = x[1];\n      _z = x[2];\n    }\n  });\n  Object.defineProperty(pos, \"polar\", {\n    get: function get(x) {\n      return [_r, _t];\n    },\n    set: function set(x) {\n      _r = x[0];\n      _t = x[1];\n    }\n  });\n  Object.defineProperty(pos, \"cylindrical\", {\n    get: function get(x) {\n      return [_r, _t, _z];\n    },\n    set: function set(x) {\n      _r = x[0];\n      _t = x[1];\n      _z = x[2];\n    }\n  });\n  Object.defineProperty(pos, \"spherical\", {\n    get: function get(x) {\n      return [_r, _t, _p];\n    },\n    set: function set(x) {\n      _r = x[0];\n      _t = x[1];\n      _p = x[2];\n    }\n  }); // init from config\n\n  if (config.isDegree && !config.isRadian) {\n    this.isDegree = true;\n  } else {\n    this.isRadian = true;\n  }\n\n  if (!config.label || !config.coords) {\n    throw new Error(\"no coordinate type defined\");\n  }\n\n  this.initialType = config.label;\n  this.pos = pos;\n  this.pos[config.label] = config.coords;\n};\n/**\n * @method cartesian\n * Converts current coordinate to cartesian\n * @function cartesian\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cartesian = function () {\n  return this.cart.apply(this, arguments);\n};\n/**\n * @method cart\n * Converts current coordinate to cartesian\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cart = function (options) {\n  var temp;\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      return this.pos.cartesian2d;\n\n    case 'cartesian3d':\n      return this.pos.cartesian3d;\n\n    case 'polar':\n      this.pos.cartesian2d = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n      return this.pos.cartesian2d;\n\n    case 'cylindrical':\n      temp = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n      this.pos.cartesian3d = [temp[0], temp[1], this.pos.cylindrical[2]];\n      return this.pos.cartesian3d;\n\n    case 'spherical':\n      this.pos.cartesian3d = Coordinate.sphericalToCart3d(this.pos.spherical, this.isDegree);\n      return this.pos.cartesian3d;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n};\n/**\n * @method cylindrical\n * Converts current coordinate to cylindrical\n * @function cylindrical\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cylindrical = function () {\n  return this.cyl.apply(this, arguments);\n};\n/**\n * @method cyl\n * Converts current coordinate to cylindrical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cyl = function (options) {\n  var temp;\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n      this.pos.cylindrical = [temp[0], temp[1], 0];\n      return this.pos.cylindrical;\n\n    case 'cartesian3d':\n      this.pos.cylindrical = Coordinate.cartesian3dToCylindrical(this.pos.cartesian3d, this.isDegree, options.center);\n      return this.pos.cylindrical;\n\n    case 'polar':\n      temp = this.pos.polar;\n      return [temp[0], temp[1], 0];\n\n    case 'cylindrical':\n      return this.pos.cylindrical;\n\n    case 'spherical':\n      this.pos.cylindrical = Coordinate.sphericalToCylindrical(this.pos.spherical, this.isDegree);\n      return this.pos.cylindrical;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n};\n/**\n * @method pol\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.pol = function () {\n  return this.polar.apply(this, arguments);\n};\n/**\n * @method polar\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.polar = function (options) {\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      this.pos.polar = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n      return this.pos.polar;\n\n    case 'polar':\n      return this.pos.polar;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n};\n/**\n * @method spherical\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.spherical = function () {\n  return this.sph.apply(this, arguments);\n};\n/**\n * @method sph\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.sph = function (options) {\n  var temp;\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n      this.pos.spherical = [temp[0], temp[1], 0];\n      return this.pos.spherical;\n\n    case 'cartesian3d':\n      this.pos.spherical = Coordinate.cartesian3dToSpherical(this.pos.cartesian3d, this.isDegree, options.center);\n      return this.pos.spherical;\n\n    case 'polar':\n      temp = this.pos.polar;\n      return [temp[0], temp[1], 0];\n\n    case 'cylindrical':\n      this.pos.spherical = Coordinate.cylindricalToSpherical(this.pos.cylindrical, this.isDegree);\n      return this.pos.spherical;\n\n    case 'spherical':\n      return this.pos.spherical;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n}; ///\n/// Static Constructor Functions\n///\n\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cartesian = function (x) {\n  return Coordinate.cart(x);\n};\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cart = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length < 2 || options.coords.length > 3) {\n      throw new Error('expected exactly 2 or exactly 3 cartesian options');\n    }\n\n    baseCoord = {\n      label: 'cartesian2d',\n      options: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n\n    if (options.coords.length === 2) {\n      return new Coordinate(baseCoord);\n    }\n\n    baseCoord.label = 'cartesian3d';\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected options w/ array of [x,y,(z?)] coords');\n};\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cylindrical = function (x) {\n  return Coordinate.cyl(x);\n};\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cyl = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length !== 3) {\n      throw new Error('expected exactly 3 params [r, t, z]');\n    }\n\n    baseCoord = {\n      label: 'cylindrical',\n      coords: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected options w/ array of [r, t, z] coords');\n};\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.polar = function (x) {\n  return Coordinate.pol(x);\n};\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.pol = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length !== 2) {\n      throw new Error('expected exactly 2 params [r, t]');\n    }\n\n    baseCoord = {\n      label: 'polar',\n      coords: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected array of [r, t] options');\n};\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.spherical = function (options) {\n  return Coordinate.sph(options);\n};\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.sph = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length !== 3) {\n      throw new Error('expected exactly 3 params [r, t, p]');\n    }\n\n    baseCoord = {\n      label: 'spherical',\n      coords: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected options w/ array of [r, t, p] coords');\n};\n/**\n * Mutates an array of number-like looking values to purely numeric array\n * @example\n * [5, '2.4', '0'] => [5, 2.4, 0]\n * @param  {Array} nums\n * @return {undefined}\n */\n\n\nCoordinate.arrToNumeric = function (nums) {\n  var num;\n\n  if (!isArray(nums)) {\n    throw new TypeError(\"expected array of number-like values\");\n  }\n\n  for (var i = nums.length - 1; i >= 0; i--) {\n    num = nums[i];\n\n    if (typeof num === 'string') {\n      num = parseFloat(num);\n    }\n\n    if (!isNumber(num)) {\n      throw new TypeError(num + ' not numeric or numeric-like');\n    }\n  }\n};\n/**\n * Convert polar to 2d cartesian coordinates\n * @param  {Array}   rt        [radis, theta]\n * @param  {Boolean} isDegree specifies units\n * @return {Array}  [x, y]\n */\n\n\nCoordinate.polarToCart2d = function (rt, isDegree) {\n  var r, t, x, y;\n  r = rt[0];\n  t = rt[1];\n\n  if (isDegree) {\n    t = t * (1 / degPerRadian);\n  }\n\n  x = r * Math.cos(t);\n  y = r * Math.sin(t);\n  return [x, y];\n};\n/**\n * Convert cartesian 2d to polar coordinates\n * @param  {Array}  xy\n * @param {Boolean=} isDegree overrides default radian theta assumption\n * @param  {Array=} center [x, y] coords of center of circle.  Defaults to [0, 0],\n * however may be offset.  Note. Such functionality not supported yet for converting\n * polar to cartesian\n * @return {Array}  [radius, theta]\n */\n\n\nCoordinate.cartesian2dToPolar = function (xy, isDegree, center) {\n  var x, y, r, t;\n\n  if (!isArray(xy) && xy.length !== 2) {\n    throw new TypeError('expected [x, y] xy array');\n  }\n\n  x = xy[0];\n  y = xy[1];\n\n  if (center && !isArray(center) && center.length !== 2) {\n    throw new TypeError('expected [x, y] center array');\n  }\n\n  if (center) {\n    x = x - center[0];\n    y = y - center[1];\n  }\n\n  r = Math.sqrt(x * x + y * y);\n  t = Math.atan2(y, x);\n\n  if (isDegree) {\n    t = t * degPerRadian;\n  }\n\n  return [r, t];\n};\n/**\n * Convert 3d cartesian to 3d cylindrical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y] coords of center of circle\n * @return {Array}      [radius, theta, z]\n */\n\n\nCoordinate.cartesian3dToCylindrical = function (xyz, isDegree, center) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      rt;\n  rt = Coordinate.cartesian2dToPolar([x, y], isDegree, center);\n  return [rt[0], rt[1], z];\n};\n/**\n * Convert 3d cartesian to 3d spherical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y, z] coords of center of circle\n * @return {Array}      [radius, theta, phi]\n */\n\n\nCoordinate.cartesian3dToSpherical = function (xyz, isDegree, center) {\n  if (center && center.length !== 3) {\n    throw new Error('expected center value to have [x, y, z] coords' + 'for locating sphere center');\n  }\n\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      x2,\n      y2,\n      z2,\n      r,\n      t,\n      p;\n\n  if (center) {\n    x = x - center[0];\n    y = y - center[1];\n    z = z - center[2];\n  }\n\n  x2 = x * x;\n  y2 = y * y;\n  z2 = z * z;\n  r = Math.sqrt(x2 + y2 + z2);\n\n  if (!r) {\n    p = t = 0;\n  } else {\n    t = Math.atan2(y, x);\n    p = Math.atan2(Math.sqrt(x2 + y2), z);\n\n    if (isDegree) {\n      t = t * degPerRadian;\n      p = p * degPerRadian;\n    }\n  }\n\n  return [r, t, p];\n};\n/**\n * Convert a cylindrical to a spherical coordinates\n * @param  {Array}   rtz\n * @param  {Boolean} isDegree\n * @return {Array}   [radius, theta, phi]\n */\n\n\nCoordinate.cylindricalToSpherical = function (rtz, isDegree) {\n  var r = rtz[0],\n      t = rtz[1],\n      z = rtz[2];\n  var sr, sp; // sphere radius, sphere theta...\n\n  if (isDegree) {\n    t = t / degPerRadian;\n  }\n\n  sr = Math.sqrt(r * r + z * z);\n  sp = Math.atan2(r, z);\n\n  if (isDegree) {\n    sp = sp * degPerRadian;\n    t = t * degPerRadian;\n  }\n\n  return [sr, t, sp];\n};\n/**\n * Convert spherical to a cartesian coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\n\n\nCoordinate.sphericalToCart3d = function (rtp, isDegree) {\n  var r = rtp[0],\n      t = rtp[1],\n      p = rtp[2],\n      x,\n      y,\n      z;\n\n  if (isDegree) {\n    t = t / degPerRadian;\n    p = p / degPerRadian;\n  }\n\n  x = r * Math.sin(p) * Math.cos(t);\n  y = r * Math.sin(p) * Math.sin(t);\n  z = r * Math.cos(p);\n  return [x, y, z];\n};\n/**\n * Convert spherical to cylindrical coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\n\n\nCoordinate.sphericalToCylindrical = function (rtp, isDegree) {\n  var r = rtp[0],\n      t = rtp[1],\n      p = rtp[2],\n      cr,\n      z;\n\n  if (isDegree) {\n    t = t / degPerRadian;\n    p = p / degPerRadian;\n  }\n\n  cr = r * Math.sin(p);\n  z = r * Math.cos(p);\n\n  if (isDegree) {\n    t = t * degPerRadian;\n    p = p * degPerRadian;\n  }\n\n  return [cr, t, z];\n};\n\nmodule.exports = Coordinate;","require(\"core-js/modules/es6.array.is-array\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nvar toString = Object.prototype.toString;\nvar nativeIsArray = Array.isArray;\n\nmodule.exports = nativeIsArray || function isArray(obj) {\n  return toString.call(obj) === '[object Array]';\n};","require(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nvar toString = Object.prototype.toString;\n\nmodule.exports = function isNumber(obj) {\n  return toString.call(obj) === '[object Number]';\n};","var isObject = require('amp-is-object');\n\nmodule.exports = function (obj) {\n  if (!isObject(obj)) return obj;\n  var source, prop;\n\n  for (var i = 1, length = arguments.length; i < length; i++) {\n    source = arguments[i];\n\n    for (prop in source) {\n      obj[prop] = source[prop];\n    }\n  }\n\n  return obj;\n};","// https://gist.github.com/gre/1650294\n\n// no easing, no acceleration\nconst linear = t => t;\n\n// accelerating from zero velocity\nconst easeInQuad = t => t * t;\n\n// decelerating to zero velocity\nconst easeOutQuad = t => t * (2 - t);\n\n// acceleration until halfway, then deceleration\nconst easeInOutQuad = t => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);\n\n// accelerating from zero velocity\nconst easeInCubic = t => t * t * t;\n\n// decelerating to zero velocity\nconst easeOutCubic = t => --t * t * t + 1;\n\n// acceleration until halfway, then deceleration\nconst easeInOutCubic = t =>\n  t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\n// accelerating from zero velocity\nconst easeInQuart = t => t * t * t * t;\n\n// decelerating to zero velocity\nconst easeOutQuart = t => 1 - --t * t * t * t;\n\n// acceleration until halfway, then deceleration\nconst easeInOutQuart = t =>\n  t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n\n// accelerating from zero velocity\nconst easeInQuint = t => t * t * t * t * t;\n\n// decelerating to zero velocity\nconst easeOutQuint = t => 1 + --t * t * t * t * t;\n\n// acceleration until halfway, then deceleration\nconst easeInOutQuint = t =>\n  t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n\nexport {\n  linear,\n  easeInQuad,\n  easeOutQuad,\n  easeInOutQuad,\n  easeInCubic,\n  easeOutCubic,\n  easeInOutCubic,\n  easeInQuart,\n  easeOutQuart,\n  easeInOutQuart,\n  easeInQuint,\n  easeOutQuint,\n  easeInOutQuint,\n};\n"],"sourceRoot":""}