{"version":3,"sources":["webpack:///./src/pages/sketch/2018/12/30.js"],"names":["sketch","p","maxSize","minSize","circles","increment","noDrawCount","Circle","distance","this","angle","frameCount","r","constrain","noise","_setXY","x","width","cos","y","height","sin","setDistance","increaseDistance","isOnCanvas","draw","ellipse","setup","createCanvas","random","push","fill","stroke","background","noLoop","forEach","c","noStroke","rect","text","pop","newCircle","strokeWeight","line","some","dist","max","location","path","pathname","description"],"mappings":"oIAGMA,EAAS,SAASC,GACtB,IAAIC,EACAC,EACAC,EAAU,GACVC,EAAY,EACZC,EAAc,EAGZC,EARmB,WASvB,WAAYC,QAAc,IAAdA,MAAW,GACrBC,KAAKD,SAAWA,EAChBC,KAAKC,MAAQT,EAAEU,WAAaN,EAC5BI,KAAKG,EAAIX,EAAEY,UAAUZ,EAAEa,MAAML,KAAKC,OAASR,EAASC,EAASD,GAC7DO,KAAKM,SAbgB,2BAevBA,OAAA,WACEN,KAAKO,EAAIf,EAAEgB,MAAQ,EAAIhB,EAAEiB,IAAIT,KAAKC,OAASD,KAAKD,SAChDC,KAAKU,EAAIlB,EAAEmB,OAAS,EAAInB,EAAEoB,IAAIZ,KAAKC,OAASD,KAAKD,UAjB5B,EAmBvBc,YAAA,SAAYd,GACVC,KAAKD,SAAWA,EAChBC,KAAKM,UArBgB,EAuBvBQ,iBAAA,WACEd,KAAKD,UAAY,EACjBC,KAAKM,UAzBgB,EA2BvBS,WAAA,WACE,OACEf,KAAKO,EAAIP,KAAKG,GACdH,KAAKO,EAAIf,EAAEgB,MAAQR,KAAKG,GACxBH,KAAKU,EAAIV,KAAKG,GACdH,KAAKU,EAAIlB,EAAEmB,OAASX,KAAKG,GAhCN,EAmCvBa,KAAA,WACExB,EAAEyB,QAAQjB,KAAKO,EAAGP,KAAKU,EAAY,EAATV,KAAKG,IApCV,KAwCzBX,EAAE0B,MAAQ,WACR1B,EAAE2B,aAAa,IAAK,KACpB1B,EAAUD,EAAE4B,OAAO5B,EAAEgB,MAAQ,EAAGhB,EAAEgB,MAAQ,GAC1Cd,EAAU,EACVC,EAAQ0B,KAAK,IAAIvB,GACjBN,EAAE8B,KAAK,GACP9B,EAAE+B,OAAO,GACT5B,EAAQ,GAAGQ,EAAIV,EACfE,EAAQ,GAAGqB,QAGbxB,EAAEwB,KAAO,WACPxB,EAAEgC,WAAW,KACT/B,IAAYC,GA/CA,OA+CWG,GACzBL,EAAEiC,SAEJ9B,EAAQ+B,SAAQ,SAAAC,GAAC,OAAIA,EAAEX,UACnBnB,EAnDY,OAoDdL,EAAE6B,OACF7B,EAAEoC,WACFpC,EAAE8B,KAAK,KACP9B,EAAEqC,KAAK,EAAG,EAAG,GAAI,IACjBrC,EAAE8B,KAAK,GACP9B,EAAEsC,KAAQjC,EAAV,QAAwC,GAAI,IAC5CL,EAAEuC,OAEJ,IAAMC,EAAY,IAAIlC,EActB,IAbAkC,EAAUnB,YAAYlB,EAAQ,GAAGQ,EAAI6B,EAAU7B,GAC3CN,EA9DY,OA+DdL,EAAE6B,OACF7B,EAAE+B,OAAO,OACT/B,EAAEyC,aAAa,GACfzC,EAAE0C,KACA1C,EAAEgB,MAAQ,EACVhB,EAAEmB,OAAS,EACXnB,EAAEgB,MAAQ,EAAIhB,EAAEiB,IAAIuB,EAAU/B,OAAST,EAAEmB,OACzCnB,EAAEmB,OAAS,EAAInB,EAAEoB,IAAIoB,EAAU/B,OAAST,EAAEmB,QAE5CnB,EAAEuC,OAGFpC,EAAQwC,MACN,SAAAR,GAAC,OAAInC,EAAE4C,KAAKJ,EAAUzB,EAAGyB,EAAUtB,EAAGiB,EAAEpB,EAAGoB,EAAEjB,GAAKsB,EAAU7B,EAAIwB,EAAExB,MAGpE6B,EAAUlB,mBAERkB,EAAUjB,cACZpB,EAAQ0B,KAAKW,GACTvC,EAAUC,IAASE,GAAa,GACpCC,EAAc,IAEdJ,EAAUD,EAAE6C,IAAI5C,EAAU,GAAKC,GAC/BE,EAAYH,EAAUC,EAAUF,EAAE6C,IAAI,EAAGzC,EAAY,GAAKA,EAC1DC,OAKS,0BAAGyC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAc/C,OAAQA,EAAQgD,KAAMD,EAASE,SAAUC,YAAY","file":"component---src-pages-sketch-2018-12-30-js-f6d7a2a09fbaa7252994.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\n\nconst sketch = function(p) {\n  let maxSize;\n  let minSize;\n  let circles = [];\n  let increment = 1;\n  let noDrawCount = 0;\n  let noDrawLimit = 1500;\n\n  class Circle {\n    constructor(distance = 0) {\n      this.distance = distance;\n      this.angle = p.frameCount / increment;\n      this.r = p.constrain(p.noise(this.angle) * maxSize, minSize, maxSize);\n      this._setXY();\n    }\n    _setXY() {\n      this.x = p.width / 2 + p.cos(this.angle) * this.distance;\n      this.y = p.height / 2 + p.sin(this.angle) * this.distance;\n    }\n    setDistance(distance) {\n      this.distance = distance;\n      this._setXY();\n    }\n    increaseDistance() {\n      this.distance += 1;\n      this._setXY();\n    }\n    isOnCanvas() {\n      return (\n        this.x > this.r &&\n        this.x < p.width - this.r &&\n        this.y > this.r &&\n        this.y < p.height - this.r\n      );\n    }\n    draw() {\n      p.ellipse(this.x, this.y, this.r * 2);\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    maxSize = p.random(p.width / 4, p.width / 3);\n    minSize = 5;\n    circles.push(new Circle());\n    p.fill(0);\n    p.stroke(0);\n    circles[0].r = maxSize;\n    circles[0].draw();\n  };\n\n  p.draw = function() {\n    p.background(255);\n    if (maxSize === minSize && noDrawCount === noDrawLimit) {\n      p.noLoop();\n    }\n    circles.forEach(c => c.draw());\n    if (noDrawCount < noDrawLimit) {\n      p.push();\n      p.noStroke();\n      p.fill(255);\n      p.rect(0, 0, 80, 30);\n      p.fill(0);\n      p.text(`${noDrawCount}/${noDrawLimit}`, 10, 20);\n      p.pop();\n    }\n    const newCircle = new Circle();\n    newCircle.setDistance(circles[0].r + newCircle.r);\n    if (noDrawCount < noDrawLimit) {\n      p.push();\n      p.stroke(\"red\");\n      p.strokeWeight(1);\n      p.line(\n        p.width / 2,\n        p.height / 2,\n        p.width / 2 + p.cos(newCircle.angle) * p.height,\n        p.height / 2 + p.sin(newCircle.angle) * p.height\n      );\n      p.pop();\n    }\n    while (\n      circles.some(\n        c => p.dist(newCircle.x, newCircle.y, c.x, c.y) < newCircle.r + c.r\n      )\n    ) {\n      newCircle.increaseDistance();\n    }\n    if (newCircle.isOnCanvas()) {\n      circles.push(newCircle);\n      if (maxSize > minSize) increment += 5;\n      noDrawCount = 0;\n    } else {\n      maxSize = p.max(maxSize - 0.1, minSize);\n      increment = maxSize > minSize ? p.max(1, increment - 1) : increment;\n      noDrawCount++;\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"Be patient. Reload page for a different variation.\" />\n);\n"],"sourceRoot":""}