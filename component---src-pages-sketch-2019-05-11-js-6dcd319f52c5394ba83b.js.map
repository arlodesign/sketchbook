{"version":3,"sources":["webpack:///./src/pages/sketch/2019/05/11.js","webpack:///./src/lib/addNoise.js"],"names":["sketch","p","w","h","GRID_SIZE","SIZES","HUE","random","BG","color","grid","Doodad","x","y","size","this","tileSize","tile","createGraphics","colorMode","HSB","background","stroke","strokeCap","PROJECT","strokeWeight","noFill","drawSmallTile","drawTile","drawBigTile","drawReallyBigTile","push","translate","rotate","HALF_PI","image","pop","_proto","prototype","arc","PI","circle","setup","createCanvas","floor","width","height","xx","yy","visited","draw","_ref","_ref3","_p$random","concat","apply","filter","_ref2","overlap","Math","max","s","_ref4","length","noLoop","__webpack_exports__","_ref5","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_0__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_2__","path","pathname","description","addNoise","intensity","PTS","console","log","i","fill","noStroke","ellipse","randomGaussian","pixelDensity"],"mappings":"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","file":"component---src-pages-sketch-2019-05-11-js-6dcd319f52c5394ba83b.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport addNoise from \"~lib/addNoise\";\n\nconst sketch = function(p) {\n  const GRID_SIZE = 30;\n  const SIZES = [1, 4, 4, 4, 4, 5, 5, 5, 6, 6];\n  const HUE = p.random(100);\n  const BG = p.color(HUE, 75, 100);\n\n  let grid = [];\n  let w;\n  let h;\n\n  class Doodad {\n    constructor(x, y, size) {\n      this.x = x * GRID_SIZE;\n      this.y = y * GRID_SIZE;\n      this.tileSize = size * GRID_SIZE;\n\n      this.tile = p.createGraphics(this.tileSize, this.tileSize);\n      this.tile.colorMode(p.HSB, 100);\n      this.tile.background(BG);\n      this.tile.stroke(100 - HUE, 25, 50);\n      this.tile.strokeCap(p.PROJECT);\n      this.tile.strokeWeight(GRID_SIZE / 5);\n      this.tile.noFill();\n\n      switch (size) {\n        case 1:\n          this.drawSmallTile();\n          break;\n\n        case 4:\n          this.drawTile();\n          break;\n\n        case 5:\n          this.drawTile();\n          this.drawBigTile();\n          break;\n\n        case 6:\n          this.drawTile();\n          this.drawReallyBigTile();\n          break;\n      }\n\n      p.push();\n      p.translate(this.x + this.tileSize / 2, this.y + this.tileSize / 2);\n      p.rotate(p.random([0, p.HALF_PI]));\n      p.image(this.tile, -this.tileSize / 2, -this.tileSize / 2);\n      p.pop();\n    }\n\n    drawSmallTile() {\n      this.tile.arc(0, 0, this.tileSize, this.tileSize, 0, p.HALF_PI);\n      this.tile.arc(\n        this.tileSize,\n        this.tileSize,\n        this.tileSize,\n        this.tileSize,\n        p.PI,\n        p.HALF_PI + p.PI\n      );\n    }\n\n    drawTile() {\n      this.tile.circle(0, 0, GRID_SIZE / 2);\n      this.tile.circle(0, this.tileSize, GRID_SIZE / 2);\n      this.tile.circle(this.tileSize, 0, GRID_SIZE / 2);\n      this.tile.circle(this.tileSize, this.tileSize, GRID_SIZE / 2);\n      this.tile.circle(0, 0, GRID_SIZE * 1.5);\n      this.tile.circle(0, this.tileSize, GRID_SIZE * 1.5);\n      this.tile.circle(this.tileSize, 0, GRID_SIZE * 1.5);\n      this.tile.circle(this.tileSize, this.tileSize, GRID_SIZE * 1.5);\n      this.tile.circle(this.tileSize / 2, this.tileSize / 2, GRID_SIZE / 2);\n    }\n\n    drawBigTile() {\n      this.tile.circle(0, 0, this.tileSize / 2);\n      this.tile.circle(this.tileSize, this.tileSize, this.tileSize / 2);\n    }\n\n    drawReallyBigTile() {\n      this.tile.circle(0, 0, GRID_SIZE * 2.5);\n      this.tile.circle(this.tileSize, this.tileSize, GRID_SIZE * 2.5);\n      this.tile.circle(0, this.tileSize, GRID_SIZE * 2.5);\n      this.tile.circle(this.tileSize, 0, GRID_SIZE * 2.5);\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.background(BG);\n\n    w = p.floor(p.width / GRID_SIZE);\n    h = p.floor(p.height / GRID_SIZE);\n\n    for (let xx = 0; xx < w; xx++) {\n      grid.push([]);\n      for (let yy = 0; yy < h; yy++) {\n        grid[xx].push({\n          x: xx,\n          y: yy,\n          visited: false,\n        });\n      }\n    }\n  };\n\n  p.draw = function() {\n    const { x, y } = p.random(\n      [].concat(...grid).filter(({ visited }) => !visited)\n    );\n\n    if (!grid[x][y].visited) {\n      let size = Math.max(...SIZES);\n      let overlap;\n\n      do {\n        overlap = false;\n        for (let xx = x; xx < size + x; xx++) {\n          for (let yy = y; yy < size + y; yy++) {\n            if (x + size > w || y + size > h || grid[xx][yy].visited) {\n              overlap = true;\n            }\n          }\n        }\n        if (overlap) {\n          size = Math.max(...SIZES.filter(s => s < size));\n        }\n      } while (overlap);\n\n      new Doodad(x, y, size);\n\n      for (let xx = x; xx < size + x; xx++) {\n        for (let yy = y; yy < size + y; yy++) {\n          grid[xx][yy].visited = true;\n        }\n      }\n    }\n\n    if (![].concat(...grid).filter(({ visited }) => !visited).length) {\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","const addNoise = (p, intensity = 0.5) => {\n  const PTS = p.width * p.height * 0.02;\n\n  console.log(PTS);\n\n  p.push();\n  for (let i = 0; i < PTS; i++) {\n    p.fill(\n      i % 2\n        ? `rgba(0, 0, 0, ${intensity})`\n        : `rgba(255, 255, 255, ${intensity})`\n    );\n    p.noStroke();\n    p.ellipse(\n      p.randomGaussian(p.width / 2, p.width / 3),\n      p.randomGaussian(p.height / 2, p.height / 3),\n      1 / (p.pixelDensity() / 2)\n    );\n  }\n  p.pop();\n};\n\nexport default addNoise;\n"],"sourceRoot":""}