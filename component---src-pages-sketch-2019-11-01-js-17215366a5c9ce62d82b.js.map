{"version":3,"sources":["webpack:///./src/pages/sketch/2019/11/01.js","webpack:///./src/lib/polarToCartesian.js","webpack:///./src/lib/lerpLine.js"],"names":["RENDER","process","DEV","sketch","p","vRadius","hRadius","H1","random","H2","H3","setup","pixelDensity","createCanvas","background","createLoop","gif","render","open","noiseRadius","blendMode","MULTIPLY","colorMode","HSL","height","width","draw","animLoop","theta","noise1D","noise2D","translate","polarToCartesian","color","forEach","c","i","stroke","line","polarToCartesianEllipse","TWO_PI","map","lerpLine","sin","SketchPage","centerX","centerY","angle","radiusX","radiusY","asArray","x","Math","cos","y","distance","center","polarToCartesianX","polarToCartesianY","x1","y1","x2","y2","rate","showFirstDot","Error","l","point","lerp"],"mappings":"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","file":"component---src-pages-sketch-2019-11-01-js-17215366a5c9ce62d82b.js","sourcesContent":["import React from \"react\";\nimport Layout from \"~components/layout\";\nimport Sketch from \"~components/sketch\";\nimport polarToCartesian, {\n  polarToCartesianEllipse,\n} from \"~lib/polarToCartesian\";\nimport \"p5.createloop\";\nimport lerpLine from \"~lib/lerpLine\";\n\nconst RENDER = process.env.DEV && false;\n\nconst sketch = function(p) {\n  const H1 = p.random(120);\n  const H2 = p.random(120, 240);\n  const H3 = p.random(240, 360);\n  let vRadius;\n  let hRadius;\n\n  p.setup = function() {\n    p.pixelDensity(RENDER ? 1 : 2);\n    p.createCanvas(660, 840);\n    p.background(255);\n\n    p.createLoop(120, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 1,\n    });\n\n    p.blendMode(p.MULTIPLY);\n    p.colorMode(p.HSL, 360);\n\n    vRadius = p.height / 2 - p.width * 0.1;\n    hRadius = p.width / 2 - p.width * 0.1;\n  };\n\n  p.draw = function() {\n    const { theta, noise1D, noise2D } = p.animLoop;\n\n    p.translate(\n      ...polarToCartesian(p.width / 2, p.height / 2, theta, p.width * 0.1, true)\n    );\n\n    [\n      p.color(H1, 360, 180, 180),\n      p.color(H2, 360, 180, 180),\n      p.color(H3, 360, 180, 180),\n    ].forEach((c, i) => {\n      p.stroke(c);\n\n      p.line(\n        ...polarToCartesianEllipse(\n          0,\n          0,\n          theta + (p.TWO_PI / 3) * i,\n          p.map(noise1D(i / 1000 + 0.005), -1, 1, 0.1, 1) * hRadius,\n          p.map(noise1D(1 / 1000 + 0.004), -1, 1, 0.1, 1) * vRadius,\n          true\n        ),\n        ...polarToCartesian(\n          0,\n          0,\n          theta + (p.TWO_PI / 3) * i,\n          p.map(noise1D(1 / 1000 + 0.003), -1, 1, 0.1, 2) * hRadius,\n          true\n        )\n      );\n\n      lerpLine(\n        p,\n        ...polarToCartesianEllipse(\n          0,\n          0,\n          theta + (p.TWO_PI / 3) * (i + 1.5),\n          p.map(noise1D(i / 1000 + 0.005), -1, 1, 0.1, 1) * hRadius,\n          p.map(noise1D(1 / 1000 + 0.004), -1, 1, 0.1, 1) * vRadius,\n          true\n        ),\n        ...polarToCartesian(\n          0,\n          0,\n          theta + (p.TWO_PI / 3) * (i + 1.5),\n          p.map(noise1D(1 / 1000 + 0.003), -1, 1, 0.1, 2) * hRadius,\n          true\n        ),\n        p.map(noise2D(1 / 1000 + 0.002, p.sin(theta)), -1, 1, 0.1, 0.5)\n      );\n    });\n  };\n};\n\nconst SketchPage = () => (\n  <Layout>\n    <Sketch sketch={sketch} />\n  </Layout>\n);\n\nexport default SketchPage;\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","export default function(p, x1, y1, x2, y2, rate, showFirstDot = true) {\n  if (rate <= 0)\n    throw new Error(\"rate for lerpLine() must be greater than zero\");\n\n  for (let l = 0; l < 1; l += rate) {\n    if (l === 0 && !showFirstDot) continue;\n    p.random() > l && p.point(p.lerp(x1, x2, l), p.lerp(y1, y2, l));\n  }\n}\n"],"sourceRoot":""}