{"version":3,"sources":["webpack:///./src/pages/sketch/2019/06/23.js","webpack:///./node_modules/amp-is-object/is-object.js","webpack:///./node_modules/coordinate-systems/coordinate-systems.js","webpack:///./node_modules/amp-is-array/is-array.js","webpack:///./node_modules/amp-is-number/is-number.js","webpack:///./node_modules/amp-extend/extend.js"],"names":["sketch","p","colors","colorFunctions","angle","abs","sin","cos","tan","setup","createCanvas","WEBGL","noStroke","Array","from","Set","length","random","draw","C","map","c","frameCount","background","pointLight","reverse","camera","spherical","SIZE","cart","specularMaterial","shininess","i","push","rotateX","TWO_PI","rotateY","torus","pop","location","path","pathname","description","module","exports","obj","type","isArray","isNumber","isObject","extend","degPerRadian","Math","PI","Coordinate","config","isRadian","isDegree","_x","_y","_z","_r","_t","_p","pos","Object","defineProperty","this","get","x","set","label","coords","Error","initialType","prototype","cartesian","apply","arguments","options","temp","cartesian2d","cartesian3d","polarToCart2d","polar","cylindrical","sphericalToCart3d","cyl","cartesian2dToPolar","center","cartesian3dToCylindrical","sphericalToCylindrical","pol","sph","cartesian3dToSpherical","cylindricalToSpherical","baseCoord","arrToNumeric","nums","num","TypeError","parseFloat","rt","r","t","xy","y","sqrt","atan2","xyz","z","x2","y2","z2","rtz","sr","sp","rtp","cr","toString","nativeIsArray","call","source","prop"],"mappings":"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","file":"component---src-pages-sketch-2019-06-23-js-e684f383ec5571cca271.js","sourcesContent":["import React from \"react\";\nimport { spherical } from \"coordinate-systems\";\nimport SketchLayout from \"~components/sketch-layout\";\n\nconst sketch = function(p) {\n  const SIZE = 10;\n  const SPEED = 0.25;\n\n  let colors = [];\n\n  const colorFunctions = [\n    angle => p.abs(p.sin(angle)) * 240,\n    angle => p.abs(p.cos(angle)) * 240,\n    angle => p.abs(p.tan(angle)) * 240,\n    angle => p.abs(p.sin(-angle)) * 240,\n    angle => p.abs(p.cos(-angle)) * 240,\n    angle => p.abs(p.tan(-angle)) * 240,\n    () => 240,\n    () => 15,\n    () => 128,\n  ];\n\n  p.setup = function() {\n    p.createCanvas(660, 840, p.WEBGL);\n    p.noStroke();\n    while (Array.from(new Set(colors)).length < 3) {\n      colors = [\n        p.random(colorFunctions),\n        p.random(colorFunctions),\n        p.random(colorFunctions),\n      ];\n    }\n  };\n\n  p.draw = function() {\n    const C = colors.map(c => c((p.frameCount / 200) * SPEED));\n\n    p.background(...C);\n\n    p.pointLight(\n      ...C.reverse(),\n      p.cos((p.frameCount / 200) * SPEED),\n      p.sin((p.frameCount / 100) * SPEED),\n      p.sin((p.frameCount / 100) * SPEED)\n    );\n    p.camera(\n      ...spherical([SIZE * SIZE * 2, 0, (p.frameCount / 200) * SPEED]).cart(),\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    );\n\n    p.noStroke();\n\n    p.specularMaterial(...C);\n    p.shininess(5);\n\n    for (let i = 0; i < SIZE * 2; i++) {\n      p.push();\n\n      p.rotateX((p.TWO_PI / SIZE) * i * p.sin((p.frameCount / 100) * SPEED));\n      p.rotateY((p.TWO_PI / SIZE) * i * p.cos((p.frameCount / 200) * SPEED));\n\n      p.torus(SIZE * i, SIZE / 3, 30 * i + 1);\n      p.pop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","module.exports = function isObject(obj) {\n  var type = typeof obj;\n  return !!obj && (type === 'function' || type === 'object');\n};","\"use strict\";\n\nrequire(\"core-js/modules/es6.object.define-property\");\n\nvar isArray = require('amp-is-array');\n\nvar isNumber = require('amp-is-number');\n\nvar isObject = require('amp-is-object');\n\nvar extend = require('amp-extend');\n\nvar degPerRadian = 180 / Math.PI;\n/**\n * @constructor Coordinate\n * @description Defines object which can convert between coordinate systems.\n * It is recommended to use one of the Coodinate.STATIC_CONSTRUCTOR functions\n * to generate your first coordinate before conversions. e.g. Coodinate.spherical(...)\n * @param {Object} config\n * {\n *     label: 'type of initial coordinate',\n *     coords: {\n *         x/y/z/r/t/p: 'k-v pairs'\n *     },\n *     isDegree: Boolean\n * }\n */\n\nvar Coordinate = function Coordinate(config) {\n  var isRadian,\n      isDegree,\n      pos = {},\n      _x,\n      _y,\n      _z,\n      _r,\n      _t,\n      _p; // Override select setters/getts\n\n\n  Object.defineProperty(this, \"isRadian\", {\n    get: function get(x) {\n      return isRadian;\n    },\n    set: function set(x) {\n      isRadian = !!x;\n\n      if (isDegree !== !x) {\n        isDegree = !x;\n      } // jshint ignore:line\n\n    }\n  });\n  Object.defineProperty(this, \"isDegree\", {\n    get: function get(x) {\n      return isDegree;\n    },\n    set: function set(x) {\n      isDegree = x;\n\n      if (isRadian !== !x) {\n        isRadian = !x;\n      } // jshint ignore:line\n\n    }\n  });\n  Object.defineProperty(pos, \"cartesian2d\", {\n    get: function get(x) {\n      return [_x, _y];\n    },\n    set: function set(x) {\n      _x = x[0];\n      _y = x[1];\n    }\n  });\n  Object.defineProperty(pos, \"cartesian3d\", {\n    get: function get(x) {\n      return [_x, _y, _z];\n    },\n    set: function set(x) {\n      _x = x[0];\n      _y = x[1];\n      _z = x[2];\n    }\n  });\n  Object.defineProperty(pos, \"polar\", {\n    get: function get(x) {\n      return [_r, _t];\n    },\n    set: function set(x) {\n      _r = x[0];\n      _t = x[1];\n    }\n  });\n  Object.defineProperty(pos, \"cylindrical\", {\n    get: function get(x) {\n      return [_r, _t, _z];\n    },\n    set: function set(x) {\n      _r = x[0];\n      _t = x[1];\n      _z = x[2];\n    }\n  });\n  Object.defineProperty(pos, \"spherical\", {\n    get: function get(x) {\n      return [_r, _t, _p];\n    },\n    set: function set(x) {\n      _r = x[0];\n      _t = x[1];\n      _p = x[2];\n    }\n  }); // init from config\n\n  if (config.isDegree && !config.isRadian) {\n    this.isDegree = true;\n  } else {\n    this.isRadian = true;\n  }\n\n  if (!config.label || !config.coords) {\n    throw new Error(\"no coordinate type defined\");\n  }\n\n  this.initialType = config.label;\n  this.pos = pos;\n  this.pos[config.label] = config.coords;\n};\n/**\n * @method cartesian\n * Converts current coordinate to cartesian\n * @function cartesian\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cartesian = function () {\n  return this.cart.apply(this, arguments);\n};\n/**\n * @method cart\n * Converts current coordinate to cartesian\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cart = function (options) {\n  var temp;\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      return this.pos.cartesian2d;\n\n    case 'cartesian3d':\n      return this.pos.cartesian3d;\n\n    case 'polar':\n      this.pos.cartesian2d = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n      return this.pos.cartesian2d;\n\n    case 'cylindrical':\n      temp = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n      this.pos.cartesian3d = [temp[0], temp[1], this.pos.cylindrical[2]];\n      return this.pos.cartesian3d;\n\n    case 'spherical':\n      this.pos.cartesian3d = Coordinate.sphericalToCart3d(this.pos.spherical, this.isDegree);\n      return this.pos.cartesian3d;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n};\n/**\n * @method cylindrical\n * Converts current coordinate to cylindrical\n * @function cylindrical\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cylindrical = function () {\n  return this.cyl.apply(this, arguments);\n};\n/**\n * @method cyl\n * Converts current coordinate to cylindrical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.cyl = function (options) {\n  var temp;\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n      this.pos.cylindrical = [temp[0], temp[1], 0];\n      return this.pos.cylindrical;\n\n    case 'cartesian3d':\n      this.pos.cylindrical = Coordinate.cartesian3dToCylindrical(this.pos.cartesian3d, this.isDegree, options.center);\n      return this.pos.cylindrical;\n\n    case 'polar':\n      temp = this.pos.polar;\n      return [temp[0], temp[1], 0];\n\n    case 'cylindrical':\n      return this.pos.cylindrical;\n\n    case 'spherical':\n      this.pos.cylindrical = Coordinate.sphericalToCylindrical(this.pos.spherical, this.isDegree);\n      return this.pos.cylindrical;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n};\n/**\n * @method pol\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.pol = function () {\n  return this.polar.apply(this, arguments);\n};\n/**\n * @method polar\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.polar = function (options) {\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      this.pos.polar = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n      return this.pos.polar;\n\n    case 'polar':\n      return this.pos.polar;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n};\n/**\n * @method spherical\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.spherical = function () {\n  return this.sph.apply(this, arguments);\n};\n/**\n * @method sph\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\n\n\nCoordinate.prototype.sph = function (options) {\n  var temp;\n  options = options || {};\n\n  switch (this.initialType) {\n    case 'cartesian2d':\n      temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n      this.pos.spherical = [temp[0], temp[1], 0];\n      return this.pos.spherical;\n\n    case 'cartesian3d':\n      this.pos.spherical = Coordinate.cartesian3dToSpherical(this.pos.cartesian3d, this.isDegree, options.center);\n      return this.pos.spherical;\n\n    case 'polar':\n      temp = this.pos.polar;\n      return [temp[0], temp[1], 0];\n\n    case 'cylindrical':\n      this.pos.spherical = Coordinate.cylindricalToSpherical(this.pos.cylindrical, this.isDegree);\n      return this.pos.spherical;\n\n    case 'spherical':\n      return this.pos.spherical;\n\n    default:\n      throw new Error('cannot convert to/from original/requested types');\n  }\n}; ///\n/// Static Constructor Functions\n///\n\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cartesian = function (x) {\n  return Coordinate.cart(x);\n};\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cart = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length < 2 || options.coords.length > 3) {\n      throw new Error('expected exactly 2 or exactly 3 cartesian options');\n    }\n\n    baseCoord = {\n      label: 'cartesian2d',\n      options: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n\n    if (options.coords.length === 2) {\n      return new Coordinate(baseCoord);\n    }\n\n    baseCoord.label = 'cartesian3d';\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected options w/ array of [x,y,(z?)] coords');\n};\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cylindrical = function (x) {\n  return Coordinate.cyl(x);\n};\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.cyl = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length !== 3) {\n      throw new Error('expected exactly 3 params [r, t, z]');\n    }\n\n    baseCoord = {\n      label: 'cylindrical',\n      coords: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected options w/ array of [r, t, z] coords');\n};\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.polar = function (x) {\n  return Coordinate.pol(x);\n};\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.pol = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length !== 2) {\n      throw new Error('expected exactly 2 params [r, t]');\n    }\n\n    baseCoord = {\n      label: 'polar',\n      coords: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected array of [r, t] options');\n};\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.spherical = function (options) {\n  return Coordinate.sph(options);\n};\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\n\n\nCoordinate.sph = function (options) {\n  var baseCoord;\n\n  if (isArray(options)) {\n    options = {\n      coords: options\n    };\n  }\n\n  if (isObject(options) && isArray(options.coords)) {\n    Coordinate.arrToNumeric(options.coords);\n\n    if (options.coords.length !== 3) {\n      throw new Error('expected exactly 3 params [r, t, p]');\n    }\n\n    baseCoord = {\n      label: 'spherical',\n      coords: options.coords\n    };\n    baseCoord = extend(baseCoord, options);\n    return new Coordinate(baseCoord);\n  }\n\n  throw new Error('expected options w/ array of [r, t, p] coords');\n};\n/**\n * Mutates an array of number-like looking values to purely numeric array\n * @example\n * [5, '2.4', '0'] => [5, 2.4, 0]\n * @param  {Array} nums\n * @return {undefined}\n */\n\n\nCoordinate.arrToNumeric = function (nums) {\n  var num;\n\n  if (!isArray(nums)) {\n    throw new TypeError(\"expected array of number-like values\");\n  }\n\n  for (var i = nums.length - 1; i >= 0; i--) {\n    num = nums[i];\n\n    if (typeof num === 'string') {\n      num = parseFloat(num);\n    }\n\n    if (!isNumber(num)) {\n      throw new TypeError(num + ' not numeric or numeric-like');\n    }\n  }\n};\n/**\n * Convert polar to 2d cartesian coordinates\n * @param  {Array}   rt        [radis, theta]\n * @param  {Boolean} isDegree specifies units\n * @return {Array}  [x, y]\n */\n\n\nCoordinate.polarToCart2d = function (rt, isDegree) {\n  var r, t, x, y;\n  r = rt[0];\n  t = rt[1];\n\n  if (isDegree) {\n    t = t * (1 / degPerRadian);\n  }\n\n  x = r * Math.cos(t);\n  y = r * Math.sin(t);\n  return [x, y];\n};\n/**\n * Convert cartesian 2d to polar coordinates\n * @param  {Array}  xy\n * @param {Boolean=} isDegree overrides default radian theta assumption\n * @param  {Array=} center [x, y] coords of center of circle.  Defaults to [0, 0],\n * however may be offset.  Note. Such functionality not supported yet for converting\n * polar to cartesian\n * @return {Array}  [radius, theta]\n */\n\n\nCoordinate.cartesian2dToPolar = function (xy, isDegree, center) {\n  var x, y, r, t;\n\n  if (!isArray(xy) && xy.length !== 2) {\n    throw new TypeError('expected [x, y] xy array');\n  }\n\n  x = xy[0];\n  y = xy[1];\n\n  if (center && !isArray(center) && center.length !== 2) {\n    throw new TypeError('expected [x, y] center array');\n  }\n\n  if (center) {\n    x = x - center[0];\n    y = y - center[1];\n  }\n\n  r = Math.sqrt(x * x + y * y);\n  t = Math.atan2(y, x);\n\n  if (isDegree) {\n    t = t * degPerRadian;\n  }\n\n  return [r, t];\n};\n/**\n * Convert 3d cartesian to 3d cylindrical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y] coords of center of circle\n * @return {Array}      [radius, theta, z]\n */\n\n\nCoordinate.cartesian3dToCylindrical = function (xyz, isDegree, center) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      rt;\n  rt = Coordinate.cartesian2dToPolar([x, y], isDegree, center);\n  return [rt[0], rt[1], z];\n};\n/**\n * Convert 3d cartesian to 3d spherical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y, z] coords of center of circle\n * @return {Array}      [radius, theta, phi]\n */\n\n\nCoordinate.cartesian3dToSpherical = function (xyz, isDegree, center) {\n  if (center && center.length !== 3) {\n    throw new Error('expected center value to have [x, y, z] coords' + 'for locating sphere center');\n  }\n\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      x2,\n      y2,\n      z2,\n      r,\n      t,\n      p;\n\n  if (center) {\n    x = x - center[0];\n    y = y - center[1];\n    z = z - center[2];\n  }\n\n  x2 = x * x;\n  y2 = y * y;\n  z2 = z * z;\n  r = Math.sqrt(x2 + y2 + z2);\n\n  if (!r) {\n    p = t = 0;\n  } else {\n    t = Math.atan2(y, x);\n    p = Math.atan2(Math.sqrt(x2 + y2), z);\n\n    if (isDegree) {\n      t = t * degPerRadian;\n      p = p * degPerRadian;\n    }\n  }\n\n  return [r, t, p];\n};\n/**\n * Convert a cylindrical to a spherical coordinates\n * @param  {Array}   rtz\n * @param  {Boolean} isDegree\n * @return {Array}   [radius, theta, phi]\n */\n\n\nCoordinate.cylindricalToSpherical = function (rtz, isDegree) {\n  var r = rtz[0],\n      t = rtz[1],\n      z = rtz[2];\n  var sr, sp; // sphere radius, sphere theta...\n\n  if (isDegree) {\n    t = t / degPerRadian;\n  }\n\n  sr = Math.sqrt(r * r + z * z);\n  sp = Math.atan2(r, z);\n\n  if (isDegree) {\n    sp = sp * degPerRadian;\n    t = t * degPerRadian;\n  }\n\n  return [sr, t, sp];\n};\n/**\n * Convert spherical to a cartesian coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\n\n\nCoordinate.sphericalToCart3d = function (rtp, isDegree) {\n  var r = rtp[0],\n      t = rtp[1],\n      p = rtp[2],\n      x,\n      y,\n      z;\n\n  if (isDegree) {\n    t = t / degPerRadian;\n    p = p / degPerRadian;\n  }\n\n  x = r * Math.sin(p) * Math.cos(t);\n  y = r * Math.sin(p) * Math.sin(t);\n  z = r * Math.cos(p);\n  return [x, y, z];\n};\n/**\n * Convert spherical to cylindrical coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\n\n\nCoordinate.sphericalToCylindrical = function (rtp, isDegree) {\n  var r = rtp[0],\n      t = rtp[1],\n      p = rtp[2],\n      cr,\n      z;\n\n  if (isDegree) {\n    t = t / degPerRadian;\n    p = p / degPerRadian;\n  }\n\n  cr = r * Math.sin(p);\n  z = r * Math.cos(p);\n\n  if (isDegree) {\n    t = t * degPerRadian;\n    p = p * degPerRadian;\n  }\n\n  return [cr, t, z];\n};\n\nmodule.exports = Coordinate;","require(\"core-js/modules/es6.array.is-array\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nvar toString = Object.prototype.toString;\nvar nativeIsArray = Array.isArray;\n\nmodule.exports = nativeIsArray || function isArray(obj) {\n  return toString.call(obj) === '[object Array]';\n};","require(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nvar toString = Object.prototype.toString;\n\nmodule.exports = function isNumber(obj) {\n  return toString.call(obj) === '[object Number]';\n};","var isObject = require('amp-is-object');\n\nmodule.exports = function (obj) {\n  if (!isObject(obj)) return obj;\n  var source, prop;\n\n  for (var i = 1, length = arguments.length; i < length; i++) {\n    source = arguments[i];\n\n    for (prop in source) {\n      obj[prop] = source[prop];\n    }\n  }\n\n  return obj;\n};"],"sourceRoot":""}