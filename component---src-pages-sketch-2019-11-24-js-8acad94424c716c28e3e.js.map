{"version":3,"sources":["webpack:///./node_modules/bezier-easing/src/index.js","webpack:///./src/pages/sketch/2019/11/24.js","webpack:///./src/lib/polarToCartesian.js","webpack:///./src/lib/lineIntersection.js"],"names":["float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","LinearEasing","x","module","exports","mX1","mY1","mX2","mY2","Error","sampleValues","Array","i","getTForX","aX","intervalStart","currentSample","kSplineTableSize","guessForT","initialSlope","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","Math","abs","binarySubdivide","ease","bezierEasing","sketch","p","drawing","circles","viewGuides","START","random","TWO_PI","Circle","y","rate","radius","this","centerX","centerY","_radius","direction","sizeFunction","sin","cos","draw","circle","theta","animLoop","polarToCartesian","setup","createCanvas","frameRate","createGraphics","width","height","colorMode","HSL","blendMode","HARD_LIGHT","strokeWeight","noFill","properties","shuffle","floor","push","createLoop","noiseRadius","noise1D","background","mid","map","cA","cB","lerp","position","thisPoint","lineIntersection","stroke","bezier","frameCount","image","DURATION","noLoop","forEach","line","console","info","mousePressed","location","path","pathname","description","polarToCartesianX","center","angle","distance","polarToCartesianY","polarToCartesianEllipse","radiusX","radiusY","asArray","x1","y1","x2","y2","x3","y3","x4","y4","uA","uB"],"mappings":"kFAAA,EAAQ,QAQR,IAMIA,EAAgD,mBAAjBC,aAEnC,SAASC,EAAEC,EAAKC,GACd,OAAO,EAAM,EAAMA,EAAM,EAAMD,EAGjC,SAASE,EAAEF,EAAKC,GACd,OAAO,EAAMA,EAAM,EAAMD,EAG3B,SAASG,EAAEH,GACT,OAAO,EAAMA,EAIf,SAASI,EAAWC,EAAIL,EAAKC,GAC3B,QAASF,EAAEC,EAAKC,GAAOI,EAAKH,EAAEF,EAAKC,IAAQI,EAAKF,EAAEH,IAAQK,EAI5D,SAASC,EAASD,EAAIL,EAAKC,GACzB,OAAO,EAAMF,EAAEC,EAAKC,GAAOI,EAAKA,EAAK,EAAMH,EAAEF,EAAKC,GAAOI,EAAKF,EAAEH,GAqClE,SAASO,EAAaC,GACpB,OAAOA,EAGTC,EAAOC,QAAU,SAAgBC,EAAKC,EAAKC,EAAKC,GAC9C,KAAM,GAAKH,GAAOA,GAAO,GAAK,GAAKE,GAAOA,GAAO,GAC/C,MAAM,IAAIE,MAAM,2CAGlB,GAAIJ,IAAQC,GAAOC,IAAQC,EACzB,OAAOP,EAMT,IAFA,IAAIS,EAAenB,EAAwB,IAAIC,aA1E1B,IA0E2D,IAAImB,MA1E/D,IA4EZC,EAAI,EAAGA,EA5EK,KA4EmBA,EACtCF,EAAaE,GAAKd,EA5EA,GA4EWc,EAAqBP,EAAKE,GAGzD,SAASM,EAASC,GAKhB,IAJA,IAAIC,EAAgB,EAChBC,EAAgB,EACHC,KAEVD,GAAgCN,EAAaM,IAAkBF,IAAME,EAC1ED,GArFgB,KAwFhBC,EAEF,IACIE,EAAYH,EA3FE,KA0FND,EAAKJ,EAAaM,KAAmBN,EAAaM,EAAgB,GAAKN,EAAaM,KAE5FG,EAAenB,EAASkB,EAAWb,EAAKE,GAE5C,OAAIY,GAlGe,KAgDvB,SAA8BL,EAAIM,EAASf,EAAKE,GAC9C,IAAK,IAAIK,EAAI,EAAGA,EAlDM,IAkDmBA,EAAG,CAC1C,IAAIS,EAAerB,EAASoB,EAASf,EAAKE,GAE1C,GAAqB,IAAjBc,EACF,OAAOD,EAITA,IADetB,EAAWsB,EAASf,EAAKE,GAAOO,GACzBO,EAGxB,OAAOD,EAuCIE,CAAqBR,EAAII,EAAWb,EAAKE,GACtB,IAAjBY,EACFD,EAxEb,SAAyBJ,EAAIS,EAAIC,EAAInB,EAAKE,GACxC,IAAIkB,EACAC,EACAd,EAAI,EAER,IAEEa,EAAW3B,EADX4B,EAAWH,GAAMC,EAAKD,GAAM,EACIlB,EAAKE,GAAOO,GAE7B,EACbU,EAAKE,EAELH,EAAKG,QAEAC,KAAKC,IAAIH,GA1CQ,QA0C+Bb,EAzC1B,IA2C/B,OAAOc,EA0DIG,CAAgBf,EAAIC,EAAeA,EAnG1B,GAmG2DV,EAAKE,GAIpF,OAAO,SAAsBL,GAE3B,OAAU,IAANA,EACK,EAGC,IAANA,EACK,EAGFJ,EAAWe,EAASX,GAAII,EAAKE,M,moDCvHxC,IAAMsB,EAAOC,IAAa,EAAG,EAAG,EAAG,GAG7BC,EAAS,SAASC,GACtB,IAAIC,EAEAC,EAAU,GACVC,GAAa,EAEXC,EAAQJ,EAAEK,OAAOL,EAAEM,QAEnBC,EARmB,WASvB,WAAYtC,EAAGuC,EAAGC,EAAMC,GACtBC,KAAKC,QAAU3C,EACf0C,KAAKE,QAAUL,EACfG,KAAKG,QAAUJ,EACfC,KAAKF,KAAOA,EACZE,KAAKI,UAAYf,EAAEK,OAAO,CAAC,GAAI,IAC/BM,KAAKK,aAAehB,EAAEK,OAAO,CAACX,KAAKuB,IAAKvB,KAAKwB,MAfxB,I,MAAA,mBA+BvBC,KAAA,WACEnB,EAAEoB,OAAOT,KAAKC,QAASD,KAAKE,QAAuB,EAAdF,KAAKD,S,EAhCrB,G,EAAA,gCAiBP,IACNW,EAAUrB,EAAEsB,SAAZD,MAER,OAAOE,YACLZ,KAAKC,QACLD,KAAKE,QACLQ,EAAQV,KAAKF,KAAOE,KAAKI,UACzBJ,KAAKD,UAxBc,6BA2BT,IACJW,EAAUrB,EAAEsB,SAAZD,MACR,OAAOV,KAAKG,UAAYH,KAAKK,aAAaK,EAAQ,GAAK,GAAK,Q,2BA7BvC,KAoCzBrB,EAAEwB,MAAQ,WACRxB,EAAEyB,aAAa,IAAK,KACpBzB,EAAE0B,UAAU,KACZzB,EAAUD,EAAE2B,eAAe3B,EAAE4B,MAAO5B,EAAE6B,SAC9BC,UAAU9B,EAAE+B,IAAK/B,EAAEM,QAC3BL,EAAQ+B,UAAUhC,EAAEiC,YACpBhC,EAAQiC,aAAa,IACrBjC,EAAQkC,SAER,IAAMC,EAAapC,EAAEqC,QAAQ,CAC3B,CAACrC,EAAEsC,MAAMtC,EAAEK,OAAO,EAAG,IAAKL,EAAEK,OAAOL,EAAE4B,MAAQ,GAAI5B,EAAE4B,MAAQ,IAC3D,CAAC5B,EAAEsC,MAAMtC,EAAEK,OAAO,GAAI,KAAML,EAAEK,OAAOL,EAAE4B,MAAQ,EAAG5B,EAAE4B,QACpD,CAAC5B,EAAEsC,MAAMtC,EAAEK,OAAO,IAAK,MAAQL,EAAEK,OAAOL,EAAE6B,OAAmB,EAAX7B,EAAE6B,WAGtD3B,EAAQqC,KAAR,EAAiBhC,EAAjB,CAAwB,EAAG,GAA3B,SAAiC6B,EAAW,OAC5ClC,EAAQqC,KAAR,EAAiBhC,EAAjB,CAAwBP,EAAE4B,MAAO,GAAjC,SAAuCQ,EAAW,OAClDlC,EAAQqC,KAAR,EAAiBhC,EAAjB,CAAwBP,EAAE4B,MAAQ,EAAc,IAAX5B,EAAE6B,QAAvC,SAAwDO,EAAW,OAEnEpC,EAAEwC,WAzDW,KAyDU,CAAEC,YAAa,MAgBxCzC,EAAEmB,KAAO,WAAY,IAAD,IACSnB,EAAEsB,SAArBD,EADU,EACVA,MAAOqB,EADG,EACHA,QAEf1C,EAAE2C,WAAW,KAEb,IAAIC,EAAM1C,EAAQ2C,KAAI,SAACC,EAAInE,GACzB,IAAIoE,EAAK7C,EAAc,IAANvB,EAAU,EAAIA,EAAI,GACnC,MAAO,CACLV,EAAG+B,EAAEgD,KAAKF,EAAGG,SAAShF,EAAG8E,EAAGE,SAAShF,EAAG,IACxCuC,EAAGR,EAAEgD,KAAKF,EAAGG,SAASzC,EAAGuC,EAAGE,SAASzC,EAAG,QAItC0C,EAAYC,YAChBjD,EAAQ,GAAG+C,SAAShF,EACpBiC,EAAQ,GAAG+C,SAASzC,EACpBoC,EAAI,GAAG3E,EACP2E,EAAI,GAAGpC,EACPN,EAAQ,GAAG+C,SAAShF,EACpBiC,EAAQ,GAAG+C,SAASzC,EACpBoC,EAAI,GAAG3E,EACP2E,EAAI,GAAGpC,GAETP,EAAQmD,OACN/B,EAAQjB,EAAQJ,EAAEM,OAASe,EAAQjB,EAAQJ,EAAEM,OAASe,EAAQjB,EAC9DJ,EAAE6C,IAAI7C,EAAEkB,IAAIG,IAAS,EAAG,EAAG,EAAGrB,EAAEM,QAChCN,EAAE6C,IAAI7C,EAAEiB,IAAY,EAARI,IAAa,EAAG,EAAG,EAAGrB,EAAEM,QACpCT,EAAKG,EAAE6C,IAAI7C,EAAEiB,IAAY,IAARI,IAAe,EAAG,EAAG,EAAGrB,EAAEM,OAAS,OAEtD,EAAAL,GAAQoD,OAAR,SACEH,EAAUjF,EACViF,EAAU1C,GAFZ,SAGKe,YACDvB,EAAE4B,MAAQ,EACV5B,EAAE6B,OAAS,EACA,GAAX7B,EAAE6B,OACFR,EAAQqB,EAAmC,KAAzB1C,EAAEsD,WAAa,EAAK,KACtC,IARJ,CAUEV,EAAI,GAAG3E,EACP2E,EAAI,GAAGpC,EACPoC,EAAI,GAAG3E,EACP2E,EAAI,GAAGpC,KAGTR,EAAEuD,MAAMtD,EAAS,EAAG,GAChBD,EAAEsD,WAAaE,QACjBxD,EAAEyD,SACFtD,GAAa,GAGXA,IACFH,EAAEoD,OAAO,OACTpD,EAAEmC,SACFjC,EAAQwD,SAAQ,SAACZ,EAAInE,GACnB,IAAIoE,EAAK7C,EAAc,IAANvB,EAAU,EAAIA,EAAI,GACnCqB,EAAEoB,OAAO0B,EAAGlC,QAASkC,EAAGjC,QAAqB,EAAZiC,EAAGpC,QACpCV,EAAE2D,KAAKb,EAAGG,SAAShF,EAAG6E,EAAGG,SAASzC,EAAGuC,EAAGE,SAAShF,EAAG8E,EAAGE,SAASzC,GAChER,EAAEoB,OAAOwB,EAAIjE,GAAGV,EAAG2E,EAAIjE,GAAG6B,EAAG,MAE/BR,EAAE2D,KAAKzD,EAAQ,GAAG+C,SAAShF,EAAGiC,EAAQ,GAAG+C,SAASzC,EAAGoC,EAAI,GAAG3E,EAAG2E,EAAI,GAAGpC,GACtER,EAAE2D,KAAKzD,EAAQ,GAAG+C,SAAShF,EAAGiC,EAAQ,GAAG+C,SAASzC,EAAGoC,EAAI,GAAG3E,EAAG2E,EAAI,GAAGpC,GACtER,EAAE2D,KAAKzD,EAAQ,GAAG+C,SAAShF,EAAGiC,EAAQ,GAAG+C,SAASzC,EAAGoC,EAAI,GAAG3E,EAAG2E,EAAI,GAAGpC,IAGpER,EAAEsD,WAAa,KAAQ,GACzBM,QAAQC,KAAK7D,EAAEsD,WAAFtD,eAIjBA,EAAE8D,aAAe,WACf3D,GAAcA,IAIH,0BAAG4D,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CACEhE,OAAQA,EACRiE,KAAMD,EAASE,SACfC,YAAY,4C,kCChKhB,0GAAMC,EAAoB,SAACC,EAAQC,EAAOC,GACxC,OAAOF,EAAS1E,KAAKwB,IAAImD,GAASC,GAE9BC,EAAoB,SAACH,EAAQC,EAAOC,GACxC,OAAOF,EAAS1E,KAAKuB,IAAIoD,GAASC,GAsB9BE,EAA0B,SAC9B5D,EACAC,EACAwD,EACAI,EACAC,EACAC,QACG,IADHA,OAAU,GAEV,IAAM1G,EAAI2C,EAAUlB,KAAKwB,IAAImD,GAASI,EAChCjE,EAAIK,EAAUnB,KAAKuB,IAAIoD,GAASK,EACtC,OAAOC,EAAU,CAAC1G,EAAGuC,GAAK,CAAEvC,IAAGuC,MAIlBe,IAzBU,SACvBX,EACAC,EACAwD,EACAC,EACAK,QACG,IADHA,OAAU,GAEV,IAAM1G,EAAIkG,EAAkBvD,EAASyD,EAAOC,GACtC9D,EAAI+D,EAAkB1D,EAASwD,EAAOC,GAC5C,OAAOK,EAAU,CAAC1G,EAAGuC,GAAK,CAAEvC,IAAGuC,O,kCCblB,SAAS2C,EAAiByB,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,GACnE,IAAMC,IACFF,EAAKF,IAAOH,EAAKI,IAAOE,EAAKF,IAAOL,EAAKI,MACzCG,EAAKF,IAAOH,EAAKF,IAAOM,EAAKF,IAAOD,EAAKF,IACvCQ,IACFP,EAAKF,IAAOC,EAAKI,IAAOF,EAAKF,IAAOD,EAAKI,MACzCG,EAAKF,IAAOH,EAAKF,IAAOM,EAAKF,IAAOD,EAAKF,IAE7C,OAAIO,GAAM,GAAKA,GAAM,GAAKC,GAAM,GAAKA,GAAM,EAClC,CAAEpH,EAAG2G,EAAKQ,GAAMN,EAAKF,GAAKpE,EAAGqE,EAAKO,GAAML,EAAKF,IAE/C,CAAE5G,EAAG,KAAMuC,EAAG,MAtBvB","file":"component---src-pages-sketch-2019-11-24-js-8acad94424c716c28e3e.js","sourcesContent":["require(\"core-js/modules/es6.typed.float32-array\");\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nfunction LinearEasing(x) {\n  return x;\n}\n\nmodule.exports = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport \"p5.createloop\";\nimport lineIntersection from \"~lib/lineIntersection\";\nimport bezierEasing from \"bezier-easing\";\n\nconst ease = bezierEasing(0, 1, 1, 0);\nconst DURATION = 1800;\n\nconst sketch = function(p) {\n  let drawing;\n  // let lastPoint;\n  let circles = [];\n  let viewGuides = true;\n\n  const START = p.random(p.TWO_PI);\n\n  class Circle {\n    constructor(x, y, rate, radius) {\n      this.centerX = x;\n      this.centerY = y;\n      this._radius = radius;\n      this.rate = rate;\n      this.direction = p.random([1, -1]);\n      this.sizeFunction = p.random([Math.sin, Math.cos]);\n    }\n    get position() {\n      const { theta } = p.animLoop;\n\n      return polarToCartesian(\n        this.centerX,\n        this.centerY,\n        theta * this.rate * this.direction,\n        this.radius\n      );\n    }\n    get radius() {\n      const { theta } = p.animLoop;\n      return this._radius * ((this.sizeFunction(theta / 2) + 1) / 2);\n    }\n    draw() {\n      p.circle(this.centerX, this.centerY, this.radius * 2);\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.frameRate(60);\n    drawing = p.createGraphics(p.width, p.height);\n    drawing.colorMode(p.HSL, p.TWO_PI);\n    drawing.blendMode(p.HARD_LIGHT);\n    drawing.strokeWeight(0.5);\n    drawing.noFill();\n\n    const properties = p.shuffle([\n      [p.floor(p.random(2, 9)), p.random(p.width / 10, p.width / 5)],\n      [p.floor(p.random(30, 70)), p.random(p.width / 2, p.width)],\n      [p.floor(p.random(500, 1000)), p.random(p.height, p.height * 2)],\n    ]);\n\n    circles.push(new Circle(0, 0, ...properties[0]));\n    circles.push(new Circle(p.width, 0, ...properties[1]));\n    circles.push(new Circle(p.width / 2, p.height * 1.5, ...properties[2]));\n\n    p.createLoop(DURATION, { noiseRadius: 15 });\n  };\n\n  /*\n\n               mid[0]\n  circle[0] ---------- circle[1]\n            \\        /\n             \\      /\n      mid[2]  \\    / mid[1]\n               \\  /\n                \\/\n             circle(2)\n\n  */\n\n  p.draw = function() {\n    const { theta, noise1D } = p.animLoop;\n\n    p.background(255);\n\n    let mid = circles.map((cA, i) => {\n      let cB = circles[i === 2 ? 0 : i + 1];\n      return {\n        x: p.lerp(cA.position.x, cB.position.x, 0.5),\n        y: p.lerp(cA.position.y, cB.position.y, 0.5),\n      };\n    });\n\n    const thisPoint = lineIntersection(\n      circles[0].position.x,\n      circles[0].position.y,\n      mid[1].x,\n      mid[1].y,\n      circles[1].position.x,\n      circles[1].position.y,\n      mid[2].x,\n      mid[2].y\n    );\n    drawing.stroke(\n      theta + START > p.TWO_PI ? theta + START - p.TWO_PI : theta + START,\n      p.map(p.cos(theta), -1, 1, 0, p.TWO_PI),\n      p.map(p.sin(theta * 4), -1, 1, 0, p.TWO_PI),\n      ease(p.map(p.sin(theta * 100), -1, 1, 0, p.TWO_PI / 10))\n    );\n    drawing.bezier(\n      thisPoint.x,\n      thisPoint.y,\n      ...polarToCartesian(\n        p.width / 2,\n        p.height / 2,\n        p.height * 10,\n        theta * noise1D(((p.frameCount % 3) + 1) * 0.01),\n        true\n      ),\n      mid[2].x,\n      mid[2].y,\n      mid[0].x,\n      mid[0].y\n    );\n\n    p.image(drawing, 0, 0);\n    if (p.frameCount > DURATION * 60) {\n      p.noLoop();\n      viewGuides = false;\n    }\n\n    if (viewGuides) {\n      p.stroke(\"red\");\n      p.noFill();\n      circles.forEach((cA, i) => {\n        let cB = circles[i === 2 ? 0 : i + 1];\n        p.circle(cA.centerX, cA.centerY, cA.radius * 2);\n        p.line(cA.position.x, cA.position.y, cB.position.x, cB.position.y);\n        p.circle(mid[i].x, mid[i].y, 5);\n      });\n      p.line(circles[0].position.x, circles[0].position.y, mid[1].x, mid[1].y);\n      p.line(circles[1].position.x, circles[1].position.y, mid[2].x, mid[2].y);\n      p.line(circles[2].position.x, circles[2].position.y, mid[0].x, mid[0].y);\n    }\n\n    if (p.frameCount % 100 === 0) {\n      console.info(p.frameCount + \" of \" + DURATION * 60);\n    }\n  };\n\n  p.mousePressed = function() {\n    viewGuides = !viewGuides;\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout\n    sketch={sketch}\n    path={location.pathname}\n    description=\"Click or tap canvas to toggle guides.\"\n  />\n);\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","/**\n *\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x4\n * @param {number} y4\n */\nexport default function lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n  const uA =\n    ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) /\n    ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n  const uB =\n    ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) /\n    ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n\n  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n    return { x: x1 + uA * (x2 - x1), y: y1 + uA * (y2 - y1) };\n  }\n  return { x: null, y: null };\n}\n"],"sourceRoot":""}