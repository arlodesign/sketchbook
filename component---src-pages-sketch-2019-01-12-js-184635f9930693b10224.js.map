{"version":3,"sources":["webpack:///./src/pages/sketch/2019/01/12.js"],"names":["sketch","p","gridSize","maxDist","vectors","setup","createCanvas","background","floor","random","dist","width","height","x","y","push","vector","createVector","reached","reachedBy","draw","stroke","strokeWeight","filter","v","forEach","point","pop","i","noFill","line","fill","triangle","ellipse","reachedByIndex","unreachedIndex","shortestDist","uv","ui","rv","ri","thisDist","length","noLoop","location","path","pathname","description"],"mappings":"qJAGMA,EAAS,SAASC,GACtB,IACIC,EACAC,EAFAC,EAAU,GAKdH,EAAEI,MAAQ,WACRJ,EAAEK,aAAa,IAAK,KACpBL,EAAEM,WAAW,KACbL,EAAWD,EAAEO,MAAMP,EAAEQ,OAAO,GAAI,KAChCN,EAAUF,EAAES,KAAK,EAAG,EAAGT,EAAEU,MAAOV,EAAEW,QAClC,IAAK,IAAIC,EAAI,EAAGA,GAAKX,EAAUW,IAC7B,IAAK,IAAIC,EAAI,EAAGA,GAAKZ,EAAUY,IACzBb,EAAEQ,SAAW,IACfL,EAAQW,KAAK,CACXC,OAAQf,EAAEgB,aACPhB,EAAEU,MAAQT,EAAYW,EACtBZ,EAAEW,OAASV,EAAYY,GAE1BI,SAAS,EACTC,UAAW,IAKnBf,EAAQ,GAAGc,SAAU,EACrBd,EAAQ,GAAGe,WAAa,GAG1BlB,EAAEmB,KAAO,WACPnB,EAAEc,OACFd,EAAEoB,OAAkB,OACpBpB,EAAEqB,aAAa,GACflB,EACGmB,QAAO,SAAAC,GAAC,OAAKA,EAAEN,WACfO,SAAQ,gBAAGT,EAAH,EAAGA,OAAH,OAAgBf,EAAEyB,MAAMV,EAAOH,EAAGG,EAAOF,MACpDb,EAAE0B,MACFvB,EAAQqB,SAAQ,WAAiCG,GAAO,IAArCZ,EAAoC,EAApCA,OAAQE,EAA4B,EAA5BA,QAASC,EAAmB,EAAnBA,UAClC,GAAID,GAAWC,GAAa,EAAG,CAAC,IAAD,EACZf,EAAQe,GAAWH,OAA5BH,EADqB,EACrBA,EAAGC,EADkB,EAClBA,EACXb,EAAEoB,OAAO,GACTpB,EAAEqB,aAAa,GACfrB,EAAE4B,SACF5B,EAAE6B,KAAKd,EAAOH,EAAGG,EAAOF,EAAGD,EAAGC,GAC9Bb,EAAE8B,KAAK,GACP9B,EAAE+B,SAAShB,EAAOH,EAAGG,EAAOF,EAAGD,EAAGC,EAAGD,EAAGG,EAAOF,GAC1CE,EAAOH,IAAMA,GAAKG,EAAOF,IAAMA,GAAMc,EAAI,GAAM,GAClD3B,EAAEgC,QAAQpB,EAAGC,EAAGb,EAAES,KAAKG,EAAGC,EAAGE,EAAOH,EAAGG,EAAOF,QAIpD,IACIoB,EACAC,EAFAC,EAAejC,EAGnBC,EAAQqB,SAAQ,SAACY,EAAIC,GACdD,EAAGnB,SACNd,EAAQqB,SAAQ,SAACc,EAAIC,GACnB,GAAID,EAAGrB,QAAS,CACd,IAAMuB,EAAWxC,EAAES,KACjB2B,EAAGrB,OAAOH,EACVwB,EAAGrB,OAAOF,EACVyB,EAAGvB,OAAOH,EACV0B,EAAGvB,OAAOF,GAER2B,EAAWL,IACbA,EAAeK,EACfN,EAAiBG,EACjBJ,EAAiBM,UAM3BpC,EAAQ+B,GAAgBjB,SAAU,EAClCd,EAAQ+B,GAAgBhB,UAAYe,EAEhC9B,EAAQmB,QAAO,SAAAC,GAAC,OAAIA,EAAEN,WAASwB,SAAWtC,EAAQsC,QACpDzC,EAAE0C,WAKO,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAc5C,OAAQA,EAAQ6C,KAAMD,EAASE,SAAUC,YAAY","file":"component---src-pages-sketch-2019-01-12-js-184635f9930693b10224.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\n\nconst sketch = function(p) {\n  let vectors = [];\n  let gridSize;\n  let maxDist;\n  let showDots = true;\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.background(255);\n    gridSize = p.floor(p.random(25, 50));\n    maxDist = p.dist(0, 0, p.width, p.height);\n    for (let x = 0; x <= gridSize; x++) {\n      for (let y = 0; y <= gridSize; y++) {\n        if (p.random() < 0.2) {\n          vectors.push({\n            vector: p.createVector(\n              (p.width / gridSize) * x,\n              (p.height / gridSize) * y\n            ),\n            reached: false,\n            reachedBy: 0,\n          });\n        }\n      }\n    }\n    vectors[0].reached = true;\n    vectors[0].reachedBy = -1;\n  };\n\n  p.draw = function() {\n    p.push();\n    p.stroke(showDots ? \"red\" : 255);\n    p.strokeWeight(1);\n    vectors\n      .filter(v => !v.reached)\n      .forEach(({ vector }) => p.point(vector.x, vector.y));\n    p.pop();\n    vectors.forEach(({ vector, reached, reachedBy }, i) => {\n      if (reached && reachedBy > -1) {\n        const { x, y } = vectors[reachedBy].vector;\n        p.stroke(0);\n        p.strokeWeight(2);\n        p.noFill();\n        p.line(vector.x, vector.y, x, y);\n        p.fill(0);\n        p.triangle(vector.x, vector.y, x, y, x, vector.y);\n        if ((vector.x === x || vector.y === y) && i % 3 === 0) {\n          p.ellipse(x, y, p.dist(x, y, vector.x, vector.y));\n        }\n      }\n    });\n    let shortestDist = maxDist;\n    let reachedByIndex;\n    let unreachedIndex;\n    vectors.forEach((uv, ui) => {\n      if (!uv.reached) {\n        vectors.forEach((rv, ri) => {\n          if (rv.reached) {\n            const thisDist = p.dist(\n              uv.vector.x,\n              uv.vector.y,\n              rv.vector.x,\n              rv.vector.y\n            );\n            if (thisDist < shortestDist) {\n              shortestDist = thisDist;\n              unreachedIndex = ui;\n              reachedByIndex = ri;\n            }\n          }\n        });\n      }\n    });\n    vectors[unreachedIndex].reached = true;\n    vectors[unreachedIndex].reachedBy = reachedByIndex;\n\n    if (vectors.filter(v => v.reached).length === vectors.length) {\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"Reload page for a different variation.\" />\n);\n"],"sourceRoot":""}