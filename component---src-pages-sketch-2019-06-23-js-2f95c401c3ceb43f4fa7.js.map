{"version":3,"sources":["webpack:///./src/pages/sketch/2019/06/23.js","webpack:///./node_modules/core-js/modules/es6.array.from.js","webpack:///./node_modules/core-js/modules/_create-property.js","webpack:///./node_modules/amp-is-object/is-object.js","webpack:///./node_modules/coordinate-systems/coordinate-systems.js","webpack:///./node_modules/amp-is-array/is-array.js","webpack:///./node_modules/amp-is-number/is-number.js","webpack:///./node_modules/amp-extend/extend.js"],"names":["sketch","p","colors","colorFunctions","angle","abs","sin","cos","tan","setup","createCanvas","WEBGL","noStroke","Array","from","Set","length","random","draw","C","map","c","frameCount","background","apply","pointLight","reverse","concat","camera","spherical","SIZE","cart","specularMaterial","shininess","i","push","rotateX","TWO_PI","rotateY","torus","pop","__webpack_exports__","_ref","location","Object","_emotion_core__WEBPACK_IMPORTED_MODULE_6__","_components_sketch_layout__WEBPACK_IMPORTED_MODULE_9__","path","pathname","description","ctx","__webpack_require__","$export","toObject","call","isArrayIter","toLength","createProperty","getIterFn","S","F","iter","arrayLike","result","step","iterator","O","this","aLen","arguments","mapfn","undefined","mapping","index","iterFn","next","done","value","$defineProperty","createDesc","module","exports","object","f","obj","type","isArray","isNumber","isObject","extend","degPerRadian","Math","PI","Coordinate","config","isRadian","isDegree","_x","_y","_z","_r","_t","_p","pos","defineProperty","get","x","set","label","coords","Error","initialType","prototype","cartesian","options","temp","cartesian2d","cartesian3d","polarToCart2d","polar","cylindrical","sphericalToCart3d","cyl","cartesian2dToPolar","center","cartesian3dToCylindrical","sphericalToCylindrical","pol","sph","cartesian3dToSpherical","cylindricalToSpherical","baseCoord","arrToNumeric","nums","num","TypeError","parseFloat","rt","r","t","xy","y","sqrt","atan2","xyz","z","x2","y2","z2","rtz","sr","sp","rtp","cr","toString","nativeIsArray","source","prop"],"mappings":"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","file":"component---src-pages-sketch-2019-06-23-js-2f95c401c3ceb43f4fa7.js","sourcesContent":["import React from \"react\";\nimport { spherical } from \"coordinate-systems\";\nimport SketchLayout from \"~components/sketch-layout\";\n\nconst sketch = function(p) {\n  const SIZE = 10;\n  const SPEED = 0.25;\n\n  let colors = [];\n\n  const colorFunctions = [\n    angle => p.abs(p.sin(angle)) * 240,\n    angle => p.abs(p.cos(angle)) * 240,\n    angle => p.abs(p.tan(angle)) * 240,\n    angle => p.abs(p.sin(-angle)) * 240,\n    angle => p.abs(p.cos(-angle)) * 240,\n    angle => p.abs(p.tan(-angle)) * 240,\n    () => 240,\n    () => 15,\n    () => 128,\n  ];\n\n  p.setup = function() {\n    p.createCanvas(660, 840, p.WEBGL);\n    p.noStroke();\n    while (Array.from(new Set(colors)).length < 3) {\n      colors = [\n        p.random(colorFunctions),\n        p.random(colorFunctions),\n        p.random(colorFunctions),\n      ];\n    }\n  };\n\n  p.draw = function() {\n    const C = colors.map(c => c((p.frameCount / 200) * SPEED));\n\n    p.background(...C);\n\n    p.pointLight(\n      ...C.reverse(),\n      p.cos((p.frameCount / 200) * SPEED),\n      p.sin((p.frameCount / 100) * SPEED),\n      p.sin((p.frameCount / 100) * SPEED)\n    );\n    p.camera(\n      ...spherical([SIZE * SIZE * 2, 0, (p.frameCount / 200) * SPEED]).cart(),\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    );\n\n    p.noStroke();\n\n    p.specularMaterial(...C);\n    p.shininess(5);\n\n    for (let i = 0; i < SIZE * 2; i++) {\n      p.push();\n\n      p.rotateX((p.TWO_PI / SIZE) * i * p.sin((p.frameCount / 100) * SPEED));\n      p.rotateY((p.TWO_PI / SIZE) * i * p.cos((p.frameCount / 200) * SPEED));\n\n      p.torus(SIZE * i, SIZE / 3, 30 * i + 1);\n      p.pop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n","'use strict';\nvar ctx = require('./_ctx');\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar toLength = require('./_to-length');\nvar createProperty = require('./_create-property');\nvar getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n","module.exports = function isObject(obj) {\n    var type = typeof obj;\n    return !!obj && (type === 'function' || type === 'object');\n};\n","\"use strict\";\nvar isArray = require('amp-is-array');\nvar isNumber = require('amp-is-number');\nvar isObject = require('amp-is-object');\nvar extend = require('amp-extend');\nvar degPerRadian = 180 / Math.PI;\n\n/**\n * @constructor Coordinate\n * @description Defines object which can convert between coordinate systems.\n * It is recommended to use one of the Coodinate.STATIC_CONSTRUCTOR functions\n * to generate your first coordinate before conversions. e.g. Coodinate.spherical(...)\n * @param {Object} config\n * {\n *     label: 'type of initial coordinate',\n *     coords: {\n *         x/y/z/r/t/p: 'k-v pairs'\n *     },\n *     isDegree: Boolean\n * }\n */\nvar Coordinate = function (config) {\n    var isRadian,\n        isDegree,\n        pos = {},\n        _x, _y, _z, _r, _t, _p;\n\n    // Override select setters/getts\n    Object.defineProperty(this, \"isRadian\", {\n        get: function (x) { return isRadian; },\n        set: function (x) {\n            isRadian = !!x;\n            if (isDegree !== !x) { isDegree = !x; } // jshint ignore:line\n        }\n    });\n    Object.defineProperty(this, \"isDegree\", {\n        get: function (x) { return isDegree; },\n        set: function (x) {\n            isDegree = x;\n            if (isRadian !== !x) { isRadian = !x; } // jshint ignore:line\n        }\n    });\n    Object.defineProperty(pos, \"cartesian2d\", {\n        get: function (x) { return [_x, _y]; },\n        set: function (x) { _x = x[0]; _y = x[1]; }\n    });\n    Object.defineProperty(pos, \"cartesian3d\", {\n        get: function (x) { return [_x, _y, _z]; },\n        set: function (x) { _x = x[0]; _y = x[1]; _z = x[2]; }\n    });\n    Object.defineProperty(pos, \"polar\", {\n        get: function (x) { return [_r, _t]; },\n        set: function (x) { _r = x[0]; _t = x[1]; }\n    });\n    Object.defineProperty(pos, \"cylindrical\", {\n        get: function (x) { return [_r, _t, _z]; },\n        set: function (x) { _r = x[0]; _t = x[1]; _z = x[2]; }\n    });\n    Object.defineProperty(pos, \"spherical\", {\n        get: function (x) { return [_r, _t, _p]; },\n        set: function (x) { _r = x[0]; _t = x[1]; _p = x[2]; }\n    });\n\n    // init from config\n    if (config.isDegree && !config.isRadian) {\n        this.isDegree = true;\n    } else {\n        this.isRadian = true;\n    }\n    if (!config.label || !config.coords) {\n        throw new Error(\"no coordinate type defined\");\n    }\n    this.initialType = config.label;\n    this.pos = pos;\n    this.pos[config.label] = config.coords;\n};\n\n\n\n/**\n * @method cartesian\n * Converts current coordinate to cartesian\n * @function cartesian\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cartesian = function () { return this.cart.apply(this, arguments); };\n/**\n * @method cart\n * Converts current coordinate to cartesian\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cart = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            return this.pos.cartesian2d;\n        case 'cartesian3d':\n            return this.pos.cartesian3d;\n        case 'polar':\n            this.pos.cartesian2d = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n            return this.pos.cartesian2d;\n        case 'cylindrical':\n            temp = Coordinate.polarToCart2d(this.pos.polar, this.isDegree);\n            this.pos.cartesian3d = [temp[0], temp[1], this.pos.cylindrical[2]];\n            return this.pos.cartesian3d;\n        case 'spherical':\n            this.pos.cartesian3d = Coordinate.sphericalToCart3d(this.pos.spherical, this.isDegree);\n            return this.pos.cartesian3d;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n\n/**\n * @method cylindrical\n * Converts current coordinate to cylindrical\n * @function cylindrical\n * @memberof Coordinate\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cylindrical = function () { return this.cyl.apply(this, arguments); };\n/**\n * @method cyl\n * Converts current coordinate to cylindrical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.cyl = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            this.pos.cylindrical = [temp[0], temp[1], 0];\n            return this.pos.cylindrical;\n        case 'cartesian3d':\n            this.pos.cylindrical = Coordinate.cartesian3dToCylindrical(this.pos.cartesian3d, this.isDegree, options.center);\n            return this.pos.cylindrical;\n        case 'polar':\n            temp = this.pos.polar;\n            return [temp[0], temp[1], 0];\n        case 'cylindrical':\n            return this.pos.cylindrical;\n        case 'spherical':\n            this.pos.cylindrical = Coordinate.sphericalToCylindrical(this.pos.spherical, this.isDegree);\n            return this.pos.cylindrical;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n/**\n * @method pol\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.pol = function () { return this.polar.apply(this, arguments); };\n/**\n * @method polar\n * Converts current coordinate to polar\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.polar = function (options) {\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            this.pos.polar = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            return this.pos.polar;\n        case 'polar':\n            return this.pos.polar;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n\n/**\n * @method spherical\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.spherical = function () { return this.sph.apply(this, arguments); };\n/**\n * @method sph\n * Converts current coordinate to spherical\n * @param  {Object} options\n * @return {Array}  coordinates in respective coordinate format\n */\nCoordinate.prototype.sph = function (options) {\n    var temp;\n    options = options || {};\n    switch (this.initialType) {\n        case 'cartesian2d':\n            temp = Coordinate.cartesian2dToPolar(this.pos.cartesian2d, this.isDegree, options.center);\n            this.pos.spherical = [temp[0], temp[1], 0];\n            return this.pos.spherical;\n        case 'cartesian3d':\n            this.pos.spherical = Coordinate.cartesian3dToSpherical(this.pos.cartesian3d, this.isDegree, options.center);\n            return this.pos.spherical;\n        case 'polar':\n            temp = this.pos.polar;\n            return [temp[0], temp[1], 0];\n        case 'cylindrical':\n            this.pos.spherical = Coordinate.cylindricalToSpherical(this.pos.cylindrical, this.isDegree);\n            return this.pos.spherical;\n        case 'spherical':\n            return this.pos.spherical;\n        default:\n            throw new Error('cannot convert to/from original/requested types');\n    }\n};\n\n\n///\n/// Static Constructor Functions\n///\n\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cartesian = function(x) { return Coordinate.cart(x); };\n/**\n * Create a point provided x, y, and optionally z coordinates\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cart = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length < 2 || options.coords.length > 3) {\n            throw new Error('expected exactly 2 or exactly 3 cartesian options');\n        }\n        baseCoord = {\n            label: 'cartesian2d',\n            options: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        if (options.coords.length === 2) {\n            return new Coordinate(baseCoord);\n        }\n        baseCoord.label = 'cartesian3d';\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [x,y,(z?)] coords');\n};\n\n\n\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cylindrical = function(x) { return Coordinate.cyl(x); };\n/**\n * Create point provided [radius, theta, z]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.cyl = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 3) {\n            throw new Error('expected exactly 3 params [r, t, z]');\n        }\n        baseCoord = {\n            label: 'cylindrical',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [r, t, z] coords');\n};\n\n\n\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.polar = function(x) { return Coordinate.pol(x); };\n/**\n * Create point provided [radius, theta]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.pol = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 2) {\n            throw new Error('expected exactly 2 params [r, t]');\n        }\n        baseCoord = {\n            label: 'polar',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected array of [r, t] options');\n};\n\n\n\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.spherical = function(options) { return Coordinate.sph(options); };\n/**\n * Create point provided [radius, theta, phi]\n * @param  {Object} coordinates\n * @return {Coordinate}\n */\nCoordinate.sph = function(options) {\n    var baseCoord;\n    if (isArray(options)) {\n        options = {coords: options};\n    }\n    if (isObject(options) && isArray(options.coords)) {\n        Coordinate.arrToNumeric(options.coords);\n        if (options.coords.length !== 3) {\n            throw new Error('expected exactly 3 params [r, t, p]');\n        }\n        baseCoord = {\n            label: 'spherical',\n            coords: options.coords\n        };\n        baseCoord = extend(baseCoord, options);\n        return new Coordinate(baseCoord);\n    }\n    throw new Error('expected options w/ array of [r, t, p] coords');\n};\n\n\n\n/**\n * Mutates an array of number-like looking values to purely numeric array\n * @example\n * [5, '2.4', '0'] => [5, 2.4, 0]\n * @param  {Array} nums\n * @return {undefined}\n */\nCoordinate.arrToNumeric = function(nums) {\n    var num;\n    if (!isArray(nums)) {\n        throw new TypeError(\"expected array of number-like values\");\n    }\n    for (var i = nums.length - 1; i >= 0; i--) {\n        num = nums[i];\n        if (typeof num === 'string') {\n            num = parseFloat(num);\n        }\n        if (!isNumber(num)) {\n            throw new TypeError(num + ' not numeric or numeric-like');\n        }\n    }\n};\n\n\n\n/**\n * Convert polar to 2d cartesian coordinates\n * @param  {Array}   rt        [radis, theta]\n * @param  {Boolean} isDegree specifies units\n * @return {Array}  [x, y]\n */\nCoordinate.polarToCart2d = function(rt, isDegree) {\n    var r, t, x, y;\n    r = rt[0];\n    t = rt[1];\n    if (isDegree) {\n        t = t * (1/degPerRadian);\n    }\n    x = r * Math.cos(t);\n    y = r * Math.sin(t);\n    return [x, y];\n};\n\n\n\n/**\n * Convert cartesian 2d to polar coordinates\n * @param  {Array}  xy\n * @param {Boolean=} isDegree overrides default radian theta assumption\n * @param  {Array=} center [x, y] coords of center of circle.  Defaults to [0, 0],\n * however may be offset.  Note. Such functionality not supported yet for converting\n * polar to cartesian\n * @return {Array}  [radius, theta]\n */\nCoordinate.cartesian2dToPolar = function(xy, isDegree, center) {\n    var x, y, r, t;\n    if (!isArray(xy) && xy.length !== 2) {\n        throw new TypeError('expected [x, y] xy array');\n    }\n    x = xy[0];\n    y = xy[1];\n    if (center && !isArray(center) && center.length !== 2) {\n        throw new TypeError('expected [x, y] center array');\n    }\n    if (center) {\n        x = x - center[0];\n        y = y - center[1];\n    }\n    r = Math.sqrt(x*x + y*y);\n    t = Math.atan2(y, x);\n    if (isDegree) {\n        t = t * degPerRadian;\n    }\n    return [r, t];\n};\n\n\n\n/**\n * Convert 3d cartesian to 3d cylindrical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y] coords of center of circle\n * @return {Array}      [radius, theta, z]\n */\nCoordinate.cartesian3dToCylindrical = function (xyz, isDegree, center) {\n    var x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        rt;\n    rt = Coordinate.cartesian2dToPolar([x, y], isDegree, center);\n    return [rt[0], rt[1], z];\n};\n\n\n\n/**\n * Convert 3d cartesian to 3d spherical coordinates\n * @param  {Array}      argument [x, y, z] coords\n * @param  {Boolean=}   isDegree overrides default radian theta assumption\n * @param  {Array=}     center [x, y, z] coords of center of circle\n * @return {Array}      [radius, theta, phi]\n */\nCoordinate.cartesian3dToSpherical = function (xyz, isDegree, center) {\n    if (center && center.length !== 3) {\n        throw new Error('expected center value to have [x, y, z] coords' +\n            'for locating sphere center');\n    }\n    var x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        x2, y2, z2,\n        r, t, p;\n    if (center) {\n        x = x - center[0];\n        y = y - center[1];\n        z = z - center[2];\n    }\n    x2 = x*x; y2 = y*y; z2 = z*z;\n    r = Math.sqrt(x2 + y2 + z2);\n    if (!r) {\n        p = t = 0;\n    } else {\n        t = Math.atan2(y,x);\n        p = Math.atan2(Math.sqrt(x2 + y2), z);\n        if (isDegree) {\n            t = t * degPerRadian;\n            p = p * degPerRadian;\n        }\n    }\n    return [r, t, p];\n};\n\n\n\n/**\n * Convert a cylindrical to a spherical coordinates\n * @param  {Array}   rtz\n * @param  {Boolean} isDegree\n * @return {Array}   [radius, theta, phi]\n */\nCoordinate.cylindricalToSpherical = function(rtz, isDegree) {\n    var r = rtz[0], t = rtz[1], z = rtz[2];\n    var sr, sp; // sphere radius, sphere theta...\n    if (isDegree) {\n        t = t / degPerRadian;\n    }\n    sr = Math.sqrt(r*r + z*z);\n    sp = Math.atan2(r, z);\n    if (isDegree) {\n        sp = sp * degPerRadian;\n        t = t * degPerRadian;\n    }\n    return [sr, t, sp];\n};\n\n\n\n/**\n * Convert spherical to a cartesian coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\nCoordinate.sphericalToCart3d = function (rtp, isDegree) {\n    var r = rtp[0], t = rtp[1], p = rtp[2],\n        x,y,z;\n    if (isDegree) {\n        t = t / degPerRadian;\n        p = p / degPerRadian;\n    }\n    x = r * Math.sin(p) * Math.cos(t);\n    y = r * Math.sin(p) * Math.sin(t);\n    z = r * Math.cos(p);\n    return [x, y, z];\n};\n\n\n\n/**\n * Convert spherical to cylindrical coordinates\n * @param  {Array}  rtz\n * @param  {Boolean} isDegree\n * @return {Array}\n */\nCoordinate.sphericalToCylindrical = function (rtp, isDegree) {\n    var r = rtp[0], t = rtp[1], p = rtp[2],\n        cr, z;\n    if (isDegree) {\n        t = t / degPerRadian;\n        p = p / degPerRadian;\n    }\n    cr = r * Math.sin(p);\n    z = r * Math.cos(p);\n    if (isDegree) {\n        t = t * degPerRadian;\n        p = p * degPerRadian;\n    }\n    return [cr, t, z];\n};\n\nmodule.exports = Coordinate;\n","var toString = Object.prototype.toString;\nvar nativeIsArray = Array.isArray;\n\n\nmodule.exports = nativeIsArray || function isArray(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n","var toString = Object.prototype.toString;\n\n\nmodule.exports = function isNumber(obj) {\n    return toString.call(obj) === '[object Number]';\n};\n","var isObject = require('amp-is-object');\n\n\nmodule.exports = function(obj) {\n    if (!isObject(obj)) return obj;\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n        source = arguments[i];\n        for (prop in source) {\n            obj[prop] = source[prop];\n        }\n    }\n    return obj;\n};\n"],"sourceRoot":""}