{"version":3,"sources":["webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2019/12/10.js"],"names":["polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y","polarToCartesian","sketch","p","RENDER","getURLParams","render","COLORS","shuffle","shapes","Point","aLow","aHigh","this","aNoise","random","dNoise","get","noise1D","animLoop","map","theta","width","Shape","i","direction","color","points","Array","fill","_","TWO_PI","draw","push","noStroke","translate","height","rotate","beginShape","forEach","pt","curveVertex","endShape","pop","setup","pixelDensity","frameRate","createCanvas","colorMode","HSB","createLoop","gif","open","noiseRadius","blendMode","BLEND","background","MULTIPLY","shape","location","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2019-12-10-js-d8636cc806c7904f4e8c.js","sourcesContent":["const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\nimport \"p5.createloop\";\n\nconst sketch = function(p) {\n  const SHAPES = 3;\n  const RENDER = p.getURLParams().render;\n  const POINTS = 25;\n  const COLORS = p.shuffle([\"cyan\", \"magenta\", \"yellow\"]);\n\n  let shapes = [];\n\n  class Point {\n    constructor(aLow, aHigh) {\n      this.aLow = aLow;\n      this.aHigh = aHigh;\n      this.aNoise = p.random();\n      this.dNoise = p.random();\n    }\n    get() {\n      const { noise1D } = p.animLoop;\n\n      return polarToCartesian(\n        0,\n        0,\n        p.map(\n          noise1D(this.aNoise) * p.cos(p.animLoop.theta),\n          -1,\n          1,\n          this.aLow,\n          this.aHigh\n        ),\n        p.map(\n          noise1D(this.dNoise) * p.cos(p.animLoop.theta),\n          -1,\n          1,\n          0,\n          p.width * 0.9\n        ),\n        true\n      );\n    }\n  }\n\n  class Shape {\n    constructor(i, ...color) {\n      this.i = i;\n      this.direction = p.random([-1, 1]);\n      this.color = p.color(...color);\n      this.points = Array(POINTS)\n        .fill()\n        .map(\n          (_, i) =>\n            new Point((p.TWO_PI / POINTS) * i, (p.TWO_PI / POINTS) * (i + 1))\n        );\n    }\n    draw() {\n      p.push();\n      p.fill(this.color);\n      p.noStroke();\n      p.translate(p.width / 2, p.height / 2);\n      p.rotate(p.animLoop.theta * this.i * this.direction);\n\n      p.beginShape();\n      this.points.forEach(pt => {\n        p.curveVertex(...pt.get());\n      });\n      p.curveVertex(...this.points[0].get());\n      p.curveVertex(...this.points[1].get());\n      p.curveVertex(...this.points[2].get());\n      p.endShape();\n\n      p.pop();\n    }\n  }\n\n  p.setup = function() {\n    if (RENDER) {\n      p.pixelDensity(1);\n      p.frameRate(30);\n    }\n\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, 1);\n    p.createLoop(20, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 0.3,\n    });\n\n    shapes = Array(SHAPES)\n      .fill()\n      .map((_, i) => new Shape(i, COLORS[i]));\n  };\n\n  p.draw = function() {\n    p.blendMode(p.BLEND);\n    p.background(255);\n    p.blendMode(p.MULTIPLY);\n    shapes.forEach(shape => shape.draw());\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\n);\n"],"sourceRoot":""}