{"version":3,"sources":["webpack:///./src/pages/sketch/2019/08/01.js"],"names":["RENDER","process","DEV","sketch","p","SIZES","GRID_SIZE","grid","boxes","Box","x","y","size","this","rotate","random","TWO_PI","HALF_PI","direction","canvasSize","canvas","createGraphics","strokeCap","PROJECT","strokeWeight","draw","noise","map","animLoop","noise2D","offset","cos","theta","blendMode","BLEND","background","MULTIPLY","push","translate","forEach","c","i","stroke","line","pop","image","setup","pixelDensity","frameRate","createCanvas","w","floor","width","h","height","createLoop","gif","render","open","noiseRadius","visited","concat","filter","length","Math","max","overlap","xx","yy","s","b","SketchPage"],"mappings":"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","file":"component---src-pages-sketch-2019-08-01-js-7bd0c8adc69716421e6e.js","sourcesContent":["import React from \"react\";\nimport Layout from \"~components/layout\";\nimport Sketch from \"~components/sketch\";\nimport \"p5.createloop\";\n\nconst RENDER = process.env.DEV && false;\n\nconst sketch = function(p) {\n  const SIZES = [1, 2, 3, 5, 8];\n  const GRID_SIZE = 60;\n\n  let grid = [];\n  let boxes = [];\n\n  class Box {\n    constructor(x, y, size) {\n      this.x = x * GRID_SIZE;\n      this.y = y * GRID_SIZE;\n      this.size = size;\n      this.rotate = p.random([p.TWO_PI, p.HALF_PI]);\n      this.direction = p.random([-1, 1]);\n      this.canvasSize = GRID_SIZE * size;\n      this.canvas = p.createGraphics(this.canvasSize, this.canvasSize);\n      this.canvas.strokeCap(p.PROJECT);\n      this.canvas.strokeWeight(2);\n    }\n\n    draw() {\n      const { x, y, size, rotate, direction, canvas, canvasSize } = this;\n      const noise = p.map(p.animLoop.noise2D(x, y), -1, 1, 0, 1);\n      const offset = p.map(p.cos(p.animLoop.theta), -1, 1, 0, p.TWO_PI * noise);\n\n      canvas.blendMode(p.BLEND);\n      canvas.background(255);\n      canvas.blendMode(p.MULTIPLY);\n      canvas.push();\n      canvas.translate(canvasSize / 2, canvasSize / 2);\n\n      [\"cyan\", \"magenta\", \"yellow\"].forEach((c, i) => {\n        canvas.push();\n        canvas.rotate(rotate * direction + offset * ((p.TWO_PI / 3) * (i + 1)));\n        canvas.stroke(c);\n        for (let i = 0; i <= canvasSize; i += canvasSize / size) {\n          canvas.line(0, 0, i, -canvasSize);\n          canvas.line(0, 0, i, canvasSize);\n          canvas.line(0, 0, -i, -canvasSize);\n          canvas.line(0, 0, -i, canvasSize);\n        }\n        canvas.pop();\n      });\n      canvas.pop();\n\n      p.image(canvas, x, y);\n    }\n  }\n\n  p.setup = function() {\n    if (RENDER) {\n      p.pixelDensity(1);\n      p.frameRate(30);\n    }\n\n    p.createCanvas(660, 840);\n    const w = p.floor(p.width / GRID_SIZE);\n    const h = p.floor(p.height / GRID_SIZE);\n\n    p.createLoop(10, {\n      gif: RENDER ? { render: false, open: true } : false,\n      noiseRadius: 0.1,\n    });\n\n    for (let x = 0; x < p.width / GRID_SIZE; x++) {\n      grid.push([]);\n      for (let y = 0; y < p.height / GRID_SIZE; y++) {\n        grid[x].push({\n          x,\n          y,\n          visited: false,\n        });\n      }\n    }\n\n    while ([].concat(...grid).filter(({ visited }) => !visited).length) {\n      const { x, y } = p.random(\n        [].concat(...grid).filter(({ visited }) => !visited)\n      );\n\n      if (!grid[x][y].visited) {\n        let size = Math.max(...SIZES);\n        let overlap;\n\n        do {\n          overlap = false;\n          for (let xx = x; xx < size + x; xx++) {\n            for (let yy = y; yy < size + y; yy++) {\n              if (x + size > w || y + size > h || grid[xx][yy].visited) {\n                overlap = true;\n              }\n            }\n          }\n          if (overlap) {\n            size = Math.max(...SIZES.filter(s => s < size));\n          }\n        } while (overlap);\n\n        boxes.push(new Box(x, y, size));\n\n        for (let xx = x; xx < size + x; xx++) {\n          for (let yy = y; yy < size + y; yy++) {\n            grid[xx][yy].visited = true;\n          }\n        }\n      }\n    }\n  };\n\n  p.draw = function() {\n    p.background(255);\n\n    boxes.forEach(b => b.draw());\n  };\n};\n\nconst SketchPage = () => (\n  <Layout>\n    <Sketch sketch={sketch} />\n  </Layout>\n);\n\nexport default SketchPage;\n"],"sourceRoot":""}