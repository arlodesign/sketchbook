{"version":3,"sources":["webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2020/02/22.js"],"names":["polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y","polarToCartesian","sketch","p","maxDist","cols","rows","gridWidth","gridHeight","HEX_WIDTH","sqrt","HUE","random","COMPLEMENT","hexagons","vertices","Hexagon","this","draw","beginShape","a","TWO_PI","vertex","endShape","points","probability","dist","width","height","pt","noise","push","setup","createCanvas","colorMode","HSB","background","floor","HEX_HEIGHT","hexX","hexY","HEX_RADIUS","stroke","fill","strokeWeight","forEach","hex","vector","reached","length","reachedVector","unreachedIndex","reachedVertices","filter","v","shortestDist","i","thisDist","line","noLoop","console","info","location","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2020-02-22-js-3c48be80d015312315fc.js","sourcesContent":["const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\n\n/**\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} angle\n * @param {number} distance\n * @param {bool} asArray\n */\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport polarToCartesian from \"~lib/polarToCartesian\";\n\nconst sketch = function(p) {\n  const HEX_RADIUS = 20;\n  const HEX_WIDTH = p.sqrt(3) * HEX_RADIUS;\n  const HEX_HEIGHT = HEX_RADIUS * 2;\n  const HUE = p.random();\n  const COMPLEMENT = 1 - HUE;\n  const WEIGHT = 5;\n\n  let hexagons = [];\n  let vertices = [];\n  let maxDist;\n  let cols;\n  let rows;\n  let gridWidth;\n  let gridHeight;\n\n  class Hexagon {\n    constructor(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    draw() {\n      p.beginShape();\n      for (let a = 0; a < p.TWO_PI; a += p.TWO_PI / 6) {\n        p.vertex(\n          ...polarToCartesian(\n            this.x,\n            this.y,\n            a + p.TWO_PI / 12,\n            HEX_RADIUS,\n            true\n          )\n        );\n      }\n      p.endShape();\n    }\n\n    get points() {\n      let points = [];\n\n      const probability =\n        p.dist(this.x, this.y, p.width / 2, p.height / 2) / maxDist;\n\n      for (let a = 0; a < p.TWO_PI; a += p.TWO_PI / 6) {\n        const pt = polarToCartesian(\n          this.x,\n          this.y,\n          a + p.TWO_PI / 12,\n          HEX_RADIUS\n        );\n\n        if (p.noise(pt.x, pt.y) / 4 < probability) {\n          points.push([pt.x, pt.y]);\n        }\n      }\n\n      p.noise(this.x, this.y) / 2 < probability &&\n        points.push([this.x, this.y]);\n\n      return points;\n    }\n  }\n\n  p.setup = function() {\n    p.createCanvas(660, 840);\n    p.colorMode(p.HSB, 1);\n    p.background(COMPLEMENT, 0.7, 0.5);\n\n    maxDist = p.dist(0, 0, p.width / 2, p.height / 2);\n    cols = p.floor((p.width - HEX_WIDTH / 2) / HEX_WIDTH);\n    rows = p.floor((p.width - HEX_HEIGHT / 4) / (HEX_HEIGHT * 0.75));\n    gridWidth = cols * HEX_WIDTH + HEX_WIDTH / 2;\n    gridHeight = rows * (HEX_HEIGHT * 0.75) + HEX_HEIGHT / 4;\n\n    for (let x = 0; x < cols; x++) {\n      for (let y = 0; y < rows; y++) {\n        const hexX =\n          x * HEX_WIDTH +\n          (y % 2 ? HEX_WIDTH : HEX_WIDTH / 2) +\n          (p.width - gridWidth) / 2;\n        const hexY =\n          y * HEX_HEIGHT * 0.75 + HEX_HEIGHT / 2 + (p.height - gridHeight) / 2;\n        p.noise(hexX, hexY) < 0.5 && hexagons.push(new Hexagon(hexX, hexY));\n      }\n    }\n\n    p.stroke(COMPLEMENT, 0.5, 0.7);\n    p.fill(COMPLEMENT, 0.5, 0.7);\n    p.strokeWeight(0.25);\n\n    hexagons.forEach(hex => {\n      hex.draw();\n      hex.points.forEach(([x, y]) =>\n        vertices.push({ vector: { x, y }, reached: false })\n      );\n    });\n\n    vertices[p.floor(p.random(vertices.length))].reached = true;\n\n    p.stroke(HUE, 0.8, 0.2);\n    p.strokeWeight(WEIGHT);\n  };\n\n  p.draw = function() {\n    const reachedVertices = vertices.filter(v => v.reached);\n    let shortestDist = maxDist;\n    let reachedVector;\n    let unreachedIndex;\n\n    vertices.forEach((vertex, i) => {\n      if (!vertex.reached) {\n        reachedVertices.forEach(({ vector }) => {\n          const thisDist = p.dist(\n            vector.x,\n            vector.y,\n            vertex.vector.x,\n            vertex.vector.y\n          );\n          if (thisDist < shortestDist) {\n            shortestDist = thisDist;\n            unreachedIndex = i;\n            reachedVector = vector;\n          }\n        });\n      }\n    });\n\n    p.line(\n      reachedVector.x + WEIGHT,\n      reachedVector.y + WEIGHT,\n      vertices[unreachedIndex].vector.x + WEIGHT,\n      vertices[unreachedIndex].vector.y + WEIGHT\n    );\n    vertices[unreachedIndex].reached = true;\n\n    if (vertices.filter(v => v.reached).length === vertices.length) {\n      p.noLoop();\n    } else {\n      console.info(\n        `${p.floor(\n          (vertices.filter(v => v.reached).length / vertices.length) * 100\n        )}%`\n      );\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout\n    sketch={sketch}\n    path={location.pathname}\n    description=\"Be patient. Reload page for a different variation.\"\n  />\n);\n"],"sourceRoot":""}