{"version":3,"sources":["webpack:///./src/pages/sketch/2019/01/19.js"],"names":["sketch","p","myFont","maxDist","vectors","preload","loadFont","withPrefix","setup","pixelDensity","createCanvas","background","stroke","string","split","points","forEach","str","line","concat","textToPoints","sampleFactor","i","x","y","noiseFactor","map","length","push","vector","createVector","noise","reached","reachedBy","dist","width","height","draw","distance","ceil","strokeWeight","reachedByIndex","unreachedIndex","shortestDist","uv","ui","rv","ri","thisDist","filter","v","noLoop","location","path","pathname"],"mappings":"iKAIMA,EAAS,SAASC,GACtB,IACIC,EAIAC,EAFAC,EAAU,GAIdH,EAAEI,QAAU,WACVH,EAASD,EAAEK,SAASC,qBAAW,gCAGjCN,EAAEO,MAAQ,WACRP,EAAEQ,aAAa,GACfR,EAAES,aAAa,IAAK,KACpBT,EAAEU,WAAW,GACbV,EAAEW,OAAO,KACT,IAAMC,EAAS,iDAAiDC,MAAM,MAClEC,EAAS,GACbF,EAAOG,SAAQ,SAACC,EAAKC,GACnBH,EAASA,EAAOI,OACdjB,EAAOkB,aAAaH,EAAK,GApBb,KAoB8BC,EAAO,GApBrC,IAoBoD,CAC9DG,aAAc,GAAKH,EAAO,SAIhCH,EAAOC,SAAQ,WAAWM,GAAO,IAAfC,EAAc,EAAdA,EAAGC,EAAW,EAAXA,EACbC,EAAcxB,EAAEyB,IAAIJ,EAAG,EAAGP,EAAOY,OAAQ,EAAG,GAClDvB,EAAQwB,KAAK,CACXC,OAAQ5B,EAAE6B,aACRP,EAAItB,EAAEyB,IAAIzB,EAAE8B,MAAMR,EAAGD,GAAI,EAAG,GAAIG,EAAaA,GAC7CD,EAAIvB,EAAEyB,IAAIzB,EAAE8B,MAAMP,EAAGF,GAAI,EAAG,GAAIG,EAAaA,IAE/CO,SAAS,EACTC,UAAW,OAGf7B,EAAQ,GAAG4B,SAAU,EACrB5B,EAAQ,GAAG6B,WAAa,EACxB9B,EAAUF,EAAEiC,KAAK,EAAG,EAAGjC,EAAEkC,MAAOlC,EAAEmC,SAGpCnC,EAAEoC,KAAO,WACPpC,EAAEU,WAAW,GACbP,EAAQY,SAAQ,WAAiCM,GAAO,IAArCO,EAAoC,EAApCA,OAAQG,EAA4B,EAA5BA,QAASC,EAAmB,EAAnBA,UAClC,GAAID,GAAWC,GAAa,EAAG,CAAC,IAAD,EACZ7B,EAAQ6B,GAAWJ,OAA5BN,EADqB,EACrBA,EAAGC,EADkB,EAClBA,EACLc,EAAWrC,EAAEsC,KAAKtC,EAAEiC,KAAKX,EAAGC,EAAGK,EAAON,EAAGM,EAAOL,IACtDvB,EAAEuC,aAAavC,EAAEyB,IAAIY,EAAU,EAAG,GAAI,EAAG,GAAG,IAC5CrC,EAAEiB,KAAKK,EAAGC,EAAGK,EAAON,EAAGM,EAAOL,OAGlC,IACIiB,EACAC,EAFAC,EAAexC,EAGnBC,EAAQY,SAAQ,SAAC4B,EAAIC,GACdD,EAAGZ,SACN5B,EAAQY,SAAQ,SAAC8B,EAAIC,GACnB,GAAID,EAAGd,QAAS,CACd,IAAMgB,EAAW/C,EAAEiC,KACjBU,EAAGf,OAAON,EACVqB,EAAGf,OAAOL,EACVsB,EAAGjB,OAAON,EACVuB,EAAGjB,OAAOL,GAERwB,EAAWL,IACbA,EAAeK,EACfN,EAAiBG,EACjBJ,EAAiBM,UAM3B3C,EAAQsC,GAAgBV,SAAU,EAClC5B,EAAQsC,GAAgBT,UAAYQ,EAEhCrC,EAAQ6C,QAAO,SAAAC,GAAC,OAAIA,EAAElB,WAASL,SAAWvB,EAAQuB,QACpD1B,EAAEkD,WAKO,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAcpD,OAAQA,EAAQqD,KAAMD,EAASE","file":"component---src-pages-sketch-2019-01-19-js-8caeddc322f6e383ab05.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\nimport { withPrefix } from \"gatsby\";\n\nconst sketch = function(p) {\n  const FONT_SIZE = 130;\n  let myFont;\n  let vectorCount;\n  let vectors = [];\n  let boundary;\n  let maxDist;\n\n  p.preload = function() {\n    myFont = p.loadFont(withPrefix(\"/assets/NewsCycle-Bold.ttf\"));\n  };\n\n  p.setup = function() {\n    p.pixelDensity(1);\n    p.createCanvas(660, 840);\n    p.background(0);\n    p.stroke(255);\n    const string = \"SELF-\\nESTEEM\\nSELF-\\nRELIANCE\\nSELF-\\nCONTROL\".split(\"\\n\");\n    let points = [];\n    string.forEach((str, line) => {\n      points = points.concat(\n        myFont.textToPoints(str, 25, FONT_SIZE * (line + 1), FONT_SIZE, {\n          sampleFactor: 1 / (line + 6),\n        })\n      );\n    });\n    points.forEach(({ x, y }, i) => {\n      const noiseFactor = p.map(i, 0, points.length, 0, 8);\n      vectors.push({\n        vector: p.createVector(\n          x + p.map(p.noise(x, i), 0, 1, -noiseFactor, noiseFactor),\n          y + p.map(p.noise(y, i), 0, 1, -noiseFactor, noiseFactor)\n        ),\n        reached: false,\n        reachedBy: 0,\n      });\n    });\n    vectors[0].reached = true;\n    vectors[0].reachedBy = -1;\n    maxDist = p.dist(0, 0, p.width, p.height);\n  };\n\n  p.draw = function() {\n    p.background(0);\n    vectors.forEach(({ vector, reached, reachedBy }, i) => {\n      if (reached && reachedBy > -1) {\n        const { x, y } = vectors[reachedBy].vector;\n        const distance = p.ceil(p.dist(x, y, vector.x, vector.y));\n        p.strokeWeight(p.map(distance, 5, 20, 1, 6, true));\n        p.line(x, y, vector.x, vector.y);\n      }\n    });\n    let shortestDist = maxDist;\n    let reachedByIndex;\n    let unreachedIndex;\n    vectors.forEach((uv, ui) => {\n      if (!uv.reached) {\n        vectors.forEach((rv, ri) => {\n          if (rv.reached) {\n            const thisDist = p.dist(\n              uv.vector.x,\n              uv.vector.y,\n              rv.vector.x,\n              rv.vector.y\n            );\n            if (thisDist < shortestDist) {\n              shortestDist = thisDist;\n              unreachedIndex = ui;\n              reachedByIndex = ri;\n            }\n          }\n        });\n      }\n    });\n    vectors[unreachedIndex].reached = true;\n    vectors[unreachedIndex].reachedBy = reachedByIndex;\n\n    if (vectors.filter(v => v.reached).length === vectors.length) {\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} />\n);\n"],"sourceRoot":""}