{"version":3,"sources":["webpack:///./src/pages/sketch/2019/01/13.js"],"names":["sketch","p","maxDist","gridSize","vectors","setup","pixelDensity","createCanvas","floor","random","x","y","xc","width","yc","height","dist","push","vector","createVector","reached","reachedBy","background","strokeWeight","fill","draw","ellipse","stroke","filter","v","forEach","point","pop","reachedByIndex","unreachedIndex","shortestDist","uv","ui","rv","ri","thisDist","i","noFill","line","triangle","length","noLoop","location","path","pathname","description"],"mappings":"mJAGMA,EAAS,SAASC,GACtB,IACIC,EACAC,EAFAC,EAAU,GAKdH,EAAEI,MAAQ,WACRJ,EAAEK,aAAa,GACfL,EAAEM,aAAa,IAAK,KACpBJ,EAAWF,EAAEO,MAAMP,EAAEQ,OAAO,GAAI,KAChC,IAAK,IAAIC,EAAI,EAAGA,GAAKP,EAAUO,IAC7B,IAAK,IAAIC,EAAI,EAAGA,GAAKR,EAAUQ,IAAK,CAClC,IAAMC,EAAKX,EAAEO,MAAOP,EAAEY,MAAQV,EAAYO,GACpCI,EAAKb,EAAEO,MAAOP,EAAEc,OAASZ,EAAYQ,GAEzCV,EAAEe,KAAKJ,EAAIE,EAAIb,EAAEY,MAAQ,EAAGZ,EAAEc,OAAS,GAAKd,EAAEY,MAAQ,EAAI,KAC1DZ,EAAEQ,SAAW,IAEbL,EAAQa,KAAK,CACXC,OAAQjB,EAAEkB,aAAaP,EAAIE,GAC3BM,SAAS,EACTC,UAAW,IAKnBjB,EAAQ,GAAGgB,SAAU,EACrBhB,EAAQ,GAAGiB,WAAa,EACxBnB,EAAUD,EAAEe,KAAK,EAAG,EAAGf,EAAEY,MAAOZ,EAAEc,QAClCd,EAAEqB,WAAW,GACbrB,EAAEsB,aAAa,GACftB,EAAEuB,KAAK,IAGTvB,EAAEwB,KAAO,WACPxB,EAAEuB,KAAK,KACPvB,EAAEyB,QACAzB,EAAEY,MAAQ,EACVZ,EAAEc,OAAS,EACXd,EAAEY,MAAQ,EAAI,IAAOZ,EAAEY,MAAQV,EAAY,GAE7CF,EAAEgB,OACFhB,EAAE0B,OAAkB,OACpBvB,EACGwB,QAAO,SAAAC,GAAC,OAAKA,EAAET,WACfU,SAAQ,gBAAGZ,EAAH,EAAGA,OAAH,OAAgBjB,EAAE8B,MAAMb,EAAOR,EAAGQ,EAAOP,MACpDV,EAAE+B,MACF,IACIC,EACAC,EAFAC,EAAejC,EAGnBE,EAAQ0B,SAAQ,SAACM,EAAIC,GACdD,EAAGhB,SACNhB,EAAQ0B,SAAQ,SAACQ,EAAIC,GACnB,GAAID,EAAGlB,QAAS,CACd,IAAMoB,EAAWvC,EAAEe,KACjBoB,EAAGlB,OAAOR,EACV0B,EAAGlB,OAAOP,EACV2B,EAAGpB,OAAOR,EACV4B,EAAGpB,OAAOP,GAER6B,EAAWL,IACbA,EAAeK,EACfN,EAAiBG,EACjBJ,EAAiBM,UAM3BnC,EAAQ8B,GAAgBd,SAAU,EAClChB,EAAQ8B,GAAgBb,UAAYY,EAEpC7B,EAAQ0B,SAAQ,WAAiCW,GAAO,IAArCvB,EAAoC,EAApCA,OAAQE,EAA4B,EAA5BA,QAASC,EAAmB,EAAnBA,UAClC,GAAID,GAAWC,GAAa,EAAG,CAAC,IAAD,EACZjB,EAAQiB,GAAWH,OAA5BR,EADqB,EACrBA,EAAGC,EADkB,EAClBA,EACXV,EAAE0B,OAAO,GACT1B,EAAEsB,aAAa,GACftB,EAAEyC,SACFzC,EAAE0C,KAAKzB,EAAOR,EAAGQ,EAAOP,EAAGD,EAAGC,GAC9BV,EAAEuB,KAAK,GACPvB,EAAEsB,aAAa,GACftB,EAAE2C,SAAS1B,EAAOR,EAAGQ,EAAOP,EAAGD,EAAGC,EAAGD,EAAGQ,EAAOP,GAC1CO,EAAOR,IAAMA,GAAKQ,EAAOP,IAAMA,GAAM8B,EAAI,GAAM,GAClDxC,EAAEyB,QAAQhB,EAAGC,EAAGV,EAAEe,KAAKN,EAAGC,EAAGO,EAAOR,EAAGQ,EAAOP,QAIhDP,EAAQwB,QAAO,SAAAC,GAAC,OAAIA,EAAET,WAASyB,SAAWzC,EAAQyC,QACpD5C,EAAE6C,WAKO,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAc/C,OAAQA,EAAQgD,KAAMD,EAASE,SAAUC,YAAY","file":"component---src-pages-sketch-2019-01-13-js-ab6cb9fa1f53111ae02d.js","sourcesContent":["import React from \"react\";\nimport SketchLayout from \"~components/sketch-layout\";\n\nconst sketch = function(p) {\n  let vectors = [];\n  let maxDist;\n  let gridSize;\n  let showDots = true;\n\n  p.setup = function() {\n    p.pixelDensity(1);\n    p.createCanvas(660, 840);\n    gridSize = p.floor(p.random(25, 50));\n    for (let x = 0; x <= gridSize; x++) {\n      for (let y = 0; y <= gridSize; y++) {\n        const xc = p.floor((p.width / gridSize) * x);\n        const yc = p.floor((p.height / gridSize) * y);\n        if (\n          p.dist(xc, yc, p.width / 2, p.height / 2) < p.width / 2 - 100 &&\n          p.random() < 0.5\n        ) {\n          vectors.push({\n            vector: p.createVector(xc, yc),\n            reached: false,\n            reachedBy: 0,\n          });\n        }\n      }\n    }\n    vectors[0].reached = true;\n    vectors[0].reachedBy = -1;\n    maxDist = p.dist(0, 0, p.width, p.height);\n    p.background(0);\n    p.strokeWeight(2);\n    p.fill(0);\n  };\n\n  p.draw = function() {\n    p.fill(255);\n    p.ellipse(\n      p.width / 2,\n      p.height / 2,\n      p.width / 2 + 100 + (p.width / gridSize) * 8\n    );\n    p.push();\n    p.stroke(showDots ? \"red\" : 255);\n    vectors\n      .filter(v => !v.reached)\n      .forEach(({ vector }) => p.point(vector.x, vector.y));\n    p.pop();\n    let shortestDist = maxDist;\n    let reachedByIndex;\n    let unreachedIndex;\n    vectors.forEach((uv, ui) => {\n      if (!uv.reached) {\n        vectors.forEach((rv, ri) => {\n          if (rv.reached) {\n            const thisDist = p.dist(\n              uv.vector.x,\n              uv.vector.y,\n              rv.vector.x,\n              rv.vector.y\n            );\n            if (thisDist < shortestDist) {\n              shortestDist = thisDist;\n              unreachedIndex = ui;\n              reachedByIndex = ri;\n            }\n          }\n        });\n      }\n    });\n    vectors[unreachedIndex].reached = true;\n    vectors[unreachedIndex].reachedBy = reachedByIndex;\n\n    vectors.forEach(({ vector, reached, reachedBy }, i) => {\n      if (reached && reachedBy > -1) {\n        const { x, y } = vectors[reachedBy].vector;\n        p.stroke(0);\n        p.strokeWeight(2);\n        p.noFill();\n        p.line(vector.x, vector.y, x, y);\n        p.fill(0);\n        p.strokeWeight(1);\n        p.triangle(vector.x, vector.y, x, y, x, vector.y);\n        if ((vector.x === x || vector.y === y) && i % 4 === 0) {\n          p.ellipse(x, y, p.dist(x, y, vector.x, vector.y));\n        }\n      }\n    });\n    if (vectors.filter(v => v.reached).length === vectors.length) {\n      p.noLoop();\n    }\n  };\n};\n\nexport default ({ location }) => (\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"Reload page for a different variation.\" />\n);\n"],"sourceRoot":""}